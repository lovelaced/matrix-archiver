<!doctype html><meta charset=utf-8>
<title>#graypaper:polkadot.io – archive</title>
<style>body{font:14px/1.45 ui-monospace,monospace;background:#111;color:#eee;padding:1em}.msg{white-space:pre-wrap}time{color:#888;margin-right:.5em}.u{font-weight:600}.reply{margin-left:2ch}a{color:#9cf;text-decoration:none}</style>
<h1>#graypaper:polkadot.io</h1>
<p><a href='room_log.txt'>⇩ plaintext</a>  ·  <a href='../../index.html'>⇦ all rooms</a></p>
<hr>
<div class='msg'><time>2024‑04‑17 20:29</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: https://matrix.to/#/!hyzRkDqDthePbodYFz:parity.io/$f_DMsIEcDXZegw6Sabnehzc-LrdDQkmq5MbxDDyoZxY?via=parity.io&amp;via=web3.foundation
</div>
<div class='msg'><time>2024‑04‑17 20:29</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: 
hmm it requires that each shard is diviasible by 64 not the number of available shards.</div>
<div class='msg'><time>2024‑04‑17 20:32</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: If we want to decode shards/segment that  are smaller than 64bytes then we have problem with using SIMD I think. Because neighbouring bytes are not encoded in the same polynomial. </div>
<div class='msg'><time>2024‑04‑17 20:33</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: so 64 bytes are encoded in 32 polynomials but each recover bytes with 32 bytes gap between them. </div>
<div class='msg'><time>2024‑04‑17 20:34</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: obviously we can rearrange the bytes before encoding but that kill the whole purpose of the SIMD.</div>
<div class='msg'><time>2024‑04‑17 20:37</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: If we are insisting on recovering less than 64-bytes at the time then maybe we shouldn&#x27;t use SIMD or we should use smaller registers perhaps.</div>
<div class='msg'><time>2024‑04‑17 21:00</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: gav: ^</div>
<div class='msg'><time>2024‑04‑18 06:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I just don&#x27;t see how you can have 341 of 1023 validators recover 64 bytes.</div>
<div class='msg'><time>2024‑04‑18 06:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: there&#x27;s not enough granularity.</div>
<div class='msg'><time>2024‑04‑18 06:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: how many bytes would they each store to recover those 64 bytes?</div>
<div class='msg'><time>2024‑04‑18 06:48</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: They each store 64*3 each have 3 shards</div>
<div class='msg'><time>2024‑04‑18 06:49</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: They recover 64*1023</div>
<div class='msg'><time>2024‑04‑18 06:49</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: Bytes in one go</div>
<div class='msg'><time>2024‑04‑18 06:50</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: They could get only two bytes out of those 64 and recover 1024*2</div>
<div class='msg'><time>2024‑04‑18 06:51</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: But those bytes are not consecutives</div>
<div class='msg'><time>2024‑04‑18 06:51</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: Two recover two consecutive bytes you need to recover 4</div>
<div class='msg'><time>2024‑04‑18 06:52</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: And they are part of the 1024 polynomial </div>
<div class='msg'><time>2024‑04‑18 06:52</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: Si you recover 4*1024</div>
<div class='msg'><time>2024‑04‑18 06:53</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: * So you recover 4*1024</div>
<div class='msg'><time>2024‑04‑18 07:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: ok so this is the minimal size you can recover at a time? 4*1024
</div>
<div class='msg'><time>2024‑04‑18 08:34</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: You can recover 2*1024 but they are non-consecative bytes</div>
<div class='msg'><time>2024‑04‑18 08:35</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: So you can recover 1024 and throw out the other 1024</div>
<div class='msg'><time>2024‑04‑18 08:35</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: That way you recover one byte from each sharf</div>
<div class='msg'><time>2024‑04‑18 08:42</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: It is just that up to 32 consecutive bytes you have to recover double amount but you get the next consecutive bytes for free.</div>
<div class='msg'><time>2024‑04‑18 10:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Ok. Hence the minimum sensible amount to recover is 4KB</div>
<div class='msg'><time>2024‑04‑19 06:36</time>&ensp;<span class='u' style='color:#c5378a'>aedigix</span>: How will metering be implemented in the RISC-V PVM?  

</div>
<div class='msg'><time>2024‑04‑19 07:06</time>&ensp;<span class='u' style='color:#c5378a'>aedigix</span>: https://docs.openhwgroup.org/projects/cv32e40x-user-manual/en/latest/perf_counters.html   </div>
<div class='msg'><time>2024‑04‑19 11:47</time>&ensp;<span class='u' style='color:#2979b3'>hitchhooker</span>: i dont think that current spec defines the metering methods. [reference implementation](https://github.com/koute/polkavm/blob/4ca06cc1b7cb435b2b92e81e30c2eb0e988f563e/crates/polkavm/src/compiler.rs#L88) of pvm has currently options for asyncronous and synchronous gas metering. async being nondeterministic and a bit faster running in separate core checking in if program is done. gas metering is still somewhat simple and imperfect([see initial posts bonus appendix dilemma](https://forum.polkadot.network/t/announcing-polkavm-a-new-risc-v-based-vm-for-smart-contracts-and-possibly-more/3811#appendix-bonus-section-or-why-does-it-smell-like-gas-here-18)), but [benchmarks](https://github.com/koute/polkavm/blob/4ca06cc1b7cb435b2b92e81e30c2eb0e988f563e/BENCHMARKS.md?plain=1#L13) have shown it to be fast enough to proceed. one [idea]((https://forum.polkadot.network/t/announcing-polkavm-a-new-risc-v-based-vm-for-smart-contracts-and-possibly-more/3811/21)) thrown out there was to use CPUs FPU for more exact/efficient deterministic metering.</div>
<div class='msg'><time>2024‑04‑19 18:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: the final metering spec is still being determined. it is heavily dependent on practical implementation speed on realistic hardware.</div>
<div class='msg'><time>2024‑04‑19 18:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * the final metering spec is still being determined. it is heavily dependent on practical implementation speed on realistic hardware, so will necessarily be in flux for some time.</div>
<div class='msg'><time>2024‑04‑19 18:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (for ethereum is was the very last protocol element we finalized)</div>
<div class='msg'><time>2024‑04‑19 18:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * (for ethereum is was the very last protocol element we finalized, and did so through performance analysis of the 3 impls)</div>
<div class='msg'><time>2024‑04‑19 18:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * (for ethereum is was the very last protocol element we finalized, and did so through performance analysis of the 3 impls; i expect we&#x27;ll do something fairly similar here, but with some research over how memory usage interacts with instruction speed)</div>
<div class='msg'><time>2024‑04‑19 18:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: we don&#x27;t expect async metering to be used.</div>
<div class='msg'><time>2024‑04‑19 18:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (and it&#x27;s not a reference implementation - it just happens to be the first:)</div>
<div class='msg'><time>2024‑04‑19 18:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * the final metering spec is still being determined. it is heavily dependent on practical implementation speed on realistic hardware, so will necessarily be in flux for some time as implementations arrive and evolve and hardware requirements are decided.</div>
<div class='msg'><time>2024‑04‑19 18:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * (for ethereum it was the very last protocol element we finalized, and did so through performance analysis of the 3 impls; i expect we&#x27;ll do something fairly similar here, but with some research over how memory usage interacts with instruction speed)</div>
<div class='msg'><time>2024‑04‑28 06:39</time>&ensp;<span class='u' style='color:#c5378a'>aedigix</span>: Is there any concerns with endianness for the choice of VM?  EVM is big-endian (not really sure the justification for this as I can&#x27;t find it in the YP)  </div>
<div class='msg'><time>2024‑04‑29 16:21</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Any concern about services intentionally inserting keys into the state trie whose hashes have a long common prefix? With the trie as specified this will result in long trie paths, with a bunch of branch nodes which have one half empty. Possibly could change the definition of M so that instead of always branching on b0 in the branch case you branch on the first bit such that l and r are non-empty? This would of course make the trie implementation more complicated and possibly ruin some optimisations.</div>
<div class='msg'><time>2024‑04‑29 16:57</time>&ensp;<span class='u' style='color:#c74b98'>alistair</span>: That doesn&#x27;t really solve the problem because if you can use brute force to find two hashes which agree on n bits then you can also with an extra 50% hash computations in expectation, find hashes with 1,2,3,..,n-1 bits of prefix agreeing with the first two hashes.  The only downside is that you now have to get n hashes included instead of 2.</div>
<div class='msg'><time>2024‑04‑29 16:58</time>&ensp;<span class='u' style='color:#c74b98'>alistair</span>:  * That doesn&#x27;t really solve the problem because if you can use brute force to find two hashes which agree on n bits then you can also with an extra 50% hash computations in expectation, find hashes with 1,2,3,..,n-1 bits of prefix agreeing with the first two hashes.  Now you still have a deth m tie. The only downside is that you now have to get n+1 hashes included instead of 2.</div>
<div class='msg'><time>2024‑04‑29 16:58</time>&ensp;<span class='u' style='color:#c74b98'>alistair</span>:  * That doesn&#x27;t really solve the problem because if you can use brute force to find two hashes which agree on n bits then you can also with an extra 50% hash computations in expectation, find hashes with 1,2,3,..,n-1 bits of prefix agreeing with the first two hashes.  Now you still have a deth n tie. The only downside is that you now have to get n+1 hashes included instead of 2.</div>
<div class='msg'><time>2024‑04‑29 16:58</time>&ensp;<span class='u' style='color:#c74b98'>alistair</span>:  * That doesn&#x27;t really solve the problem because if you can use brute force to find two hashes which agree on n bits then you can also with an extra 50% hash computations in expectation, find hashes with 1,2,3,..,n-1 bits of prefix agreeing with the first two hashes.  Now you still have a depth n trie. The only downside is that you now have to get n+1 hashes included instead of 2.</div>
<div class='msg'><time>2024‑04‑29 17:26</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: No it doesn&#x27;t solve the problem, but it reduces it to the same problem that currently exists in polkadot, so at least it&#x27;s not making it worse</div>
<div class='msg'><time>2024‑04‑29 17:28</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Maybe not the &quot;same&quot; problem as services don&#x27;t exist in polkadot, but you can do similar things with eg account keys</div>
<div class='msg'><time>2024‑04‑29 17:45</time>&ensp;<span class='u' style='color:#b9329c'>jeff</span>: &gt; &lt;@aedigix:matrix.org&gt; Is there any concerns with endianness for the choice of VM?  EVM is big-endian (not really sure the justification for this as I can&#x27;t find it in the YP)

I&#x27;d expect scale covers this.

Afaik big endian aka network byte order is used in network protocols because it makes testing more robust:  If you omit an endianness conversion in only one place then protocol implementations typically fail in testing on little endian machines.  There is no reason to use network byte order if everyone uses some library that enforces a particular convention, like say protobuf, which likely covers our case more or less.  Also, you could skip network byte when you have a very tightly specified protocol, like djb&#x27;s crypto like ed25519 uses little endian, because he&#x27;s fighting much bigger implementor risks, while older crypto specifications like secp256k1 often used big endian, just because they didn&#x27;t understand implementation risks, so they addresses only minor ones.  </div>
<div class='msg'><time>2024‑04‑29 17:49</time>&ensp;<span class='u' style='color:#b9329c'>jeff</span>: &gt; &lt;@aedigix:matrix.org&gt; Is there any concerns with endianness for the choice of VM?  EVM is big-endian (not really sure the justification for this as I can&#x27;t find it in the YP)

 * I&#x27;d expect scale covers this.

Afaik big endian aka network byte order is used in network protocols because it makes testing more robust:  If you omit an endianness conversion in only one place then protocol implementations typically fail in testing on little endian machines.  The bad situation this avoids is going into production with code that doesn&#x27;t work when ported to a big endian machine.  There is no reason to use network byte order if everyone uses some library that enforces a particular convention, like say protobuf, which likely covers our case more or less.  Also, you could skip network byte when you have a very tightly specified protocol, like djb&#x27;s crypto like ed25519 uses little endian, because he&#x27;s fighting much bigger implementor risks, while older crypto specifications like secp256k1 often used big endian, just because they didn&#x27;t understand implementation risks, so they addresses only minor ones.</div>
<div class='msg'><time>2024‑04‑29 20:02</time>&ensp;<span class='u' style='color:#8dbe5c'>arkadiy</span>: &gt; &lt;@dave:parity.io&gt; Any concern about services intentionally inserting keys into the state trie whose hashes have a long common prefix? With the trie as specified this will result in long trie paths, with a bunch of branch nodes which have one half empty. Possibly could change the definition of M so that instead of always branching on b0 in the branch case you branch on the first bit such that l and r are non-empty? This would of course make the trie implementation more complicated and possibly ruin some optimisations.

(127) `C(s,h)` definition Interleaves the hash of the key with the service id so that a service won&#x27;t be able to create common prefix chains in other service subtries with this kind of attack.</div>
<div class='msg'><time>2024‑04‑29 20:04</time>&ensp;<span class='u' style='color:#8dbe5c'>arkadiy</span>: &gt; &lt;@dave:parity.io&gt; Any concern about services intentionally inserting keys into the state trie whose hashes have a long common prefix? With the trie as specified this will result in long trie paths, with a bunch of branch nodes which have one half empty. Possibly could change the definition of M so that instead of always branching on b0 in the branch case you branch on the first bit such that l and r are non-empty? This would of course make the trie implementation more complicated and possibly ruin some optimisations.

 * (127) `C(s,h)` definition Interleaves the hash of the key with the service id to create the trie key. So that a service won&#x27;t be able to create common prefix chains in other service subtries with this kind of attack.</div>
<div class='msg'><time>2024‑04‑30 00:39</time>&ensp;<span class='u' style='color:#449ad3'>eclesiomelo</span>: just saw that the definition of header judgement mark is not accurate given that `t != 0` will include valid judgments also, so 107. `Hj ≡ [... t ≠⌊2/3V⌋ + 1]` looks correct, right?</div>
<div class='msg'><time>2024‑04‑30 00:40</time>&ensp;<span class='u' style='color:#449ad3'>eclesiomelo</span>:  * just saw that the definition of header judgement mark is not accurate given that `t != 0` will include valid judgments also, so 107. `Hj ≡ [r ∣⎧r, t⎫⎭&lt;− J, t ≠⌊2/3V⌋ + 1]` looks correct, right?</div>
<div class='msg'><time>2024‑04‑30 00:41</time>&ensp;<span class='u' style='color:#449ad3'>eclesiomelo</span>:  * just saw that the definition of header judgement mark is not accurate given that `t != 0` will include valid judgments also, so 107. `Hj ≡ [r | (r, t)&lt;− J, t ≠⌊2/3V⌋ + 1]` looks correct, right?</div>
<div class='msg'><time>2024‑04‑30 00:41</time>&ensp;<span class='u' style='color:#449ad3'>eclesiomelo</span>:  * just saw that the definition of header judgement mark is not accurate given that `t != 0` will include valid judgments also, so 107. `Hj ≡ [r | (r, t) &lt;− J, t ≠⌊2/3V⌋ + 1]` looks correct, right?</div>
<div class='msg'><time>2024‑04‑30 00:41</time>&ensp;<span class='u' style='color:#449ad3'>eclesiomelo</span>:  * just saw that the definition of header judgement mark is not accurate given that `t != 0` will include valid judgments also, so 107. `Hj ≡ [r | (r, t) &lt;− J, t ≠ ⌊2/3V⌋ + 1]` looks correct, right?</div>
<div class='msg'><time>2024‑05‑02 17:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@eclesiomelo:matrix.org&gt; just saw that the definition of header judgement mark is not accurate given that `t != 0` will include valid judgments also, so 107. `Hj ≡ [r | (r, t) &lt;− J, t ≠ ⌊2/3V⌋ + 1]` looks correct, right?

Yes thanks! that&#x27;ll be corrected in the next revision:)</div>
<div class='msg'><time>2024‑05‑02 17:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@eclesiomelo:matrix.org&gt; just saw that the definition of header judgement mark is not accurate given that `t != 0` will include valid judgments also, so 107. `Hj ≡ [r | (r, t) &lt;− J, t ≠ ⌊2/3V⌋ + 1]` looks correct, right?

 * Yes thanks - well spotted! that&#x27;ll be corrected in the next revision:)</div>
<div class='msg'><time>2024‑05‑08 09:18</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: `(17) β′ ≺(H,EG,β†,C)` what is the `C` here?</div>
<div class='msg'><time>2024‑05‑08 09:18</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-05-08 at 9.18.28 PM.png</div>
<div class='msg'><time>2024‑05‑08 09:18</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: this is the only reference of C that I can find</div>
<div class='msg reply'><time>2024‑05‑08 09:25</time>&ensp;<span class='u' style='color:#d06a65'>karim</span>: Screenshot from 2024-05-08 11-24-37.png</div>
<div class='msg reply'><time>2024‑05‑08 09:25</time>&ensp;<span class='u' style='color:#d06a65'>karim</span>: Maybe this? `\mathbf{C}` in the LaTeX for easier search / mapping.</div>
<div class='msg reply'><time>2024‑05‑08 09:52</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Thanks. That&#x27;s it.</div>
<div class='msg'><time>2024‑05‑08 09:19</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>:  * this is the only other reference of C that I can find</div>
<div class='msg'><time>2024‑05‑08 09:19</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: so it is just an intermediate variable? some output from `(EA,ρ′,δ†,χ,ι,φ)`?</div>
<div class='msg'><time>2024‑05‑10 03:43</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-05-10 at 3.43.10 PM.png</div>
<div class='msg'><time>2024‑05‑10 03:43</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: is this a typo? because the total length should be 336 bytes?</div>
<div class='msg'><time>2024‑05‑10 03:43</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-05-10 at 3.43.37 PM.png</div>
<div class='msg'><time>2024‑05‑11 10:14</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; so it is just an intermediate variable? some output from `(EA,ρ′,δ†,χ,ι,φ)`?

Exactly.</div>
<div class='msg'><time>2024‑05‑11 10:15</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; is this a typo? because the total length should be 336 bytes?

yes - thanks!</div>
<div class='msg'><time>2024‑05‑11 10:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: that&#x27;ll be fixed in the next revision.</div>
<div class='msg'><time>2024‑05‑23 08:42</time>&ensp;<span class='u' style='color:#349bb7'>helikon</span>: Hi, at the bottom of the left column of page 6, the set of all dictionaries, D, is defined as:</div>
<div class='msg'><time>2024‑05‑23 08:42</time>&ensp;<span class='u' style='color:#349bb7'>helikon</span>: `D ⊂ {{(k ↦ v)}}`</div>
<div class='msg'><time>2024‑05‑23 08:42</time>&ensp;<span class='u' style='color:#349bb7'>helikon</span>: Since D contains all dictionaries, shouldn&#x27;t it be:</div>
<div class='msg'><time>2024‑05‑23 08:42</time>&ensp;<span class='u' style='color:#349bb7'>helikon</span>: `D ⊃ {{(k ↦ v)}}`</div>
<div class='msg'><time>2024‑05‑23 08:42</time>&ensp;<span class='u' style='color:#349bb7'>helikon</span>: Or maybe even:</div>
<div class='msg'><time>2024‑05‑23 08:42</time>&ensp;<span class='u' style='color:#349bb7'>helikon</span>: `D ≡ {{(k ↦ v)}}`</div>
<div class='msg'><time>2024‑05‑23 08:42</time>&ensp;<span class='u' style='color:#349bb7'>helikon</span>: And on the right column of the same page, D is defined as:</div>
<div class='msg'><time>2024‑05‑23 08:42</time>&ensp;<span class='u' style='color:#349bb7'>helikon</span>: `D⟨K → V⟩ ⊂ D`</div>
<div class='msg'><time>2024‑05‑23 08:42</time>&ensp;<span class='u' style='color:#349bb7'>helikon</span>: which I think validates the initial correction. Thanks!</div>
<div class='msg'><time>2024‑05‑23 11:13</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: D excludes sets with duplicate keys, so seems like subset is accurate</div>
<div class='msg'><time>2024‑05‑23 11:44</time>&ensp;<span class='u' style='color:#349bb7'>helikon</span>: Ah, got it now thanks, I assumed uniqueness of keys.</div>
<div class='msg'><time>2024‑05‑23 11:48</time>&ensp;<span class='u' style='color:#349bb7'>helikon</span>:  * Ah, got it now thanks, I assumed uniqueness of keys. Actually the following (4) just explains that.</div>
<div class='msg'><time>2024‑05‑23 20:12</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: Will there be some more explanation on the 2/3+1 honesty assumption?  
What time-window is to be considered when evaluating this? Current session? Or something like current session + past session?</div>
<div class='msg'><time>2024‑05‑23 20:53</time>&ensp;<span class='u' style='color:#b9329c'>jeff</span>: I&#x27;d think the jam paper could just say &quot;byzantine assumption, including 2/3rd honest, for the current and previous sessions&quot;.

It&#x27;ll be the (machine) elves paper that clarifies our assumptions, but maybe not something jam should discuss to precisely, due to some technicalities: 

We make &quot;synchronous&quot; byzantine assumptions for the current session and all previous sessions, which includes that less than 1/3 of validators were miss-behaving, including being off-line.  We uses the &quot;network synchrony&quot; assumption only narrowly, and make a serious effort (no shows) to mitigate its weakness, which makes it less bad than it sounds. 

Arguably, we only require these assumption for the current and immediately previous session, so long as all parachains are all somehow appropriately publicly monitored.  We should not discuss this however since we cannot define this monitoring, and we&#x27;ll do things like elections on parachains, which probably do not satisfy such a monitoring condition.  And non-turnstiled zk parachains are likely eventually too.  It&#x27;s not worth discussing this.
</div>
<div class='msg'><time>2024‑05‑24 21:18</time>&ensp;<span class='u' style='color:#b9329c'>jeff</span>:  * I&#x27;d think the jam paper could just say &quot;byzantine assumptions, including 2/3rd honest, for the current and previous sessions&quot;.

It&#x27;ll be the (machine) elves paper that clarifies our assumptions, but maybe not something jam should discuss to precisely, due to some technicalities: 

We make &quot;synchronous&quot; byzantine assumptions for the current session and all previous sessions, which includes that less than 1/3 of validators were miss-behaving, including being off-line.  We uses the &quot;network synchrony&quot; assumption only narrowly, and make a serious effort (no shows) to mitigate its weakness, which makes it less bad than it sounds. 

Arguably, we only require these assumption for the current and immediately previous session, so long as all parachains are all somehow appropriately publicly monitored.  We should not discuss this however since we cannot define this monitoring, and we&#x27;ll do things like elections on parachains, which probably do not satisfy such a monitoring condition.  And non-turnstiled zk parachains are likely eventually too.  It&#x27;s not worth discussing this.
</div>
<div class='msg'><time>2024‑05‑27 07:27</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-05-27 at 7.25.01 PM.png</div>
<div class='msg'><time>2024‑05‑27 07:27</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: The formula doesn&#x27;t appear to be matching with the description?</div>
<div class='msg'><time>2024‑05‑27 08:57</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It might need to be reworded slightly.</div>
<div class='msg'><time>2024‑05‑27 08:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It intention was that `a` always has 3 elements, but the last element, and only the last, may potentially be None.</div>
<div class='msg'><time>2024‑05‑27 08:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * the formula is correct; the text needs to be reworded slightly.</div>
<div class='msg'><time>2024‑05‑27 08:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * The intention was that `a` always has 3 elements, but the last element, and only the last, may potentially be None.</div>
<div class='msg'><time>2024‑05‑27 09:02</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: so it is something like`((Sig, Idx), (Sig, Idx), Optional&lt;(Sig, Idx)&gt;)`?</div>
<div class='msg'><time>2024‑05‑27 09:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Implementation wise, sure</div>
<div class='msg'><time>2024‑05‑27 09:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Or you can have an array 2 or 3 items large</div>
<div class='msg'><time>2024‑05‑27 09:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Or you can have an array/vec 2 or 3 items large</div>
<div class='msg'><time>2024‑06‑04 10:04</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: </div>
<div class='msg'><time>2024‑06‑04 10:05</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-06-04 at 10.05.34 PM.png</div>
<div class='msg'><time>2024‑06‑04 10:06</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Just to confirm, the Bandersnatch public key size is 32 bytes?</div>
<div class='msg'><time>2024‑06‑04 10:07</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: https://github.com/paritytech/polkadot-sdk/blob/f0ac3310eed91bd4f72811136b685b4a80a06c45/substrate/primitives/core/src/bandersnatch.rs#L46 it is 33 here</div>
<div class='msg'><time>2024‑06‑04 10:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: [@davxy:matrix.org](https://matrix.to/#/@davxy:matrix.org)^^^?</div>
<div class='msg'><time>2024‑06‑04 10:17</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: &gt; &lt;@xlchen:matrix.org&gt; Just to confirm, the Bandersnatch public key size is 32 bytes?

Yes</div>
<div class='msg'><time>2024‑06‑04 10:18</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: It is in compressed twisted Edwards form.</div>
<div class='msg'><time>2024‑06‑04 10:18</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: Similar to Zcash</div>
<div class='msg'><time>2024‑06‑04 10:19</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: We are moving to twisted Edwards form partially to save that one byte</div>
<div class='msg'><time>2024‑06‑04 11:53</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: Confirmed. </div>
<div class='msg'><time>2024‑06‑06 08:15</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-06-06 at 8.15.18 PM.png</div>
<div class='msg'><time>2024‑06‑06 08:16</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: it said there are 3 items in the judgement state but the formula have 4?</div>
<div class='msg'><time>2024‑06‑06 08:16</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-06-06 at 8.16.35 PM.png</div>
<div class='msg'><time>2024‑06‑06 08:16</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: so does the serialization formula</div>
<div class='msg'><time>2024‑06‑06 08:17</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: `We store the last epoch’s validator set in ψk:`</div>
<div class='msg'><time>2024‑06‑06 08:17</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: and `λ: The validator keys and metadata which were active in the prior epoch.`</div>
<div class='msg'><time>2024‑06‑06 08:19</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: what&#x27;s the difference between those?</div>
<div class='msg'><time>2024‑06‑06 09:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yeah that&#x27;s old - the stuff about psi_k can be removed.</div>
<div class='msg'><time>2024‑06‑06 09:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Yeah that&#x27;s old - the stuff about psi\_k should have been removed.</div>
<div class='msg'><time>2024‑06‑06 09:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (It used to contain what lambda now contains)</div>
<div class='msg'><time>2024‑06‑06 09:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Will be removed shortly.</div>
<div class='msg'><time>2024‑06‑10 10:14</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-06-10 at 10.14.02 PM.png</div>
<div class='msg'><time>2024‑06‑10 10:15</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I guess one of it is wrong?</div>
<div class='msg'><time>2024‑06‑10 12:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yeah - the top one needs removing</div>
<div class='msg'><time>2024‑06‑10 12:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Will be done in the next update</div>
<div class='msg'><time>2024‑06‑10 18:19</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: Bryan Chen | Laminar &amp; Acala: https://github.com/gavofyork/graypaper/pull/13</div>
<div class='msg'><time>2024‑06‑11 20:49</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: While this is a minor point, I think it is aligned with the intention of maintaining the formal rigor intended in the graypaper. 

I feel there is some inconsistency in terminology concerning &quot;integer&quot; versus &quot;natural numbers.&quot; Specifically, when adhering to Section 3.4 (numbers), I believe that the text in sections like 3.6 should use use natural instead of &quot;integer&quot; to be consistent with the corresponding math expressions ($\N$, etc.). This happens in various other sections as well, where talking about natural numbers or positive integers (unsigned?) would be more appropriate than just &quot;integers&quot;

Generally, the mathematical expressions are accurate, but the narrative often uses &quot;integer&quot; in a broader sense. I think this is due to how the term is used in programming (unsigned integers, etc.) rather that math.

This inconsistency becomes particularly evident in Appendix C.1.2, where the encoding is defined solely for natural numbers, and there is no mention at all about how negative values should be handled. Also, I don&#x27;t seem to find any real need for serializing negative integers. Probably this section could be restricted to only encoding natural numbers and this shoud be enough.

If useful, I am glad to review and make a PR with suggestions addressing this along the text.
</div>
<div class='msg'><time>2024‑06‑11 20:52</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * While this is a minor point, I think it is aligned with the intention of maintaining the formal rigor intended in the graypaper.

I feel there is some inconsistency in terminology concerning &quot;integer&quot; versus &quot;natural numbers.&quot; Specifically, when adhering to Section 3.4 (numbers), I believe that the text in sections like 3.6 should use use natural instead of &quot;integer&quot; to be consistent with the corresponding math expressions ($\\N$, etc.). This happens in various other sections as well, where talking about natural numbers or positive integers (unsigned?) would be more appropriate than just &quot;integers&quot;

Generally, the mathematical expressions are accurate, but the narrative often uses &quot;integer&quot; in a broader sense. I think this is due to how the term is used in programming (unsigned integers, etc.) rather than math.

This inconsistency becomes particularly evident in Appendix C.1.2, where the encoding is defined solely for natural numbers, and there is no mention at all about how negative values should be handled. Also, I don&#x27;t seem to find any real need for serializing negative integers. Probably this section could be restricted to only encoding natural numbers and this shoud be enough.

If useful, I am glad to review and make a PR with suggestions addressing this along the text.</div>
<div class='msg'><time>2024‑06‑11 21:09</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: ...
I have also a few of questions about C.2. .. (262) (263)

- why is H_j not included when serializing the header? is that correct or an unintentional omission?

- why there is a claim that E_U(H) has &quot;no inverse&quot;? wouldn&#x27;t that imply that there is no way to decode a serialized header?
</div>
<div class='msg'><time>2024‑06‑11 21:11</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * ...
I have also a few of questions about C.2. .. (262) (263)

- why is H\_j not included when serializing the header? is that correct or an unintentional omission?
- why there is a claim that E\_U(H) has &quot;no inverse&quot;? wouldn&#x27;t that imply that there is no way to decode a serialized header? (In C.1. &quot;...We define the deserialization function E−1 = E−1 as the inverse of E and able to decode some sequence into the original value....&quot;</div>
<div class='msg'><time>2024‑06‑11 21:21</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: ....
5. Header
&quot;... Excepting the Genesis header, all block headers H have an associated parent header, whose hash is H_p...&quot;

but expression (264) for header serialization does not indicate optionality (?H_p). So should there be some exception or fixed value defined for the genesis? For instance, like H_p for H^0 is defined as some fixed preestablished value? </div>
<div class='msg'><time>2024‑06‑11 21:22</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * ....
5. Header
&quot;... Excepting the Genesis header, all block headers H have an associated parent header, whose hash is H\_p...&quot;

but expression (263) for header serialization does not indicate optionality (?H\_p). So should there be some exception or fixed value defined for the genesis? For instance, like H\_p for H^0 is defined as some fixed preestablished value? </div>
<div class='msg'><time>2024‑06‑11 21:23</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * ....
5. Header
&quot;... Excepting the Genesis header, all block headers H have an associated parent header, whose hash is H\_p...&quot;

but expression (263) for header serialization does not indicate optionality (?H\_p). So should there be some exception or fixed value for the genesis case? For instance, like H\_p for H^0 is defined as some fixed preestablished value?</div>
<div class='msg'><time>2024‑06‑11 21:27</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * ....
5. Header
&quot;... Excepting the Genesis header, all block headers H have an associated parent header, whose hash is H\_p...&quot;

but expression (263) for header serialization does not indicate optionality (?H\_p). So should there be some exception or fixed value for the genesis case? For instance, like H\_p for H^0 is defined as some fixed preestablished value?

or instead, the serialization of H^0 is a special case that should be explicitely included in C.2 and H_p is not encoded? </div>
<div class='msg'><time>2024‑06‑11 21:39</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: image.png</div>
<div class='msg'><time>2024‑06‑11 21:40</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: in the case of 38, the hash is done over the encoded Extrinsic...  H(E(E))
I believe that 36 is missing the encoding function E to be consistent.. so... H(E(P(H)))</div>
<div class='msg'><time>2024‑06‑11 21:41</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * in the case of 38, the hash is done over the encoded Extrinsic...  H(E(E)), which makes sense..
I believe that 36 is missing the encoding function E to be consistent.. so... H(E(P(H)))</div>
<div class='msg'><time>2024‑06‑11 21:41</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * in the case of 38, the hash is done over the encoded Extrinsic...  H(E(E)), which makes sense..
I believe that 36 is missing the encoding function E to be consistent.. so... H_p = H(E(P(H)))
otherwise, maybe it would be worth indicating somewhere that hashing implies encoding?</div>
<div class='msg'><time>2024‑06‑11 21:44</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * ....
5. Header
&quot;... Excepting the Genesis header, all block headers H have an associated parent header, whose hash is H\_p...&quot;

but expression (263) for header serialization does not indicate optionality (?H\_p). So should there be some exception or fixed value for the genesis case? For instance, like H\_p for H^0 is defined as some fixed preestablished value?

or instead, the serialization of H^0 is a special case that should be explicitely indicated in C.2 that H\_p should not be encoded for H^0?</div>
<div class='msg'><time>2024‑06‑12 04:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@purpletentacle:matrix.org&gt; ...
&gt; I have also a few of questions about C.2. .. (262) (263)
&gt; 
&gt; - why is H\_j not included when serializing the header? is that correct or an unintentional omission?
&gt; - why there is a claim that E\_U(H) has &quot;no inverse&quot;? wouldn&#x27;t that imply that there is no way to decode a serialized header? (In C.1. &quot;...We define the deserialization function E−1 = E−1 as the inverse of E and able to decode some sequence into the original value....&quot;

- unintended. Feel free to create an issue. I’ll sort it in the next revision. 
- where exactly does it say E_U(H) cannot have an inverse?</div>
<div class='msg'><time>2024‑06‑12 04:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@purpletentacle:matrix.org&gt; ....
&gt; 5. Header
&gt; &quot;... Excepting the Genesis header, all block headers H have an associated parent header, whose hash is H\_p...&quot;
&gt; 
&gt; but expression (263) for header serialization does not indicate optionality (?H\_p). So should there be some exception or fixed value for the genesis case? For instance, like H\_p for H^0 is defined as some fixed preestablished value?
&gt; 
&gt; or instead, the serialization of H^0 is a special case that should be explicitely indicated in C.2 that H\_p should not be encoded for H^0?

Yeah - it would likely be zeroes. The genesis header and state are not yet defined in the protocol. </div>
<div class='msg'><time>2024‑06‑12 04:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@purpletentacle:matrix.org&gt; ....
&gt; 5. Header
&gt; &quot;... Excepting the Genesis header, all block headers H have an associated parent header, whose hash is H\_p...&quot;
&gt; 
&gt; but expression (263) for header serialization does not indicate optionality (?H\_p). So should there be some exception or fixed value for the genesis case? For instance, like H\_p for H^0 is defined as some fixed preestablished value?
&gt; 
&gt; or instead, the serialization of H^0 is a special case that should be explicitely indicated in C.2 that H\_p should not be encoded for H^0?

* Yeah. It’s not optional; genesis is a very special case and it makes no sense to complicate the protocol due to it. It will likely just be defined as zeroes. The genesis header and state are not yet defined in the protocol. </div>
<div class='msg'><time>2024‑06‑12 04:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@purpletentacle:matrix.org&gt; in the case of 38, the hash is done over the encoded Extrinsic...  H(E(E)), which makes sense..
&gt; I believe that 36 is missing the encoding function E to be consistent.. so... H_p = H(E(P(H)))
&gt; otherwise, maybe it would be worth indicating somewhere that hashing implies encoding?

I believe it is mentioned previously that when hashing, values are assumed to be encoded with the regular serialisation function if they are not explicitly so. </div>
<div class='msg'><time>2024‑06‑12 04:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I think I’ve generally made it explicit but as it is unambiguous I gave the option for omission particularly to help improve readability of some longer formulae. </div>
<div class='msg'><time>2024‑06‑16 12:53</time>&ensp;<span class='u' style='color:#39bc2a'>ltfschoen</span>: </div>
<div class='msg'><time>2024‑06‑16 12:54</time>&ensp;<span class='u' style='color:#39bc2a'>ltfschoen</span>:  * it says here https://jam.web3.foundation/rules that &quot;Clean-room implementation using the Graypaper and public implementor chat channels as the only resources.&quot;.

it is my understanding that the Graypaper chat channel is https://matrix.to/#/#graypaper:polkadot.io

where are the &quot;public implementer&quot; chat channels?

and is there a reason why it doesn&#x27;t include the Jam chat channel here https://matrix.to/#/#jam:polkadot.io?

also, it says &quot;Each team is only allowed to work on one implementation&quot;, but in the application form it says &quot;What programming language(s) are you using and which language set are you applying for? e.g. &quot;Rust, set B&quot;, so i don&#x27;t understand why it&#x27;s asking us &quot;What programming language(s) are you using&quot;. is it just wanting to know if we&#x27;ll be using multiple languages in the our single implementation (e.g. if we&#x27;ll be doing an implementation in Rust and using FFI from Ruby and Python then we&#x27;d answer `Rust, Ruby, Python, set B`?

i was actually going to try and work on multiple implementations using multiple language sets (e.g. Rust, Swift Ruby, Python, TS) in parallel as a contingency incase i got stuck and couldn&#x27;t get support with one of them. after submission of our initial application form, will be possible for us to later on change what programming language(s) and language set that we&#x27;ll be using for the one implementation that could be eligible for the JAM prize?</div>
<div class='msg'><time>2024‑06‑16 14:48</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: Definitions 284 and 291 both define function M_S, just with different arity. The definition section also mentions it twice:  
</div>
<div class='msg'><time>2024‑06‑16 14:48</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: Screenshot 2024-06-16 at 16.48.36.png</div>
<div class='msg'><time>2024‑06‑16 14:48</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: Screenshot 2024-06-16 at 16.48.46.png</div>
<div class='msg'><time>2024‑06‑16 14:49</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: Screenshot 2024-06-16 at 16.48.57.png</div>
<div class='msg'><time>2024‑06‑16 14:50</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: Is it supposed to be disambiguated by their arity, or is it a name clash?</div>
<div class='msg'><time>2024‑06‑16 16:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: They’re meant to be different functions. The name clash is an oversight. </div>
<div class='msg'><time>2024‑06‑18 03:05</time>&ensp;<span class='u' style='color:#abc062'>mkalohood</span>: </div>
<div class='msg'><time>2024‑06‑18 03:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@aedigix:matrix.org&gt; Is there any concerns with endianness for the choice of VM?  EVM is big-endian (not really sure the justification for this as I can&#x27;t find it in the YP)

AFAIK there wasn&#x27;t an especially good reason for it other than it made sense from a mathematician&#x27;s perspective.</div>
<div class='msg'><time>2024‑06‑18 03:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: In any case modern architectures are either natively LE or have LE-compatibility modes, so it makes sense on the VM side to stick with LE.</div>
<div class='msg'><time>2024‑06‑18 03:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: As for serialization, it&#x27;ll be SCALE.</div>
<div class='msg'><time>2024‑06‑18 03:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * As for serialization, it&#x27;ll be SCALE, so LE also.</div>
<div class='msg'><time>2024‑06‑18 03:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * As for serialization, it&#x27;ll be SCALE, so LE also. This can already be seen via the definitions for the encode function.</div>
<div class='msg'><time>2024‑06‑18 03:15</time>&ensp;<span class='u' style='color:#abc062'>mkalohood</span>: miss deleting.  The big endian and the little endian have two related concepts: 1. Host order: Different CPUs process data with different byte order types.  Intel X86 CPU is little endian, mips architecture CPU is big endian. 
2, network order, the network transmits data in the way of byte stream, and the byte order type in the transmission process is called network order. It is independent of the CPU/OS type of other specific devices, ensuring that it can be resolved correctly when transferred between different devices. it defines the byte order as the big endian. 

So basically the big endian is used before the network data is sent.

But , I don&#x27;t think the big endian is the deciding factor in VM selection. I think we can take it apart. The VM communication layer and data operation management can be separated.</div>
<div class='msg'><time>2024‑06‑18 03:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * - H\_j is not serialized but implied by E\_J.
- where exactly does it say E\_U(H) cannot have an inverse?</div>
<div class='msg'><time>2024‑06‑18 03:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@purpletentacle:matrix.org&gt; ...
&gt; I have also a few of questions about C.2. .. (262) (263)
&gt; 
&gt; - why is H\_j not included when serializing the header? is that correct or an unintentional omission?
&gt; - why there is a claim that E\_U(H) has &quot;no inverse&quot;? wouldn&#x27;t that imply that there is no way to decode a serialized header? (In C.1. &quot;...We define the deserialization function E−1 = E−1 as the inverse of E and able to decode some sequence into the original value....&quot;

On the first point, H_j is not serialized - it&#x27;s auxilliary data implied through E_J. </div>
<div class='msg'><time>2024‑06‑18 03:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@gav:polkadot.io&gt; - H\_j is not serialized but implied by E\_J.
&gt; - where exactly does it say E\_U(H) cannot have an inverse?

On the second point &quot;the latter has no inverse&quot;, it was merely meant to state that no function `D_U(Y) -&gt; H` was defined explicitly. However, I removed it as it&#x27;s clearly misleading.</div>
<div class='msg'><time>2024‑06‑18 03:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@gav:polkadot.io&gt; I believe it is mentioned previously that when hashing, values are assumed to be encoded with the regular serialisation function if they are not explicitly so.

I made this explicit now.</div>
<div class='msg'><time>2024‑06‑19 13:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 0.2.1 of the paper is tagged and released. </div>
<div class='msg'><time>2024‑06‑19 20:15</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: image.png</div>
<div class='msg'><time>2024‑06‑19 20:15</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: sorry to insist on this point.. but it is not 100% clear to me

</div>
<div class='msg'><time>2024‑06‑19 20:16</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * sorry to insist on this point.. but it is not 100% clear to me
36) defines the header as including H_J

but later it is not included

</div>
<div class='msg'><time>2024‑06‑19 20:16</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: image.png</div>
<div class='msg'><time>2024‑06‑19 20:17</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: and when deserializing, it should be kept as ?H_j (optional) in the extrinsic E_J is not available? </div>
<div class='msg'><time>2024‑06‑19 20:18</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: </div>
<div class='msg'><time>2024‑06‑19 20:18</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * I find a bit odd that H is defined as &quot;containing&quot; H\_j when it is actually always external to it  </div>
<div class='msg'><time>2024‑06‑19 20:18</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: maybe I am missing something?</div>
<div class='msg'><time>2024‑06‑19 20:19</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * and when deserializing, it should be kept as ?H\_j (optional) if the corresponding extrinsic E\_J is not available? </div>
<div class='msg'><time>2024‑06‑19 20:20</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * is it fair to assume that the seal applies to the encoded header, an as a consequence is it will never include H_j ?</div>
<div class='msg'><time>2024‑06‑19 20:20</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * is it fair to assume that the seal applies to the encoded header, an as a consequence, it will never include H_j ?</div>
<div class='msg'><time>2024‑06‑19 20:21</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * is it fair to assume that the seal applies to the encoded header, an as a consequence, it will never include H\_j ?

if that is the case, when is H_j relevant or useful?</div>
<div class='msg'><time>2024‑06‑19 20:44</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * and when deserializing, it should be kept as ?H\_j = None (optional) if the corresponding extrinsic E\_J is not available?</div>
<div class='msg'><time>2024‑06‑19 21:02</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * is it fair to assume that the seal applies to the encoded header, an as a consequence, it will never include H\_j ?
if that is the case, when is H\_j relevant or useful? 

Btw, I see the definition later at 10.3 but I am still a bit confused by how this is described.</div>
<div class='msg'><time>2024‑06‑19 21:04</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * Btw, I see the definition later at 10.3 but I am still a bit confused and unsure about this value being part of the header or not.. 
is it fair to assume that the seal applies to the encoded header, an as a consequence, it will never include H\_j ?
if that is the case, when is H\_j relevant or useful?
</div>
<div class='msg'><time>2024‑06‑19 23:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@purpletentacle:matrix.org&gt; Btw, I see the definition later at 10.3 but I am still a bit confused and unsure about this value being part of the header or not.. 
&gt; is it fair to assume that the seal applies to the encoded header, an as a consequence, it will never include H\_j ?
&gt; if that is the case, when is H\_j relevant or useful?
&gt; 

You’re right - it’s not especially clear and I’ll clarify it for the next minor revision. As of 0.2.1, it doesn’t get serialised or deserialised but is just defined as an equivalence based on the value of E_J. It is used in the definition of Safrole, equation 56. However, in future versions of the spec this may change and it may be featured in the encoding of the header.</div>
<div class='msg'><time>2024‑06‑19 23:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@purpletentacle:matrix.org&gt; Btw, I see the definition later at 10.3 but I am still a bit confused and unsure about this value being part of the header or not.. 
&gt; is it fair to assume that the seal applies to the encoded header, an as a consequence, it will never include H\_j ?
&gt; if that is the case, when is H\_j relevant or useful?
&gt; 

* Yes it’s not especially clear and I’ll clarify it for the next minor revision. As of 0.2.1, it doesn’t get serialised or deserialised but is just defined as an equivalence based on the value of E_J. It is used in the definition of Safrole, equation 56. However, in future versions of the spec this may change and it may be featured in the encoding of the header.</div>
<div class='msg'><time>2024‑06‑21 04:17</time>&ensp;<span class='u' style='color:#6ecf94'>qiwei</span>: image.png</div>
<div class='msg'><time>2024‑06‑21 04:17</time>&ensp;<span class='u' style='color:#6ecf94'>qiwei</span>: something missing here for 0.2.1</div>
<div class='msg'><time>2024‑06‑21 08:37</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: ```
The judgements state includes three items, an allow-set ($\psi_\mathbf{a}$), a ban-set ($\psi_\mathbf{b}$) and a punish-set ($\psi_\mathbf{p}$). The allow-set contains the hashes of all work-reports which were disputed and judged to be accurate. The ban-set contains the hashes of all work-reports which were disputed and whose accuracy could not be confidently confirmed. The punish-set is a set of keys of Bandersnatch keys which were found to have guaranteed a report which was confidently found to be invalid.
\begin{equation}
  \psi \equiv \tup{\psi_\mathbf{a}, \psi_\mathbf{b}, \psi_\mathbf{p}, \psi_\mathbf{k}}
\end{equation}

`\subsection{Extrinsic}


```

it looks like a misplaced backtick.. I would say it can be ignored </div>
<div class='msg reply'><time>2024‑06‑21 09:29</time>&ensp;<span class='u' style='color:#6ecf94'>qiwei</span>: I see, from the [commit history](https://github.com/gavofyork/graypaper/commit/973ca32b7fa6e52e3d19eda7bfb1c7019067f32a), maybe there are a few other occurences of `\psi_\mathbf{k}` need to be removed</div>
<div class='msg'><time>2024‑06‑21 09:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@qiwei:matrix.org&gt; something missing here for 0.2.1

Yes there’s an error there, the latter component should have been removed. </div>
<div class='msg'><time>2024‑06‑21 09:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It will be fixed in the next revision but feel free to place an issue. </div>
<div class='msg'><time>2024‑06‑21 09:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@purpletentacle:matrix.org&gt; ```
&gt; The judgements state includes three items, an allow-set ($\psi_\mathbf{a}$), a ban-set ($\psi_\mathbf{b}$) and a punish-set ($\psi_\mathbf{p}$). The allow-set contains the hashes of all work-reports which were disputed and judged to be accurate. The ban-set contains the hashes of all work-reports which were disputed and whose accuracy could not be confidently confirmed. The punish-set is a set of keys of Bandersnatch keys which were found to have guaranteed a report which was confidently found to be invalid.
&gt; \begin{equation}
&gt;   \psi \equiv \tup{\psi_\mathbf{a}, \psi_\mathbf{b}, \psi_\mathbf{p}, \psi_\mathbf{k}}
&gt; \end{equation}
&gt; 
&gt; `\subsection{Extrinsic}
&gt; 
&gt; 
&gt; ```
&gt; 
&gt; it looks like a misplaced backtick.. I would say it can be ignored 

Again, will be fixed in next revision. </div>
<div class='msg'><time>2024‑06‑23 13:40</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: For Appendix B.6 (General), B.7 (Accumulate) and Appendix B.8 (Refine) functions:
1. For ω parameter inputs, I did not understand why the number of parameters on the left hand side did not equal that of the right hand side:
  - lookup [h_o, b_0, b_z] = w_{1..4}  (3 vs 4) but then w_0 is used so ... ok
  - read [k_o, k_z, b_o, b_z] = w_{1..5} (4 vs 5) but then w_0 is used so .. ok
  - write [k_o, k_z, v_o, v_z] = w_{0..4} (4 vs 5) but there is no w_4 ... huh?
  - new  [o,l,g_l, g_h, m_l, m_h] = w_{0..6} (6 vs 7) ... huh?
  ...
  - machine [p_o, p_z, i] = w_{0..3} (3 vs 4)
  - peek [n,a,b,l] = w_{0..4} (4 vs 5)
  ...
  Then you use w_0&#x27; as a return parameter which has nothing to do with the input w_0, huh.
2. At least a line or two describing the each function, specifically referencing these w (\omega) parameters would help a lot!
3. I believe most of the functions probably deserve at least a passing reference in the main body, or solid exposition around present (242), (246), (252).  We can guess import+export+historical_lookup but nothing references what peek, poke, machine, assign, delegate, quit (?), ... do yet.  
4. invoke = 13 is a copy of solicit and surely deserves a different name to the invoke = 20, like invoke_accumulate vs invoke_refine.  
5. Not clear what&#x27;s going on with numbers:
  - new&#x27;s bump function 42, 9
  - designate&#x27;s 176
  - invoke=20&#x27;s 13 and 60
6. Not clear why all these 64-bit parameters (g, a, m) have to be split into 2 32-bit and joined back together?
7. A diagram for the whole DA system would be worth a thousand words.
8. If you don&#x27;t want to add more exposition because you want hyper compactness  ok I get it but maybe using https://en.wikibooks.org/wiki/LaTeX/Macros will allow implementers to disambiguate notation by just reading latex (?!)

(Feel free to ignore most of the above, not very confident, just learning =))  </div>
<div class='msg'><time>2024‑06‑23 14:58</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * For Appendix B.6 (General), B.7 (Accumulate) and Appendix B.8 (Refine) functions:

1. For ω parameter inputs, I did not understand why the number of parameters on the left hand side did not equal that of the right hand side:

- lookup \[h\_o, b\_0, b\_z\] = ω\_{1..4}  (3 vs 4) but then ω\_0 is used so ... ok
- read \[k\_o, k\_z, b\_o, b\_z\] = ω\_{1..5} (4 vs 5) but then w\_0 is used so .. ok
- write \[k\_o, k\_z, v\_o, v\_z\] = ω\_{0..4} (4 vs 5) but there is no w\_4 ... huh?
- new  \[o,l,g\_l, g\_h, m\_l, m\_h\] = ω\_{0..6} (6 vs 7) ... huh?
...
- machine \[p\_o, p\_z, i\] = ω\_{0..3} (3 vs 4)
- peek \[n,a,b,l\] = ω\_{0..4} (4 vs 5)
...
 Then you use ω\_0&#x27; as a return parameter which has nothing to do with the input ω\_0, huh.    ω isn&#x27;t really doing that much for you it seems except to group the inputs, maybe just describe the inputs and output?
2. At least a line or two describing the each function, specifically referencing these w (\\omega) parameters would help a lot!  Whereas PVM opcode semantics are quite common place and need no explication, these functions are the heart of JAM.
3. I believe most of the functions probably deserve at least a passing reference in the main body, or solid exposition around present (242), (246), (252).  We can guess import+export+historical\_lookup but nothing references what peek, poke, machine, assign, delegate, quit (?), ... do yet.
4. invoke = 13 is a copy of solicit and surely deserves a different name to the invoke = 20, like invoke\_accumulate vs invoke\_refine.
5. Not clear what&#x27;s going on with numbers:

- new&#x27;s bump function 42, 9
- designate&#x27;s 176
- invoke=20&#x27;s 13 and 60

6. Not clear why all these 64-bit parameters (g, a, m) have to be split into 2 32-bit and joined back together?
7. A diagram for the whole DA system would be worth a thousand words.
8. If you don&#x27;t want to add more exposition because you want hyper compactness  ok I get it but maybe using https://en.wikibooks.org/wiki/LaTeX/Macros will allow implementers to disambiguate notation by just reading latex (?!) -- for any overloaded notation (E, W, s, C, c, t, ...) that is used to reference more than one concept, implementers can go look at the LaTeX source, where the macros would be unambiguous.   

(Feel free to ignore most of the above, not very confident, just learning =))</div>
<div class='msg'><time>2024‑06‑23 17:30</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * For Appendix B.6 (General), B.7 (Accumulate) and Appendix B.8 (Refine) functions:

1. For ω parameter inputs, I did not understand why the number of parameters on the left hand side did not equal that of the right hand side:

- lookup \[h\_o, b\_0, b\_z\] = ω\_{1..4}  (3 vs 4) but then ω\_0 is used so ... ok
- read \[k\_o, k\_z, b\_o, b\_z\] = ω\_{1..5} (4 vs 5) but then w\_0 is used so .. ok
- write \[k\_o, k\_z, v\_o, v\_z\] = ω\_{0..4} (4 vs 5) but there is no w\_4 ... huh?
- new  \[o,l,g\_l, g\_h, m\_l, m\_h\] = ω\_{0..6} (6 vs 7) ... huh?
...
- machine \[p\_o, p\_z, i\] = ω\_{0..3} (3 vs 4)
- peek \[n,a,b,l\] = ω\_{0..4} (4 vs 5)
...
Then you use ω\_0&#x27; as a return parameter which has nothing to do with the input ω\_0, huh.    ω isn&#x27;t really doing that much for you it seems except to group the inputs, maybe just describe the inputs and output?

2. At least a line or two describing the each function, specifically referencing these ω parameter inputs would help a lot!  Whereas PVM opcode semantics are quite common place and need little additional explication, these functions are the heart of JAM and the additional explication would increase speed of comprehension and reduce guesswork.
3. I believe most of the functions probably deserve at least a passing reference in the main body, or solid exposition around present (242), (246), (252).  We can guess import+export+historical\_lookup but nothing references what peek, poke, machine, assign, delegate, quit (?), ... do yet.  
4. invoke = 13 is a copy of solicit and surely deserves a different name to the invoke = 20, like invoke\_accumulate vs invoke\_refine.
5. Not clear what&#x27;s going on with numbers:

- new&#x27;s bump function 42, 9
- designate&#x27;s 176
- invoke=20&#x27;s 13 and 60

6. Not clear why all these 64-bit parameters (g, a, m) have to be split into 2 32-bit and joined back together?
7. A diagram for the whole DA system would be worth a thousand words.  I imagine you have them in your JAM slides.
8. If you don&#x27;t want to add more exposition because you want hyper compactness  ok I get it but maybe using https://en.wikibooks.org/wiki/LaTeX/Macros will allow implementers to disambiguate notation by just reading latex (?!) -- especially for any overloaded notation (E, W, s, C, c, t, ...) that is used to reference more than one concept, implementers can go look at the LaTeX source, where the macros would be unambiguous.  

(Feel free to ignore most of the above, not very confident, just learning =).  Will of course take any edits you make and follow up with deep look to check if I understand in our stubs)</div>
<div class='msg'><time>2024‑06‑23 17:31</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * For Appendix B.6 (General), B.7 (Accumulate) and Appendix B.8 (Refine) functions:

1. For ω parameter inputs, I did not understand why the number of parameters on the left hand side did not equal that of the right hand side:

- lookup \[h\_o, b\_0, b\_z\] = ω\_{1..4}  (3 vs 4) but then ω\_0 is used so ... ok
- read \[k\_o, k\_z, b\_o, b\_z\] = ω\_{1..5} (4 vs 5) but then w\_0 is used so .. ok
- write \[k\_o, k\_z, v\_o, v\_z\] = ω\_{0..4} (4 vs 5) but there is no w\_4 ... huh?
- new  \[o,l,g\_l, g\_h, m\_l, m\_h\] = ω\_{0..6} (6 vs 7) ... huh?
...
- machine \[p\_o, p\_z, i\] = ω\_{0..3} (3 vs 4) ... huh?
- peek \[n,a,b,l\] = ω\_{0..4} (4 vs 5) ... huh?
... and so on
Then you use ω\_0&#x27; as a return parameter which has nothing to do with the input ω\_0, huh.    ω isn&#x27;t really doing that much for you it seems except to group the inputs, maybe just describe the inputs and output?

2. At least a line or two describing the each function, specifically referencing these ω parameter inputs would help a lot!  Whereas PVM opcode semantics are quite common place and need little additional explication, these functions are the heart of JAM and the additional explication would increase speed of comprehension and reduce guesswork.
3. I believe most of the functions probably deserve at least a passing reference in the main body, or solid exposition around present (242), (246), (252).  We can guess import+export+historical\_lookup but nothing references what peek, poke, machine, assign, delegate, quit (?), ... do yet.
4. invoke = 13 is a copy of solicit and surely deserves a different name to the invoke = 20, like invoke\_accumulate vs invoke\_refine.
5. Not clear what&#x27;s going on with numbers:

- new&#x27;s bump function 42, 9
- designate&#x27;s 176
- invoke=20&#x27;s 13 and 60

6. Not clear why all these 64-bit parameters (g, a, m) have to be split into 2 32-bit and joined back together?
7. A diagram for the whole DA system would be worth a thousand words.  I imagine you have them in your JAM slides.
8. If you don&#x27;t want to add more exposition because you want hyper compactness  ok I get it but maybe using https://en.wikibooks.org/wiki/LaTeX/Macros will allow implementers to disambiguate notation by just reading latex (?!) -- especially for any overloaded notation (E, W, s, C, c, t, ...) that is used to reference more than one concept, implementers can go look at the LaTeX source, where the macros would be unambiguous.

(Feel free to ignore most of the above, not very confident, just learning =).  Will of course take any edits you make and follow up with deep look to check if I understand in our stubs)</div>
<div class='msg'><time>2024‑06‑24 01:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Regarding the use of omega, did you understand that the range is inclusive on the lower bound and exclusive on the upper?</div>
<div class='msg reply'><time>2024‑06‑24 01:59</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Yes, for the cases that appear to be ranges.   Not all your ω parameters are ranges though.  </div>
<div class='msg reply'><time>2024‑06‑24 02:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I&#x27;m not sure what you think the issue is.</div>
<div class='msg reply'><time>2024‑06‑24 02:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: let [a, b, c] = X_{1..4} seems perfectly comprehensible.</div>
<div class='msg reply'><time>2024‑06‑24 02:23</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Got it, its clear.  [Normies will think X_{1..4} will have 4 elements.   You obviously think it should have just 3] </div>
<div class='msg reply'><time>2024‑06‑24 02:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I would draw your attention to Section 3 Notational Conventions:</div>
<div class='msg reply'><time>2024‑06‑24 02:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: A range may be denoted using an ellip-
sis for example: [0, 1, 2, 3]...2 = [0, 1] and [0, 1, 2, 3]1⋅⋅⋅+2 =
[1, 2]</div>
<div class='msg reply'><time>2024‑06‑24 02:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I believe it is not uncommon in computer programming to use (inclusive...exclusive) ranges.</div>
<div class='msg reply'><time>2024‑06‑24 02:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: In any case, regardless of convenion I have endeavoured to make my notation clear. But it is very important that anyone serious about interpreting the GP thoroughly read and understand Section 3.</div>
<div class='msg reply'><time>2024‑06‑24 02:37</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Alright that explication is clear.  Thanks!</div>
<div class='msg'><time>2024‑06‑24 01:57</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I’m not sure what your point is when you say “Then you use…”</div>
<div class='msg reply'><time>2024‑06‑24 02:03</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: My point is that people would expect ω_0 and ω_0&#x27; to be related, of the same rough type -- you take pains in most other cases to have them be the same type.   So, its an expectation violation.</div>
<div class='msg reply'><time>2024‑06‑24 02:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: ω_0&#x27; is always the return code.</div>
<div class='msg reply'><time>2024‑06‑24 02:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: ω is always the argument values.</div>
<div class='msg reply'><time>2024‑06‑24 02:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I see no such violation. Perhaps you were misinterpreting.</div>
<div class='msg'><time>2024‑06‑24 02:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I have intentionally avoided attempting to document the host functions in the GP. They will inevitably get documented eventually as a user-resource. But at present the host function definitions are explicit and unambiguous, the primary point of the GP&#x27;s appendix. Defining them in English as well might lead to people who are less well able to read maths instead relying solely on the English description which will inevitably be more ambiguous and less well defined.</div>
<div class='msg'><time>2024‑06‑24 02:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * I see no such violation. Perhaps you were misinterpreting my intentions.</div>
<div class='msg'><time>2024‑06‑24 02:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * I have intentionally avoided attempting to document the host functions in the GP. They will inevitably get documented eventually as a user-resource. But at present the host function definitions are explicit and unambiguous, the primary point of the GP&#x27;s appendix. Defining them in English as well might lead to people who are less well able to read maths instead relying solely on the English description which will inevitably be more ambiguous and less well defined, increasing the speed of miscomprehension.</div>
<div class='msg'><time>2024‑06‑24 02:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; Not clear why all these 64-bit parameters (g, a, m) have to be split into 2 32-bit and joined back together?

How else do you expect to be able to store a 64-bit value across 32-bit registers?</div>
<div class='msg reply'><time>2024‑06‑24 03:47</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: I expected the caller to do this nitty gritty mapping -- I see you mean 100% of ω_{i...j}  are 32-bit registers, now the ω_0&#x27; vs ω_0 being unrelated types makes sense.   </div>
<div class='msg'><time>2024‑06‑24 02:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * &gt; Not clear why all these 64-bit parameters (g, a, m) have to be split into 2 32-bit and joined back together?

How else do you expect to be able to represent a 64-bit value across 32-bit registers?</div>
<div class='msg'><time>2024‑06‑24 02:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Macros have been used on occasion (see e.g. preamble.tex). I will likely increase the usage in time.</div>
<div class='msg'><time>2024‑06‑24 02:14</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There will be no diagrams in the GP.</div>
<div class='msg'><time>2024‑06‑24 02:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; invoke = 13 is a copy of solicit and surely deserves a different name to the invoke = 20, like invoke_accumulate vs invoke_refine.

Unintended - invoke = 13 will be removed in the next revision. Thanks for reporting this.</div>
<div class='msg'><time>2024‑06‑24 02:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * &gt; invoke = 13 is a copy of solicit and surely deserves a different name to the invoke = 20, like invoke\_accumulate vs invoke\_refine.

Unintended. `invoke = 13` will be removed in the next revision. Thanks for reporting this.</div>
<div class='msg'><time>2024‑06‑24 02:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * A range may be denoted using an ellip-
sis for example: \[0, 1, 2, 3\]...2 = \[0, 1\] and \[0, 1, 2, 3\]1⋅⋅⋅+2 = \[1, 2\]</div>
<div class='msg'><time>2024‑06‑24 02:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * A range may be denoted using an ellipsis for example: \[0, 1, 2, 3\]...2 = \[0, 1\] and \[0, 1, 2, 3\]1⋅⋅⋅+2 = \[1, 2\]</div>
<div class='msg'><time>2024‑06‑24 02:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * I believe it is not uncommon in computer programming to use (inclusive...exclusive) ranges. Rust, notably, does this.</div>
<div class='msg'><time>2024‑06‑24 02:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * In any case, regardless of convention I have endeavoured to make my notation clear. But it is very important that anyone serious about interpreting the GP thoroughly read and understand Section 3.</div>
<div class='msg'><time>2024‑06‑26 13:27</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: &quot;Boolean values. Bs denotes the set of Boolean  strings of length s, thus Bs = ⟦{, ⊺}⟧s. When dealing  with Boolean values we may assume an implicit equivalence mapping to a bit whereby ⊺ = 1 and  = 0, thus  B◻ = ⟦N2⟧◻. We use the function bits(Y) ∈ B to denote the sequence of bits, ordered with the least significant first, which represent the octet sequence Y, thus  bits([5, 0]) = [1, 0, 1, 0, 0,...]. &quot;

I didn&#x27;t understand why bits([5, 0]) and not simple bits(5)? What this 0 represent in the sequence?</div>
<div class='msg'><time>2024‑06‑26 13:28</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: * &quot;Boolean values. Bs denotes the set of Boolean strings of length s, thus Bs = ⟦{, ⊺}⟧s. When dealing with Boolean values we may assume an implicit equivalence mapping to a bit whereby ⊺ = 1 and  = 0, thus B◻ = ⟦N2⟧◻. We use the function bits(Y) ∈ B to denote the sequence of bits, ordered with the least significant first, which represent the octet sequence Y, thus bits([5, 0]) = [1, 0, 1, 0, 0,...]. &quot;
I didn&#x27;t understand why bits([5, 0]) and not simple bits(5)? What this 0 represent in the [5, 0] sequence?</div>
<div class='msg'><time>2024‑06‑26 13:49</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: bits takes an octet (=byte) _sequence_, not just a single byte. 0 is simply the second byte in the sequence.</div>
<div class='msg'><time>2024‑06‑26 15:48</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: So bits([5]) would be [1,0,1,0,0,0,0,0] and bits([5,0]) would be [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0]?</div>
<div class='msg'><time>2024‑06‑26 21:20</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Screenshot 2024-06-26 at 18.19.53.png</div>
<div class='msg'><time>2024‑06‑26 21:20</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: what is C here?</div>
<div class='msg'><time>2024‑06‑27 01:26</time>&ensp;<span class='u' style='color:#7fc52e'>sergei_astapov</span>: &gt; &lt;@danicuki:matrix.org&gt; what is C here?

&gt; gav
It’s the beefy commitment set. 
It should be mentioned in the definitions section. 
It’s defined at the end of the accumulation definitions. 
Section 14 iirc. </div>
<div class='msg'><time>2024‑06‑27 19:56</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Potential issues in Appendix A: 
1. `sub_imm` is missing in A.5.9 - not sure what the opcode but see: https://github.com/koute/jamtestvectors/blob/master_pvm_initial/pvm/programs/inst_sub_imm.json
vs
https://github.com/koute/jamtestvectors/blob/master_pvm_initial/pvm/programs/inst_add_imm.json
2. `cmov_imm_iz`  appears here as Opcode 85 but is missing in Appendix A
https://github.com/koute/jamtestvectors/blob/master_pvm_initial/pvm/programs/inst_cmov_if_zero_imm_ok.json
3. the family of &quot;branch&quot; opcodes { 24, 30, 47, 48, 41, 43 } are repeated in A.5.9 and A.5.10 -- is this intended? 
4. The &quot;condition&quot; referenced in &quot;In the case that the above condition is not met, then the instruction is considered invalid, and it results in a panic&quot; after (224), (226), (227) is not clear to me.  </div>
<div class='msg'><time>2024‑06‑27 19:57</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Potential issues in Appendix A:

1. `sub_imm` is missing in A.5.9 - not sure what the opcode is (`add_imm` is 2) but see: https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_sub\_imm.json
vs
https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_add\_imm.json
2. `cmov_imm_iz`  appears here as Opcode 85 but is missing in Appendix A
https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_cmov\_if\_zero\_imm\_ok.json
3. the family of &quot;branch&quot; opcodes { 24, 30, 47, 48, 41, 43 } are repeated in A.5.9 and A.5.10 -- is this intended?
4. The &quot;condition&quot; referenced in &quot;In the case that the above condition is not met, then the instruction is considered invalid, and it results in a panic&quot; after (224), (226), (227) is not clear to me.</div>
<div class='msg'><time>2024‑06‑27 20:13</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Potential issues in Appendix A:

1. `sub_imm` is missing in A.5.9 - not sure what the opcode is (`add_imm` is 2) but see: https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_sub\_imm.json
vs
https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_add\_imm.json
2. `cmov_imm_iz`  appears here as Opcode 85 but is missing in Appendix A
https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_cmov\_if\_zero\_imm\_ok.json
3. the family of &quot;branch&quot; opcodes { 24, 30, 47, 48, 41, 43 } are repeated in A.5.9 and A.5.10 -- is this intended?
4. The &quot;above condition&quot; referenced in &quot;In the case that the above condition is not met, then the instruction is considered invalid, and it results in a panic&quot; after (224-227) is not clear to me.</div>
<div class='msg'><time>2024‑06‑27 20:51</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Potential issues in Appendix A:

1. `sub_imm` is missing in A.5.9 - not sure what the opcode is (`add_imm` is 2) but see: https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_sub\_imm.json
vs
https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_add\_imm.json
2. `cmov_imm_iz`  appears here as Opcode 85 but is missing in Appendix A
https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_cmov\_if\_zero\_imm\_ok.json
3. the family of &quot;branch&quot; opcodes { 24, 30, 47, 48, 41, 43 } are repeated in A.5.9 and A.5.10 -- is this intended?
4. The &quot;above condition&quot; referenced in &quot;In the case that the above condition is not met, then the instruction is considered invalid, and it results in a panic&quot; after (224-227) is not clear to me.
5. `mov_reg` (op code 82) and `sbrk` (op code 87) seems to need B and D swapped in some way either in 223 or in the Mutations, whatever works</div>
<div class='msg'><time>2024‑06‑27 20:56</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Potential issues in Appendix A:

1. `sub_imm` is missing in A.5.9 - not sure what the opcode is (`add_imm` is 2) but see: https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_sub\_imm.json
vs
https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_add\_imm.json
2. `cmov_imm_iz`  appears here as Opcode 85 but is missing in Appendix A
https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_cmov\_if\_zero\_imm\_ok.json
3. the family of &quot;branch&quot; opcodes { 24, 30, 47, 48, 41, 43 } are repeated in A.5.9 and A.5.10 -- is this intended?
4. The &quot;above condition&quot; referenced in &quot;In the case that the above condition is not met, then the instruction is considered invalid, and it results in a panic&quot; after (224-227) is not clear to me.
5. `mov_reg` (op code 82) and `sbrk` (op code 87) seems to need B and D swapped in some way either in 223 or in the Mutations, whatever works [but, not sure what `sbrk` does though]</div>
<div class='msg'><time>2024‑06‑27 21:48</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Potential issues in Appendix A:

1. `sub_imm` is missing in A.5.9 - not sure what the opcode is (`add_imm` is 2) but see: https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_sub\_imm.json
vs
https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_add\_imm.json
2. `cmov_imm_iz`  appears here as Opcode 85 but is missing in Appendix A
https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_cmov\_if\_zero\_imm\_ok.json
3. the family of &quot;branch&quot; opcodes { 24, 30, 47, 48, 41, 43 } are repeated in A.5.9 and A.5.10 -- is this intended?
4. The &quot;above condition&quot; referenced in &quot;In the case that the above condition is not met, then the instruction is considered invalid, and it results in a panic&quot; after (224-227) is not clear to me.
5. `mov_reg` (op code 82) and `sbrk` (op code 87) seems to need B and D swapped in some way either in 223 or in the Mutations, whatever works \[but, not sure what `sbrk` does though\]
6. You have to finish the sentence around (213) &quot;This allows for compact representation of both positive and negative encoded values, important as .&quot;
</div>
<div class='msg'><time>2024‑06‑28 01:00</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Potential issues in Appendix A:

1. `sub_imm` is missing in A.5.9 - not sure what the opcode is (`add_imm` is 2) but see: https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_sub\_imm.json
vs
https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_add\_imm.json
2. `cmov_imm_iz`  appears here as Opcode 85 but is missing in Appendix A
https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_cmov\_if\_zero\_imm\_ok.json
3. the family of &quot;branch&quot; opcodes { 24, 30, 47, 48, 41, 43 } are repeated in A.5.9 and A.5.10 -- is this intended?
4. The &quot;above condition&quot; referenced in &quot;In the case that the above condition is not met, then the instruction is considered invalid, and it results in a panic&quot; after (224-227) is not clear to me.
5. `mov_reg` (op code 82) and `sbrk` (op code 87) seems to need B and D swapped in some way either in 223 or in the Mutations, whatever works \[but, not sure what `sbrk` does though\].  
6. You have to finish the sentence around (213) &quot;This allows for compact representation of both positive and negative encoded values, important as .&quot;
7.  Based on https://github.com/koute/jamtestvectors/blob/master_pvm_initial/pvm/programs/inst_add.json (and many &quot;ALU&quot; operations I think you have a mix up of A, B, D (the `inst_add.json` has 1+2 =&gt; 3 r_A = 7, r_D = 9, r_B = 8 where w[r_A] = 1, w[r_B] = 2, w[r_D] = 3).  Not sure if its the test vectors that are incorrect or the GP here.</div>
<div class='msg'><time>2024‑06‑28 05:46</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Potential issues in Appendix A:

1. `sub_imm` is missing in A.5.9 - not sure what the opcode is (`add_imm` is 2) but see: https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_sub\_imm.json
vs
https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_add\_imm.json
2. `cmov_imm_iz`  appears here as Opcode 85 but is missing in Appendix A
https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_cmov\_if\_zero\_imm\_ok.json
3. the family of &quot;branch&quot; opcodes { 24, 30, 47, 48, 41, 43 } are repeated in A.5.9 and A.5.10 -- is this intended?
4. The &quot;above condition&quot; referenced in &quot;In the case that the above condition is not met, then the instruction is considered invalid, and it results in a panic&quot; after (224-227) is not clear to me.
5. `mov_reg` (op code 82) and `sbrk` (op code 87) seems to need B and D swapped in some way either in 223 or in the Mutations, whatever works \[but, not sure what `sbrk` does though\].
6. You have to finish the sentence around (213) &quot;This allows for compact representation of both positive and negative encoded values, important as .&quot;
7. Based on https://github.com/koute/jamtestvectors/blob/master\_pvm\_initial/pvm/programs/inst\_add.json (and many &quot;ALU&quot; operations I think you have a mix up of A, B, D (the `inst_add.json` has 1+2 =&gt; 3 r\_A = 7, r\_D = 9, r\_B = 8 where w\[r\_A\] = 1, w\[r\_B\] = 2, w\[r\_D\] = 3).  Not sure if its the test vectors that are incorrect or the GP here.
8. The mutations of  `cmov_iz` (opcode 85) and `cmov_nz` (opcode 84) appear to be swapped in A.5.11.</div>
<div class='msg'><time>2024‑06‑28 05:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Point 6 will be sorted in the next revision.</div>
<div class='msg'><time>2024‑06‑28 05:59</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 1. `sub_imm` doesn&#x27;t exist.</div>
<div class='msg'><time>2024‑06‑28 07:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 2. Will be fixed.
3. Will be fixed.
4. This refers to the implied decode of the immediate value which could conceivably fail. If the condition cannot fail, then the statement is redundant and you need not pay it any attention.
5. Will be fixed.
6. Will be sorted in the next revision.
7. Not sure what the issue is here.
8. Will be fixed.</div>
<div class='msg'><time>2024‑06‑28 07:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 2. Will be fixed.
3. Will be fixed.
4. This refers to the implied decode of the immediate value which could conceivably fail. If the condition cannot fail, then the statement is redundant and you need not pay it any attention.
5. Will be fixed.
6. Will be sorted in the next revision.
7. Not sure what the issue is here. The example you gave seems in line with the GP.
8. Will be fixed.</div>
<div class='msg'><time>2024‑06‑28 07:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (Fixed in master)</div>
<div class='msg'><time>2024‑06‑28 07:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * (Fixed in main)</div>
<div class='msg'><time>2024‑06‑28 07:24</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Ok, for 7, the test vector for `add` is computing 1+2 = 3 with inputs w_7 (1) + w_8 (2) going into w_9 (3) as is easily seen here: https://github.com/koute/jamtestvectors/blob/master_pvm_initial/pvm/programs/inst_add.json#L28  
but looking closely at the test vector code:
(a) decimal 121 is hexadecimal 0x79  (so w_7 are the high order 4 bits INPUT, while the *OUTPUT* w_9 is the low order 4 bits)  
(b) the byte following (a) is &quot;8&quot; which is the other INPUT 
Basically r_A+r_D are together in one byte with r_B following. 

In contrast, the GP in (227) has both  r_A+r_B put together in one byte and with a byte holding r_D following that byte.  

The fix, I believe, is to adjust (227) subscripts from 
_A, _B, _D 
to 
_D, _A, _B
  </div>
<div class='msg'><time>2024‑06‑28 07:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Ok, for 7, the test vector for `add` is computing 1+2 = 3 with inputs w_7 (1) + w_8 (2) going into w_9 (3) as is easily seen here: https://github.com/koute/jamtestvectors/blob/master_pvm_initial/pvm/programs/inst_add.json#L28  
&gt; but looking closely at the test vector code:
&gt; (a) decimal 121 is hexadecimal 0x79  (so w_7 are the high order 4 bits INPUT, while the *OUTPUT* w_9 is the low order 4 bits)  
&gt; (b) the byte following (a) is &quot;8&quot; which is the other INPUT 
&gt; Basically r_A+r_D are together in one byte with r_B following. 
&gt; 
&gt; In contrast, the GP in (227) has both  r_A+r_B put together in one byte and with a byte holding r_D following that byte.  
&gt; 
&gt; The fix, I believe, is to adjust (227) subscripts from 
&gt; _A, _B, _D 
&gt; to 
&gt; _D, _A, _B

I see - for this the tests will be altered</div>
<div class='msg'><time>2024‑06‑28 07:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * I see - for this the tests will be altered (GP stays as is)</div>
<div class='msg'><time>2024‑06‑30 19:55</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: This is more like a question than some specific correction..  but I feel that there are some information gaps that I am not able to fill and probably other may find in the same situation. Hopefully is not purely because of my lack of knowledge. 

I am confused by how the Bandersnatch ring root function O is defined in 3.0 and/or Appendix G.
This is required to complete the update of the key root in safrole.

...
    \where z &amp;= \mathcal{O}([k_b \mid k \orderedin \gamma&#x27;_\mathbf{k}]) \\
...

The appendix defines:

O(⟦HB ⟧) ≡ PCS_commitment(⟦HB ⟧)

GP points to https://github.com/davxy/bandersnatch-vrfs-spec/blob/main/specification.pdf ( which seems to be work in progress, A few TODOs, etc.). The document briefly defines `prove` and `verify`. Proving requires a secret key.. so it could not be applicable to key root update. Verify does not seem to be aplicable either.

- I cannot link with confidence what is PCS_Commitment in Galassi&#x27;s document.
- It is allowed to use external code (FFI) for bandersnatch VRF.

Would it he possible to provide more information about this step in Safrole, expand a bit more the appendix about Bandersnatch VRF or provide some reference on how the test vectors used the reference crate that was used for this purpose?
</div>
<div class='msg'><time>2024‑06‑30 21:09</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: Indeed. I&#x27;m going to update the Bandernatch with some extra info about the procedure used to construct the verifier and how to use it. The real meat of ring proof spec should be delivered by a dedicated document BTW. But apparently this one has not been made public yet. I&#x27;ll try to push for some progress.
For the moment, I think the brst route is to use the reference impl and have a look at the ring proof tests in ark-ec-vrf:
- https://github.com/davxy/ark-ec-vrfs/blob/3b4b3591aba62d206408052f6ffd5d5aba6d60a5/src/suites/bandersnatch.rs#L206
- https://github.com/davxy/ark-ec-vrfs/blob/3b4b3591aba62d206408052f6ffd5d5aba6d60a5/src/testing.rs#L70
This gives you an idea of how the data in the test vectors (the ring verifier key) is constructed and the used to verify some proof.</div>
<div class='msg'><time>2024‑07‑01 00:51</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: davxy: gav   1. For your test vectors (&quot;tiny&quot;), what are the values of 
$jam_entropy  (was BYTES( &quot;sassafras_randomness&quot;))
$jam_ticket_seal  (was BYTES(&quot;sassafras_ticket_seal&quot;))
$jam_fallback_seal (was BYTES(&quot;sassafras_fallback_seal&quot;))
and what does term in the GP does &quot;entropy&quot; (Per block entropy (originated from block entropy source VRF)) refer to?

2. I see &quot;attempt&quot; and &quot;attempts_number&quot; was renamed to &quot;entry index&quot; and &quot;N&quot; in GP, but what happened to the &quot;ticket threshold&quot; and &quot;redundancy_factor&quot; - are those [what I thought key] concepts gone (in which case, how?) or to be documented still?

3. Since a high level goal of JAM is to get NON-Rust implementations for Safrole almost everyone will surely use FFI into your recommended crypto package.  Can you ( @davxy) provide a single working test case to 
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json
(or the scale equilv) set up the ring verifier, get the ring vrf output, get the entropy buffer updated?  With a single well-worked out test case in Rust handing the &quot;Bare VRF&quot; and &quot;Ring VRF&quot; (specifically making the specific flavors exceptionally clear to &quot;I&#x27;m not a cryptographer, I just use cryptography&quot; engineers), I&#x27;ll bet everyone can use that to set up their `extern &quot;C&quot;` type FFI and pass most of the cases in rapid order.  Is this possible?</div>
<div class='msg'><time>2024‑07‑01 01:47</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * davxy: gav   1. For your test vectors (&quot;tiny&quot;), what are the values of
$jam\_entropy  (was BYTES( &quot;sassafras\_randomness&quot;))
$jam\_ticket\_seal  (was BYTES(&quot;sassafras\_ticket\_seal&quot;))
$jam\_fallback\_seal (was BYTES(&quot;sassafras\_fallback\_seal&quot;))
and what does term in the GP does &quot;entropy&quot; (Per block entropy (originated from block entropy source VRF)) refer to?

2. I see &quot;attempt&quot; and &quot;attempts\_number&quot; was renamed to &quot;entry index&quot; and &quot;N&quot; in GP, but what happened to the &quot;ticket threshold&quot; and &quot;redundancy\_factor&quot; - are those \[what I thought key\] concepts gone (in which case, how?) or to be documented still?
3. Since a high level goal of JAM is to get NON-Rust implementations for Safrole almost everyone will surely use FFI into your recommended crypto package.  Can you ( @davxy) provide a single working test case like say this one 
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json
(or the scale equivalent) to set up the ring verifier, get the ring vrf output, and get the entropy buffer updated?  With a single well-worked out test case in Rust handing the &quot;Bare VRF&quot; and &quot;Ring VRF&quot; (specifically making the specific flavors exceptionally clear to &quot;I&#x27;m not a cryptographer, I just use cryptography&quot; engineers), I&#x27;ll bet everyone can use that to set up their `extern &quot;C&quot;` type FFI and pass most of the cases in rapid order.  Is this possible?</div>
<div class='msg'><time>2024‑07‑01 01:47</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * davxy: gav   1. For your Safrole test vectors (&quot;tiny&quot;), what are the values of
$jam\_entropy  (was BYTES( &quot;sassafras\_randomness&quot;))
$jam\_ticket\_seal  (was BYTES(&quot;sassafras\_ticket\_seal&quot;))
$jam\_fallback\_seal (was BYTES(&quot;sassafras\_fallback\_seal&quot;))
and what does term in the GP does &quot;entropy&quot; (Per block entropy (originated from block entropy source VRF)) refer to?

2. I see &quot;attempt&quot; and &quot;attempts\_number&quot; was renamed to &quot;entry index&quot; and &quot;N&quot; in GP, but what happened to the &quot;ticket threshold&quot; and &quot;redundancy\_factor&quot; - are those \[what I thought key\] concepts gone (in which case, how?) or to be documented still?
3. Since a high level goal of JAM is to get NON-Rust implementations for Safrole almost everyone will surely use FFI into your recommended crypto package.  Can you ( @davxy) provide a single working test case like say this one
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json
(or the scale equivalent) to set up the ring verifier, get the ring vrf output, and get the entropy buffer updated?  With a single well-worked out test case in Rust handing the &quot;Bare VRF&quot; and &quot;Ring VRF&quot; (specifically making the specific flavors exceptionally clear to &quot;I&#x27;m not a cryptographer, I just use cryptography&quot; engineers), I&#x27;ll bet everyone can use that to set up their `extern &quot;C&quot;` type FFI and pass most of the cases in rapid order.  Is this possible?</div>
<div class='msg'><time>2024‑07‑01 01:51</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * davxy: gav   1. For your Safrole test vectors (&quot;tiny&quot;), what are the values of
$jam\_entropy  (was BYTES( &quot;sassafras\_randomness&quot;))
$jam\_ticket\_seal  (was BYTES(&quot;sassafras\_ticket\_seal&quot;))
$jam\_fallback\_seal (was BYTES(&quot;sassafras\_fallback\_seal&quot;))
and what does term in the GP does &quot;entropy&quot; (documented with&quot;Per block entropy (originated from block entropy source VRF)&quot;) refer to from the test vector
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json#L4
?

2. I see &quot;attempt&quot; and &quot;attempts\_number&quot; was renamed to &quot;entry index&quot; and &quot;N&quot; in GP, but what happened to the &quot;ticket threshold&quot; and &quot;redundancy\_factor&quot; - are those \[what I thought key\] concepts gone (in which case, how?) or to be documented still?
3. Since a high level goal of JAM is to get NON-Rust implementations for Safrole almost everyone will surely use FFI into your recommended crypto package.  Can you ( @davxy) provide a single working test case like say this one
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json
(or the scale equivalent) to set up the ring verifier, get the ring vrf output, and get the entropy buffer updated?  With a single well-worked out test case in Rust handing the &quot;Bare VRF&quot; and &quot;Ring VRF&quot; (specifically making the specific flavors exceptionally clear to &quot;I&#x27;m not a cryptographer, I just use cryptography&quot; engineers), I&#x27;ll bet everyone can use that to set up their `extern &quot;C&quot;` type FFI and pass most of the cases in rapid order.  Is this possible?</div>
<div class='msg'><time>2024‑07‑01 02:11</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * davxy: gav  Some freshman questions on Safrole:
1. For your Safrole test vectors (&quot;tiny&quot;), what are the values of
$jam\_entropy  (was BYTES( &quot;sassafras\_randomness&quot;))
$jam\_ticket\_seal  (was BYTES(&quot;sassafras\_ticket\_seal&quot;))
$jam\_fallback\_seal (was BYTES(&quot;sassafras\_fallback\_seal&quot;))
and what does term in the GP does &quot;entropy&quot; (documented with&quot;Per block entropy (originated from block entropy source VRF)&quot;) refer to from the test vector
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json#L4
?

2. I see &quot;attempt&quot; and &quot;attempts\_number&quot; was renamed to &quot;entry index&quot; and &quot;N&quot; in GP, but what happened to the &quot;ticket threshold&quot; and &quot;redundancy\_factor&quot; - are those \[what I thought key\] concepts gone (in which case, how?) or to be documented still?
3. Since a high level goal of JAM is to get NON-Rust implementations for Safrole almost everyone will surely use FFI into your recommended crypto package.  Can you ( @davxy) provide a single working test case like say this one
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json
(or the scale equivalent) to set up the ring verifier, get the ring vrf output, and get the entropy buffer updated?  With a single well-worked out test case in Rust handing the &quot;Bare VRF&quot; and &quot;Ring VRF&quot; (specifically making the specific flavors exceptionally clear to &quot;I&#x27;m not a cryptographer, I just use cryptography&quot; engineers), I&#x27;ll bet everyone can use that to set up their `extern &quot;C&quot;` type FFI and pass most of the cases in rapid order.  Is this possible?

4. For the &quot;tickets_verifier_key&quot; eg 
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json#L210
they are 384 bytes and it is labeled as &quot;gamma_z: The Bandersnatch ring root.&quot; in `safrole.asn`. However in GP it is documented as being element Y_R in (47) but the I.1.2 it is 144 bytes.  Can you explain further what this discrepancy could be due to?
</div>
<div class='msg'><time>2024‑07‑01 02:34</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * davxy: gav  Some freshman questions on Safrole:

1. For your Safrole test vectors (&quot;tiny&quot;), what are the values of
$jam\_entropy  (was BYTES( &quot;sassafras\_randomness&quot;))
$jam\_ticket\_seal  (was BYTES(&quot;sassafras\_ticket\_seal&quot;))
$jam\_fallback\_seal (was BYTES(&quot;sassafras\_fallback\_seal&quot;))
and what does term in the GP does &quot;entropy&quot; (documented with&quot;Per block entropy (originated from block entropy source VRF)&quot;) refer to from the test vector
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json#L4
?
2. I see &quot;attempt&quot; and &quot;attempts\_number&quot; was renamed to &quot;entry index&quot; and &quot;N&quot; in GP, but what happened to the &quot;ticket threshold&quot; and &quot;redundancy\_factor&quot; - are those \[what I thought key\] concepts gone (in which case, how?) or to be documented still?
3. Since a high level goal of JAM is to get NON-Rust implementations for Safrole almost everyone will surely use FFI into your recommended crypto package.  Can you ( @davxy) provide a single working test case like say this one
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json
(or the scale equivalent) to set up the ring verifier, get the ring vrf output, and get the entropy buffer updated?  With a single well-worked out test case in Rust handing the &quot;Bare VRF&quot; and &quot;Ring VRF&quot; (specifically making the specific flavors exceptionally clear to &quot;I&#x27;m not a cryptographer, I just use cryptography&quot; engineers), I&#x27;ll bet everyone can use that to set up their `extern &quot;C&quot;` type FFI and pass most of the cases in rapid order.  Is this possible?
4. For the &quot;tickets\_verifier\_key&quot; eg
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json#L210
they are 384 bytes and it is labeled as &quot;gamma\_z: The Bandersnatch ring root.&quot; in `safrole.asn`. However in GP it is documented as being element Y\_R in (47) but in I.1.2 it says it is 144 bytes.  Can you explain further what this discrepancy could be due to?</div>
<div class='msg'><time>2024‑07‑01 05:19</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * davxy: gav  Some freshman questions on Safrole:

1. For your Safrole test vectors (&quot;tiny&quot;), what are the values of
$jam\_entropy  (was BYTES( &quot;sassafras\_randomness&quot;))
$jam\_ticket\_seal  (was BYTES(&quot;sassafras\_ticket\_seal&quot;))
$jam\_fallback\_seal (was BYTES(&quot;sassafras\_fallback\_seal&quot;))
and what does term in the GP does &quot;entropy&quot; (documented with&quot;Per block entropy (originated from block entropy source VRF)&quot;) refer to from the test vector
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json#L4
?
2. I see &quot;attempt&quot; and &quot;attempts\_number&quot; was renamed to &quot;entry index&quot; and &quot;N&quot; in GP, but what happened to the &quot;ticket threshold&quot; and &quot;redundancy\_factor&quot; - are those \[what I thought key\] concepts gone (in which case, how?) or to be documented still?
3. Since a high level goal of JAM Implementation is to get NON-Rust implementations for Safrole almost everyone will surely use FFI into your recommended crypto package.  Can you ( @davxy) provide a single working test case like say this one
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json
(or the scale equivalent) to set up the ring verifier, get the ring vrf output, and get the entropy buffer updated?  With a single well-worked out test case in Rust handing the &quot;Bare VRF&quot; and &quot;Ring VRF&quot; (specifically making the specific flavors exceptionally clear to &quot;I&#x27;m not a cryptographer, I just use cryptography&quot; engineers), I&#x27;ll bet everyone can use that to set up their `extern &quot;C&quot;` type FFI and pass most of the cases in rapid order.  Is this possible?
4. For the &quot;tickets\_verifier\_key&quot; eg
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json#L210
they are 384 bytes and it is labeled as &quot;gamma\_z: The Bandersnatch ring root.&quot; in `safrole.asn`. However in GP it is documented as being element Y\_R in (47) but in I.1.2 it says it is 144 bytes.  Can you explain further what this discrepancy could be due to?</div>
<div class='msg'><time>2024‑07‑01 08:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: @davxy ^^^</div>
<div class='msg'><time>2024‑07‑01 09:01</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: sourabhniyogi: 
1.  For Safrole test vectors the only thing we use of is $jam_ticket_seal.
    In particular this is used for the ring-vrf input construction (context in the GP) to obtain the ticket score (aka ticket-id)  during the candidate ticket verification procedure.
    The value of $jam_ticket_seal&quot; is constant and defined as &quot;jam_ticket_seal&quot; ASCII string.
    This is a thing that applies in general for values starting with `$` (e.g. `$foo` in the GP =&gt; `&quot;foo&quot;` ascii string).
    (Thank you BTW as I&#x27;ve just spotted that I was using &quot;jam_seal&quot; instead of &quot;jam_ticket_seal&quot;, I&#x27;ll add the fix to the upcoming vectors PR)
    The other constant strings ($jam_fallback_seal and $jam_entropy) are used for block verification and
    per-block entropy production (which is passed as input to Safrole).
    NOTE: The actual value of per-block entropy used by the Safrole test vectors is not relevant to have been 
    really produced using the signature in the header. Here we abstract away from the value&#x27;s origin, we don&#x27;t
    really care for the sake of the Safrole test vectors and Safrole STF. In the specific case I&#x27;ve used:
    - entropy_0 = blake2b([42_u8; 32])[..32]
    - entropy_i+1 = blake2b(entropy_i)[..32]

2. If you take as a reference the Sassafras RFC then there some differences.
   One of these is the threshold and redundancy factor, which in the graypaper are in practice simplified to
   one single entry (attempts number).
   Even though reading Sassafras RFC can help (as it is a quite similar protocol), always take the graypaper
   as the source of truth for JAM.

3. Sure thing. I&#x27;ll post here as soon as it is ready.

4. This is a very interesting observation. Current implementation serializes 3 extra fields (part of the SNARK SRS).
   Serialization of these fields may be important **in a general application**, but here these values are constant.
   I will definitely get rid of these from serialized data. The final size will be 144 (i.e. the last 144 bytes of what
   you see right now)
</div>
<div class='msg'><time>2024‑07‑01 09:02</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * sourabhniyogi:

1. For Safrole test vectors the only thing we use of is $jam\_ticket\_seal.
In particular this is used for the ring-vrf input construction (context in the GP) to obtain the ticket score (aka ticket-id)  during the candidate ticket verification procedure.
The value of $jam\_ticket\_seal&quot; is constant and defined as &quot;jam\_ticket\_seal&quot; ASCII string.
This is a thing that applies in general for values starting with `$` (e.g. `$foo` in the GP =&gt; `&quot;foo&quot;` ascii string).
(Thank you BTW as I&#x27;ve just spotted that I was using &quot;jam\_seal&quot; instead of &quot;jam\_ticket\_seal&quot;, I&#x27;ll add the fix to the upcoming vectors PR)
The other constant strings ($jam\_fallback\_seal and $jam\_entropy) are used for block verification and
per-block entropy production (which is passed as input to Safrole).
NOTE: The actual value of per-block entropy used by the Safrole test vectors is not relevant to have been
really produced using the signature in the header. Here we abstract away from the value&#x27;s origin, we don&#x27;t
really care for the sake of the Safrole test vectors and Safrole STF. In the specific case I&#x27;ve used:
    - entropy\_0 = blake2b(\[42\_u8; 32\])\[..32\]
    - entropy\_i+1 = blake2b(entropy\_i)\[..32\]
2. If you take as a reference the Sassafras RFC then there some differences.
One of these is the threshold and redundancy factor, which in the graypaper are in practice simplified to
one single entry (attempts number).
Even though reading Sassafras RFC can help (as it is a quite similar protocol), always take the graypaper
as the source of truth for JAM.
3. Sure thing. I&#x27;ll post here as soon as it is ready.
4. This is a very interesting observation. Current implementation serializes 3 extra fields (part of the SNARK SRS).
Serialization of these fields may be important **in a general application**, but here these values are constant.
I will definitely get rid of these from serialized data (I&#x27;m working on it). The final size will be 144 (i.e. the last 144 bytes of what you see right now)</div>
<div class='msg'><time>2024‑07‑01 09:02</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * sourabhniyogi:

1. For Safrole test vectors the only thing we use of is $jam\_ticket\_seal.
In particular this is used for the ring-vrf input construction (context in the GP) to obtain the ticket score (aka ticket-id)  during the candidate ticket verification procedure.
The value of $jam\_ticket\_seal&quot; is constant and defined as &quot;jam\_ticket\_seal&quot; ASCII string.
This is a thing that applies in general for values starting with `$` (e.g. `$foo` in the GP =&gt; `&quot;foo&quot;` ascii string).
(Thank you BTW as I&#x27;ve just spotted that I was using &quot;jam\_seal&quot; instead of &quot;jam\_ticket\_seal&quot;, I&#x27;ll add the fix to the upcoming vectors PR)
The other constant strings ($jam\_fallback\_seal and $jam\_entropy) are used for block verification and
per-block entropy production (which is passed as input to Safrole).
NOTE: The actual value of per-block entropy used by the Safrole test vectors is not relevant to have been
really produced using the signature in the header. Here we abstract away from the value&#x27;s origin, we don&#x27;t
really care for the sake of the Safrole test vectors and Safrole STF. In the specific case I&#x27;ve used:

    - entropy\_0 = blake2b(\[42\_u8; 32\])\[..32\]
    - entropy\_i+1 = blake2b(entropy\_i)\[..32\]
2. If you take as a reference the Sassafras RFC then there some differences.
One of these is the threshold and redundancy factor, which in the graypaper are in practice simplified to
one single entry (attempts number).
Even though reading Sassafras RFC can help (as it is a quite similar protocol), always take the graypaper
as the source of truth for JAM.
3. Sure thing. I&#x27;ll post here as soon as it is ready.
4. This is a very interesting observation. Current implementation serializes 3 extra fields (part of the SNARK SRS).
Serialization of these fields may be important **in a general application**, but here these values are constant.
I will definitely get rid of these from serialized data (I&#x27;m on it). The final size will be 144 (i.e. the last 144 bytes of what you see right now)</div>
<div class='msg'><time>2024‑07‑01 09:03</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * sourabhniyogi:

1. For Safrole test vectors the only thing we use is $jam\_ticket\_seal.
In particular this is used for the ring-vrf input construction (context in the GP) to obtain the ticket score (aka ticket-id)  during the candidate ticket verification procedure.
The value of $jam\_ticket\_seal&quot; is constant and defined as &quot;jam\_ticket\_seal&quot; ASCII string.
This is a thing that applies in general for values starting with `$` (e.g. `$foo` in the GP =&gt; `&quot;foo&quot;` ascii string).
(Thank you BTW as I&#x27;ve just spotted that I was using &quot;jam\_seal&quot; instead of &quot;jam\_ticket\_seal&quot;, I&#x27;ll add the fix to the upcoming vectors PR)
The other constant strings ($jam\_fallback\_seal and $jam\_entropy) are used for block verification and
per-block entropy production (which is passed as input to Safrole).
NOTE: The actual value of per-block entropy used by the Safrole test vectors is not relevant to have been
really produced using the signature in the header. Here we abstract away from the value&#x27;s origin, we don&#x27;t
really care for the sake of the Safrole test vectors and Safrole STF. In the specific case I&#x27;ve used:
    - entropy\_0 = blake2b(\[42\_u8; 32\])\[..32\]
    - entropy\_i+1 = blake2b(entropy\_i)\[..32\]
2. If you take as a reference the Sassafras RFC then there some differences.
One of these is the threshold and redundancy factor, which in the graypaper are in practice simplified to
one single entry (attempts number).
Even though reading Sassafras RFC can help (as it is a quite similar protocol), always take the graypaper
as the source of truth for JAM.
3. Sure thing. I&#x27;ll post here as soon as it is ready.
4. This is a very interesting observation. Current implementation serializes 3 extra fields (part of the SNARK SRS).
Serialization of these fields may be important **in a general application**, but here these values are constant.
I will definitely get rid of these from serialized data (I&#x27;m on it). The final size will be 144 (i.e. the last 144 bytes of what you see right now)</div>
<div class='msg'><time>2024‑07‑01 09:07</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * sourabhniyogi:

1. For Safrole test vectors the only thing we use is $jam\_ticket\_seal.
In particular this is used for the ring-vrf input construction (context in the GP) to obtain the ticket score (aka ticket-id)  during the candidate ticket verification procedure.
The value of $jam\_ticket\_seal&quot; is constant and defined as &quot;jam\_ticket\_seal&quot; ASCII string.
This is a thing that applies in general for values starting with `$` (e.g. `$foo` in the GP =&gt; `&quot;foo&quot;` ascii string).
(Thank you BTW as I&#x27;ve just spotted that I was using &quot;jam\_seal&quot; instead of &quot;jam\_ticket\_seal&quot;, I&#x27;ll add the fix to the upcoming vectors PR)
The other constant strings ($jam\_fallback\_seal and $jam\_entropy) are used for block verification and
per-block entropy production (which is passed as input to Safrole).
NOTE: The actual value of per-block entropy used by the Safrole test vectors is not relevant to have been
really produced using the signature in the header. Here we abstract away from the value&#x27;s origin, we don&#x27;t
really care for the sake of the Safrole test vectors and Safrole STF. In the specific case I&#x27;ve used:

    - entropy\_0 = blake2b(\[42\_u8; 32\])\[..32\]
    - entropy\_i+1 = blake2b(entropy\_i)\[..32\]
2. If you take as a reference the Sassafras RFC then there some differences.
One of these is the attempts number and redundancy factor, which in the graypaper are in practice simplified to one single entry (attempts number).
Redundancy factor is gone.
Even though reading Sassafras RFC can help (as it is a quite similar protocol), always take the graypaper
as the source of truth for JAM.
3. Sure thing. I&#x27;ll post here as soon as it is ready.
4. This is a very interesting observation. Current implementation serializes 3 extra fields (part of the SNARK SRS).
Serialization of these fields may be important **in a general application**, but here these values are constant.
I will definitely get rid of these from serialized data (I&#x27;m on it). The final size will be 144 (i.e. the last 144 bytes of what you see right now)</div>
<div class='msg'><time>2024‑07‑01 09:07</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * sourabhniyogi:

1. For Safrole test vectors the only thing we use is $jam\_ticket\_seal.
In particular this is used for the ring-vrf input construction (context in the GP) to obtain the ticket score (aka ticket-id)  during the candidate ticket verification procedure.
The value of $jam\_ticket\_seal&quot; is constant and defined as &quot;jam\_ticket\_seal&quot; ASCII string.
This is a thing that applies in general for values starting with `$` (e.g. `$foo` in the GP =&gt; `&quot;foo&quot;` ascii string).
(Thank you BTW as I&#x27;ve just spotted that I was using &quot;jam\_seal&quot; instead of &quot;jam\_ticket\_seal&quot;, I&#x27;ll add the fix to the upcoming vectors PR)
The other constant strings ($jam\_fallback\_seal and $jam\_entropy) are used for block verification and
per-block entropy production (which is passed as input to Safrole).
NOTE: The actual value of per-block entropy used by the Safrole test vectors is not relevant to have been
really produced using the signature in the header. Here we abstract away from the value&#x27;s origin, we don&#x27;t
really care for the sake of the Safrole test vectors and Safrole STF. In the specific case I&#x27;ve used:
    - entropy\_0 = blake2b(\[42\_u8; 32\])\[..32\]
    - entropy\_i+1 = blake2b(entropy\_i)\[..32\]
2. If you take as a reference the Sassafras RFC then there some differences.
One of these is the attempts number and redundancy factor, which in the graypaper are in practice simplified to one single entry (attempts number).
Threshold is gone.
Even though reading Sassafras RFC can help (as it is a quite similar protocol), always take the graypaper
as the source of truth for JAM.
3. Sure thing. I&#x27;ll post here as soon as it is ready.
4. This is a very interesting observation. Current implementation serializes 3 extra fields (part of the SNARK SRS).
Serialization of these fields may be important **in a general application**, but here these values are constant.
I will definitely get rid of these from serialized data (I&#x27;m on it). The final size will be 144 (i.e. the last 144 bytes of what you see right now)</div>
<div class='msg'><time>2024‑07‑01 09:08</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * sourabhniyogi:

1. For Safrole test vectors the only thing we use is $jam\_ticket\_seal.
In particular this is used for the ring-vrf input construction (context in the GP) to obtain the ticket score (aka ticket-id)  during the candidate ticket verification procedure.
The value of $jam\_ticket\_seal&quot; is constant and defined as &quot;jam\_ticket\_seal&quot; ASCII string.
This is a thing that applies in general for values starting with `$` (e.g. `$foo` in the GP =&gt; `&quot;foo&quot;` ascii string).
(Thank you BTW as I&#x27;ve just spotted that I was using &quot;jam\_seal&quot; instead of &quot;jam\_ticket\_seal&quot;, I&#x27;ll add the fix to the upcoming vectors PR)
The other constant strings ($jam\_fallback\_seal and $jam\_entropy) are used for block verification and per-block entropy production (which is passed as input to Safrole).
NOTE: The actual value of per-block entropy used by the Safrole test vectors is not relevant to have been really produced using the signature in the header. Here we abstract away from the value&#x27;s origin, we don&#x27;t really care for the sake of the Safrole test vectors and Safrole STF. In the specific case I&#x27;ve used:

    - entropy\_0 = blake2b(\[42\_u8; 32\])\[..32\]
    - entropy\_i+1 = blake2b(entropy\_i)\[..32\]
2. If you take as a reference the Sassafras RFC then there some differences.
One of these is the attempts number and redundancy factor, which in the graypaper are in practice simplified to one single entry (attempts number).
Threshold is gone.
Even though reading Sassafras RFC can help (as it is a quite similar protocol), always take the GP as the source of truth for JAM.
3. Sure thing. I&#x27;ll post here as soon as it is ready.
4. This is a very interesting observation. Current implementation serializes 3 extra fields (part of the SNARK SRS).
Serialization of these fields may be important **in a general application**, but here these values are constant.
I will definitely get rid of these from serialized data (I&#x27;m on it). The final size will be 144 (i.e. the last 144 bytes of what you see right now)</div>
<div class='msg'><time>2024‑07‑01 09:09</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * sourabhniyogi:

1. For Safrole test vectors the only thing we use is $jam\_ticket\_seal.
In particular this is used for the ring-vrf input construction (context in the GP) to obtain the ticket score (aka ticket-id)  during the candidate ticket verification procedure.
The value of $jam\_ticket\_seal&quot; is constant and defined as &quot;jam\_ticket\_seal&quot; ASCII string.
This is a thing that applies in general for values starting with `$` (e.g. `$foo` in the GP =&gt; `&quot;foo&quot;` ascii string).
(Thank you BTW as I&#x27;ve just spotted that I was using &quot;jam\_seal&quot; instead of &quot;jam\_ticket\_seal&quot;, I&#x27;ll add the fix to the upcoming vectors PR)
The other constant strings ($jam\_fallback\_seal and $jam\_entropy) are used for block verification and per-block entropy production (which is passed as input to Safrole).
NOTE: The actual value of per-block entropy used by the Safrole test vectors is not relevant to have been really produced using the signature in the header. Here we abstract away from the value&#x27;s origin, we don&#x27;t really care for the sake of the Safrole test vectors and Safrole STF. In the specific case I&#x27;ve used:
    - entropy\_0 = blake2b(\[42\_u8; 32\])\[..32\]
    - entropy\_i+1 = blake2b(entropy\_i)\[..32\]
2. If you take as a reference the Sassafras RFC then there some differences.
One of these is the attempts number and redundancy factor, which in the graypaper are in practice simplified to one single entry (attempts number).
Threshold is gone.
Even though reading Sassafras RFC can help (as it is a quite similar protocol), always take the GP as the source of truth for JAM.
3. Sure thing. I&#x27;ll post here as soon as it is ready.
4. This is a very interesting observation. Current implementation serializes 3 extra fields (part of the SNARK SRS).
Serialization of these fields may be important **in a general application**, but here these values are constant.
I will definitely get rid of these from serialized data (I&#x27;m on it). The final size will be 144 (i.e. the last 144 bytes of what you see right now)</div>
<div class='msg'><time>2024‑07‑01 09:16</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * sourabhniyogi:

1. For Safrole test vectors the only thing we use is $jam\_ticket\_seal.
In particular this is used for the ring-vrf input construction (context in the GP) to obtain the ticket score (aka ticket-id)  during the candidate ticket verification procedure.
The value of $jam\_ticket\_seal&quot; is constant and defined as &quot;jam\_ticket\_seal&quot; ASCII string.
This is a thing that applies in general for values starting with `$` (e.g. `$foo` in the GP =&gt; `&quot;foo&quot;` ascii string).
(Thank you BTW as I&#x27;ve just spotted that I was using &quot;jam\_seal&quot; instead of &quot;jam\_ticket\_seal&quot;, I&#x27;ll add the fix to the upcoming vectors PR)
The other constant strings ($jam\_fallback\_seal and $jam\_entropy) are used for block verification and per-block entropy production (which is passed as input to Safrole).
NOTE: The actual value of per-block entropy used by the Safrole test vectors is not relevant to have been really produced using the signature in the header. Here we abstract away from the value&#x27;s origin, we don&#x27;t really care for the sake of the Safrole test vectors and Safrole STF. In the specific case I&#x27;ve used:

    - entropy\_0 = blake2b(\[42\_u8; 32\])\[..32\]
    - entropy\_i+1 = blake2b(entropy\_i)\[..32\]
2. If you take as a reference the Sassafras RFC then there some differences.
One of these is the attempts number and redundancy factor, which in the GP are in practice simplified to one single thing (attempts number).
Threshold is gone.
Even though reading Sassafras RFC can help (as it is a quite similar protocol), always take the GP as the source of truth for JAM.
3. Sure thing. I&#x27;ll post here as soon as it is ready.
4. This is a very interesting observation. Current implementation serializes 3 extra fields (part of the SNARK SRS).
Serialization of these fields may be important **in a general application**, but here these values are constant.
I will definitely get rid of these from serialized data (I&#x27;m on it). The final size will be 144 (i.e. the last 144 bytes of what you see right now)</div>
<div class='msg'><time>2024‑07‑01 09:16</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: &gt; &lt;@davxy:matrix.org&gt; sourabhniyogi:
&gt; 
&gt; 1. For Safrole test vectors the only thing we use is $jam\_ticket\_seal.
&gt; In particular this is used for the ring-vrf input construction (context in the GP) to obtain the ticket score (aka ticket-id)  during the candidate ticket verification procedure.
&gt; The value of $jam\_ticket\_seal&quot; is constant and defined as &quot;jam\_ticket\_seal&quot; ASCII string.
&gt; This is a thing that applies in general for values starting with `$` (e.g. `$foo` in the GP =&gt; `&quot;foo&quot;` ascii string).
&gt; (Thank you BTW as I&#x27;ve just spotted that I was using &quot;jam\_seal&quot; instead of &quot;jam\_ticket\_seal&quot;, I&#x27;ll add the fix to the upcoming vectors PR)
&gt; The other constant strings ($jam\_fallback\_seal and $jam\_entropy) are used for block verification and per-block entropy production (which is passed as input to Safrole).
&gt; NOTE: The actual value of per-block entropy used by the Safrole test vectors is not relevant to have been really produced using the signature in the header. Here we abstract away from the value&#x27;s origin, we don&#x27;t really care for the sake of the Safrole test vectors and Safrole STF. In the specific case I&#x27;ve used:
&gt; 
&gt;     - entropy\_0 = blake2b(\[42\_u8; 32\])\[..32\]
&gt;     - entropy\_i+1 = blake2b(entropy\_i)\[..32\]
&gt; 2. If you take as a reference the Sassafras RFC then there some differences.
&gt; One of these is the attempts number and redundancy factor, which in the GP are in practice simplified to one single thing (attempts number).
&gt; Threshold is gone.
&gt; Even though reading Sassafras RFC can help (as it is a quite similar protocol), always take the GP as the source of truth for JAM.
&gt; 3. Sure thing. I&#x27;ll post here as soon as it is ready.
&gt; 4. This is a very interesting observation. Current implementation serializes 3 extra fields (part of the SNARK SRS).
&gt; Serialization of these fields may be important **in a general application**, but here these values are constant.
&gt; I will definitely get rid of these from serialized data (I&#x27;m on it). The final size will be 144 (i.e. the last 144 bytes of what you see right now)

I think the `[..32]` after the blake2b is not correct, see https://github.com/w3f/jamtestvectors/issues/6</div>
<div class='msg'><time>2024‑07‑01 09:18</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: I&#x27;ve just seen your issue. Yeah truncated Blake2b-512 has been used for the test vectors. Need to change to blake2b. Thank you</div>
<div class='msg'><time>2024‑07‑01 09:18</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * I&#x27;ve just seen your issue. Yeah truncated Blake2b-512 has been used for the test vectors. Need to change to blake2b 256. Thank you</div>
<div class='msg'><time>2024‑07‑01 09:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: https://github.com/gavofyork/graypaper/releases/tag/v0.2.2 is tagged and download available.</div>
<div class='msg'><time>2024‑07‑01 11:06</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: &gt; Blake2b-512 has been used for the test vectors. Need to change to blake2b 256.
&gt; &quot;jam_seal&quot; instead of &quot;jam_ticket_seal&quot;, I&#x27;ll add the fix to the upcoming vectors PR)

Should we then assume that current test vectors are incorrect and wait for the next release?
As @sourabhniyogi explained, having access to something like 3) as primitives could be very useful... because it can also help to detect these subtle issues in the test vectors themselves

Thank you again for the great responsiveness</div>
<div class='msg'><time>2024‑07‑01 11:37</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * davxy: gav  Some freshman questions on Safrole:

1. For your Safrole test vectors (&quot;tiny&quot;), what are the values of
$jam\_entropy  (was BYTES( &quot;sassafras\_randomness&quot;))
$jam\_ticket\_seal  (was BYTES(&quot;sassafras\_ticket\_seal&quot;))
$jam\_fallback\_seal (was BYTES(&quot;sassafras\_fallback\_seal&quot;))
and what  term in the GP does &quot;entropy&quot; (documented with&quot;Per block entropy (originated from block entropy source VRF)&quot;) refer to from the test vector
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json#L4
?
2. I see &quot;attempt&quot; and &quot;attempts\_number&quot; was renamed to &quot;entry index&quot; and &quot;N&quot; in GP, but what happened to the &quot;ticket threshold&quot; and &quot;redundancy\_factor&quot; - are those \[what I thought key\] concepts gone (in which case, how?) or to be documented still?
3. Since a high level goal of JAM Implementation is to get NON-Rust implementations for Safrole almost everyone will surely use FFI into your recommended crypto package.  Can you ( @davxy) provide a single working test case like say this one
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json
(or the scale equivalent) to set up the ring verifier, get the ring vrf output, and get the entropy buffer updated?  With a single well-worked out test case in Rust handing the &quot;Bare VRF&quot; and &quot;Ring VRF&quot; (specifically making the specific flavors exceptionally clear to &quot;I&#x27;m not a cryptographer, I just use cryptography&quot; engineers), I&#x27;ll bet everyone can use that to set up their `extern &quot;C&quot;` type FFI and pass most of the cases in rapid order.  Is this possible?
4. For the &quot;tickets\_verifier\_key&quot; eg
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-6.json#L210
they are 384 bytes and it is labeled as &quot;gamma\_z: The Bandersnatch ring root.&quot; in `safrole.asn`. However in GP it is documented as being element Y\_R in (47) but in I.1.2 it says it is 144 bytes.  Can you explain further what this discrepancy could be due to?</div>
<div class='msg'><time>2024‑07‑01 11:56</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: &gt; &lt;@davxy:matrix.org&gt; sourabhniyogi:
&gt; 
&gt; 1. For Safrole test vectors the only thing we use is $jam\_ticket\_seal.
&gt; In particular this is used for the ring-vrf input construction (context in the GP) to obtain the ticket score (aka ticket-id)  during the candidate ticket verification procedure.
&gt; The value of $jam\_ticket\_seal&quot; is constant and defined as &quot;jam\_ticket\_seal&quot; ASCII string.
&gt; This is a thing that applies in general for values starting with `$` (e.g. `$foo` in the GP =&gt; `&quot;foo&quot;` ascii string).
&gt; (Thank you BTW as I&#x27;ve just spotted that I was using &quot;jam\_seal&quot; instead of &quot;jam\_ticket\_seal&quot;, I&#x27;ll add the fix to the upcoming vectors PR)
&gt; The other constant strings ($jam\_fallback\_seal and $jam\_entropy) are used for block verification and per-block entropy production (which is passed as input to Safrole).
&gt; NOTE: The actual value of per-block entropy used by the Safrole test vectors is not relevant to have been really produced using the signature in the header. Here we abstract away from the value&#x27;s origin, we don&#x27;t really care for the sake of the Safrole test vectors and Safrole STF. In the specific case I&#x27;ve used:
&gt; 
&gt;     - entropy\_0 = blake2b(\[42\_u8; 32\])\[..32\]
&gt;     - entropy\_i+1 = blake2b(entropy\_i)\[..32\]
&gt; 2. If you take as a reference the Sassafras RFC then there some differences.
&gt; One of these is the attempts number and redundancy factor, which in the GP are in practice simplified to one single thing (attempts number).
&gt; Threshold is gone.
&gt; Even though reading Sassafras RFC can help (as it is a quite similar protocol), always take the GP as the source of truth for JAM.
&gt; 3. Sure thing. I&#x27;ll post here as soon as it is ready.
&gt; 4. This is a very interesting observation. Current implementation serializes 3 extra fields (part of the SNARK SRS).
&gt; Serialization of these fields may be important **in a general application**, but here these values are constant.
&gt; I will definitely get rid of these from serialized data (I&#x27;m on it). The final size will be 144 (i.e. the last 144 bytes of what you see right now)

Thank you!  </div>
<div class='msg'><time>2024‑07‑01 16:41</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: Alright we&#x27;re getting there.

I&#x27;ve updated the [PR](https://github.com/w3f/jamtestvectors/pull/5) with all the fixes we&#x27;ve discussed so far. Check the description for the changes.
(if you find / suspect something else please tell)

In order to reduce the ring keys commitment to 144 (as per GP) I had to patch an upstream dependency. So I&#x27;ll temporarily point ark-ec-vrfs to the patched `ring-proof` for the moment (not pushed yet, I&#x27;ll notify here when ready).

Juan Leni | zondax.ch Yeah. Unfortunately there was the blake2b thing that invalidated tickets data and some pseudo randomly constructed things that were depending on the hash previously used. 

For tomorrow you&#x27;ll have a clear example of how to use ring vrf.</div>
<div class='msg'><time>2024‑07‑01 16:43</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * Alright we&#x27;re getting there.

I&#x27;ve updated the [PR](https://github.com/w3f/jamtestvectors/pull/5) with all the fixes we&#x27;ve discussed so far. Check the description for the changes.
(if you find / suspect something else please tell)

In order to reduce the ring keys commitment to 144 (as per GP) I had to patch an upstream dependency. So I&#x27;ll temporarily point ark-ec-vrfs to the patched `ring-proof` for the moment (not pushed yet, I&#x27;ll notify here when ready).

Juan Leni | zondax.ch Yeah. Unfortunately there was the blake2b thing that invalidated tickets data and some pseudo randomly constructed things that were depending on the hash previously used.

For tomorrow you&#x27;ll have a clear example of how to use ring vrf (maybe I&#x27;ll put it in the bandersnatch-specs repo)</div>
<div class='msg'><time>2024‑07‑02 18:04</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: https://github.com/davxy/bandersnatch-vrfs-spec/commit/9bf454693a8e27776bd1bdde551dda4b51f22451

A couple of trivial examples pushed in the specs repo.</div>
<div class='msg'><time>2024‑07‑02 19:43</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Thank you, this simplifies &quot;which flavor&quot; questions a lot!  But how can we construct `_vrf_output` not from 
```
let _vrf_output = &amp;output.hash()[..32];
```
(which uses one of the randomly generated secrets
```
let output = secret.output(input);
```
) but instead from the extrinsic signature ALONE
https://github.com/w3f/jamtestvectors/blob/master/safrole/publish-tickets-no-mark-2.json#L8
(and the verifier key and/or the set of authorities that can submit tickets)

This expectation of  `vrf_signed_output(signature)` being possible was set by this line here
https://github.com/polkadot-fellows/RFCs/blob/main/text/0026-sassafras-consensus.md?plain=1#L228C34-L228C62
and codified in 
GP 0.2.2 (303)+(306)
I think we would like a &quot;fn ring_verify()&quot; [and &quot;fn ietf_verify()&quot;] that does NOT set up a prover with any secret generation at all.  Is this reasonable?</div>
<div class='msg'><time>2024‑07‑02 21:52</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: It is quite easy. The signature you see in the extrinsic is a ring signature.
You can deserialize it into the `RingSignature` struct you see in the example (the one who contain the output+ring proof).
Once deserialized you can:
- validate the proof constructing the Verifier as the example show
- use the output point entry to actually generate the vrf output hash
Does this help? 
To be more concrete, I&#x27;ll add an example which verifies one of the signatures in the test vectors</div>
<div class='msg'><time>2024‑07‑02 21:52</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: * It is quite easy. The signature you see in the extrinsic is a ring signature.
You can deserialize it into the `RingSignature` struct you see in the example (the one who contain the output+ring proof).
Once deserialized you can:
- validate the proof constructing the Verifier as the example show
- use the output point entry to actually generate the vrf output hash

Does this help? 
To be more concrete, I&#x27;ll add an example which verifies one of the signatures in the test vectors</div>
<div class='msg'><time>2024‑07‑02 21:56</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: * It is quite easy. The signature you see in the extrinsic is a ring signature.
You can deserialize it into the `RingSignature` struct you see in the example (the one who contain the output+ring proof).
Once deserialized you can:
- validate the proof constructing the Verifier as the example show
- use the struct&#x27;s output entry to actually generate the vrf output hash

Does this help? 
To be more concrete, I&#x27;ll add an example which verifies one of the signatures in the test vectors</div>
<div class='msg'><time>2024‑07‑02 21:59</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: * It is quite easy. The signature you see in the extrinsic is a ring signature.
You can deserialize it into the `RingSignature` struct you see in the example (the one who contain the output+ring proof).
Once deserialized you can:
- validate the proof constructing the Verifier as the example show
- use the struct&#x27;s output entry to actually generate the vrf output hash

Does this help? 
To be more concrete, I&#x27;ll add an example as you suggested</div>
<div class='msg'><time>2024‑07‑02 22:30</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: &gt; &lt;@davxy:matrix.org&gt; It is quite easy. The signature you see in the extrinsic is a ring signature.
&gt; You can deserialize it into the `RingSignature` struct you see in the example (the one who contain the output+ring proof).
&gt; Once deserialized you can:
&gt; - validate the proof constructing the Verifier as the example show
&gt; - use the struct&#x27;s output entry to actually generate the vrf output hash
&gt; 
&gt; Does this help? 
&gt; To be more concrete, I&#x27;ll add an example as you suggested

Yes that final example should do it, wonderful</div>
<div class='msg'><time>2024‑07‑02 23:20</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: I&#x27;ve updated the example in the spec repo. Check that out</div>
<div class='msg reply'><time>2024‑07‑03 16:36</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: is 20-24 secs the typical time for ring_prove_verify? 
running in a macbook with M3</div>
<div class='msg reply'><time>2024‑07‑03 17:34</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: Not really. Is a bit too much :-)
```
❯ cargo run  --release
   Compiling ark-ec-vrfs-bandersnatch-example v0.1.0 (/mnt/ssd/develop/bandersnatch-vrfs-spec/example)
    Finished `release` profile [optimized] target(s) in 1.48s
     Running `target/release/ark-ec-vrfs-bandersnatch-example`
* Time taken by ring-vrf-sign: 629.248169ms
Ring signature verified
 vrf-output-hash: 6b260bfda2e3ef118c529f30b60dfa4678fbeef3682b55ba002aa8633f1b0364
* Time taken by ring-vrf-verify: 6.105183ms
* Time taken by ietf-vrf-sign: 394.206µs
Ietf signature verified
 vrf-output-hash: 6b260bfda2e3ef118c529f30b60dfa4678fbeef3682b55ba002aa8633f1b0364
* Time taken by ietf-vrf-verify: 599.059µs
```

I have a beefy threadripper 3970X, but I don&#x27;t expect 24s

See here latest benchmarks: https://github.com/davxy/crypto-benches/blob/main/vrf/README.md#verify</div>
<div class='msg reply'><time>2024‑07‑03 17:38</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: Proving is expected to be slow (well not that slow). But proving is done once per epoch, offchain and by powerful enough candidate validators</div>
<div class='msg reply'><time>2024‑07‑03 17:46</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: Verification is more critical. Number of tickets per block is limited to 16 (by the GP) and multiple tickets verification can be done in parallel.</div>
<div class='msg reply'><time>2024‑07‑03 17:50</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: Oh. I also forgot to add the &quot;parallel&quot; feature to `ark-ec-vrfs`.

These are the correct timings:
```
❯ cargo run --releaseandersnatch-example`
* Time taken by ring-vrf-sign: 164.761467ms
Ring signature verified
 vrf-output-hash: 6b260bfda2e3ef118c529f30b60dfa4678fbeef3682b55ba002aa8633f1b0364
* Time taken by ring-vrf-verify: 6.42629ms
* Time taken by ietf-vrf-sign: 408.352µs
Ietf signature verified
 vrf-output-hash: 6b260bfda2e3ef118c529f30b60dfa4678fbeef3682b55ba002aa8633f1b0364
* Time taken by ietf-vrf-verify: 622.041µs
```</div>
<div class='msg reply'><time>2024‑07‑23 00:46</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: iThe key insight, we found, is from RFC 26 [which we&#x27;re not supposed to get too confused by but is an excellent introduction] in these:
(a) ietf_vrf_output (Non anonymous VRF): vrf_output(secret, input) == vrf_signed_output(signature) 
(b) ring_vrf_output (Anonymous VRF): vrf_signed_output(signature) == ring_vrf_signed_output(ring_signature);
The (a) case has the block author reveal himself through the signature of (a)
The (b)  does not reveal the ticket submitter. Which is the beauty of RingVRFs, an important invention.  
The key AHA I think for people is: 

vrf_output(secret, input) == vrf_signed_output(signature) == ring_vrf_signed_output(ring_signature)

which maps onto this line here:
 https://github.com/davxy/bandersnatch-vrfs-spec/blob/1ec75e9a3af3a2be7dbca5090171c01e29ac5854/example/src/main.rs#L268C33-L268C48


</div>
<div class='msg'><time>2024‑07‑03 00:08</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Perfect, thank you!  I think most non-cryptographer non-Rust engineers can jump into this and execute now.  </div>
<div class='msg'><time>2024‑07‑03 00:10</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Perfect, thank you!  I think most non-cryptographer non-Rust engineers can jump into this and execute now.  [We will proceed to try to pass our first few tiny tests with a FFI, hope others will do the same]</div>
<div class='msg'><time>2024‑07‑03 16:37</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>:  * is 20-24 secs the typical time for ring\_prove\_verify? 
running in a macbook with M3
.. wow..</div>
<div class='msg'><time>2024‑07‑03 17:52</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * Oh. I also forgot to add the &quot;parallel&quot; feature to `ark-ec-vrfs`.

These are the timings (as you can see proving is a lot faster):

```
❯ cargo run --releaseandersnatch-example`
* Time taken by ring-vrf-sign: 164.761467ms
Ring signature verified
 vrf-output-hash: 6b260bfda2e3ef118c529f30b60dfa4678fbeef3682b55ba002aa8633f1b0364
* Time taken by ring-vrf-verify: 6.42629ms
* Time taken by ietf-vrf-sign: 408.352µs
Ietf signature verified
 vrf-output-hash: 6b260bfda2e3ef118c529f30b60dfa4678fbeef3682b55ba002aa8633f1b0364
* Time taken by ietf-vrf-verify: 622.041µs
```</div>
<div class='msg'><time>2024‑07‑03 17:52</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * Oh. I also forgot to add the &quot;parallel&quot; feature to `ark-ec-vrfs`.

These are the timings (as you can see proving is a lot faster):

```
❯ cargo run --release
* Time taken by ring-vrf-sign: 156.818104ms
Ring signature verified
 vrf-output-hash: 6b260bfda2e3ef118c529f30b60dfa4678fbeef3682b55ba002aa8633f1b0364
* Time taken by ring-vrf-verify: 6.4541ms
* Time taken by ietf-vrf-sign: 412.089µs
Ietf signature verified
 vrf-output-hash: 6b260bfda2e3ef118c529f30b60dfa4678fbeef3682b55ba002aa8633f1b0364
* Time taken by ietf-vrf-verify: 613.725µs
```</div>
<div class='msg'><time>2024‑07‑04 00:20</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: davxy: We succeeded with our FFI, but did not get a &quot;tiny&quot; extrinsic verification to work yet:

https://github.com/w3f/jamtestvectors/pull/5#issuecomment-2207625234

What did we miss?</div>
<div class='msg'><time>2024‑07‑04 10:28</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: Test vectors PR updated to make use of a not &quot;random&quot; SRS (the stuff used to construct the RingContext).
Check the README for some pointers and update ark-ec-vrfs for new constructor.</div>
<div class='msg reply'><time>2024‑07‑04 12:26</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Got it -- I got the new ring_context and am pulling the binary of &quot;zcash-srs-2-11-uncompressed.bin&quot; but still no verification yet: https://github.com/w3f/jamtestvectors/pull/5#issuecomment-2208850402
What did we miss?</div>
<div class='msg reply'><time>2024‑07‑04 13:16</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: Replied in the PR</div>
<div class='msg reply'><time>2024‑07‑04 14:34</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Woohoo!  Thank you!</div>
<div class='msg reply'><time>2024‑07‑06 05:27</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: We are succeeding with most of the STF successfully thanks to your example, but have a few outstanding cases in &quot;tiny&quot; to address: 

https://github.com/w3f/jamtestvectors/pull/5#issuecomment-2211649983

Can you kindly advise?</div>
<div class='msg'><time>2024‑07‑04 12:34</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Question: In Section 15 Guaranteeing &quot;With two guarantor signatures, the work-report may be distributed to the forthcoming Jam chain block author in order to be used in the E_G, which leads to a reward for the guarantors.&quot; .. but how could  a work-report be distributed to a _forthcoming_ block author if via Safrole block authors are only knowable when they actually reveal themselves when they actually author the block?</div>
<div class='msg'><time>2024‑07‑04 12:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Question: In Section 15 Guaranteeing &quot;With two guarantor signatures, the work-report may be distributed to the forthcoming Jam chain block author in order to be used in the E_G, which leads to a reward for the guarantors.&quot; .. but how could  a work-report be distributed to a _forthcoming_ block author if via Safrole block authors are only knowable when they actually reveal themselves when they actually author the block?

By distributing to all possible nodes.</div>
<div class='msg'><time>2024‑07‑04 12:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Question: In Section 15 Guaranteeing &quot;With two guarantor signatures, the work-report may be distributed to the forthcoming Jam chain block author in order to be used in the E_G, which leads to a reward for the guarantors.&quot; .. but how could  a work-report be distributed to a _forthcoming_ block author if via Safrole block authors are only knowable when they actually reveal themselves when they actually author the block?

 * By distributing to all possible authors.</div>
<div class='msg'><time>2024‑07‑04 12:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * By distributing to all possible authors (i.e. all validators).</div>
<div class='msg'><time>2024‑07‑04 12:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * By distributing to all possible block authors (i.e. all validators).</div>
<div class='msg'><time>2024‑07‑04 12:59</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: I know networking is still not fully defined.. but I have a quick follow up question on that.. the idea in jam is that every node will connect to every other node and they will be no gossip at all, right?</div>
<div class='msg'><time>2024‑07‑04 13:00</time>&ensp;<span class='u' style='color:#2fbc2e'>purpletentacle</span>: * I know networking is still not fully defined.. but I have a quick follow up question on that.. the idea in jam is that every node will connect to every other node and there will be no gossip at all, right?</div>
<div class='msg'><time>2024‑07‑04 15:56</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Here is working verification in Rust (with matching &quot;gamma_z&quot; =)) for &quot;tiny&quot; case in @davxy PR:  https://gist.github.com/sourabhniyogi/7097609935fc7a584d71731acdf32027

Thank you davxy !</div>
<div class='msg'><time>2024‑07‑04 16:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@purpletentacle:matrix.org&gt; I know networking is still not fully defined.. but I have a quick follow up question on that.. the idea in jam is that every node will connect to every other node and there will be no gossip at all, right?

Yes indeed.</div>
<div class='msg'><time>2024‑07‑04 16:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It&#x27;s still a WiP, but you can get a feel for the basic networking protocol https://hackmd.io/@polkadot/jamsnp</div>
<div class='msg'><time>2024‑07‑04 16:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There will likely be two revisions of the protocol - one initial JAMSNP focusing on simplicity and ease of implementation/conformance and a second JAMNP focussed on optimisation and security.</div>
<div class='msg'><time>2024‑07‑04 16:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * There will likely be two revisions of the protocol - one initial JAMSNP focusing on simplicity and speed of implementation and a second JAMNP focussed on optimisation and security.</div>
<div class='msg'><time>2024‑07‑04 22:59</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Is it reasonable to have a &quot;tiny&quot; setup (like 6 validators, single team with another team, enabling Milestone 1 &quot;solo&quot; networking PoC, easy to simulate), &quot;medium&quot; setup (like 15-30 validators, enabling Milestone 2 &quot;multi-team&quot; networking PoC with like 4-5 teams, possible to simulate for a single team though) WELL before the 1023 validator set up (which few teams will have resources for, not sure if its even possible to simulate).  I am wondering if a &quot;lite&quot; Erasure coding would be worth it to support tiny and medium cases for simplicity / speed of implementation in this tiny vs medium situation, and could have significant utility in the next 6-9 months?</div>
<div class='msg'><time>2024‑07‑04 23:01</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Is it reasonable to have a &quot;tiny&quot; setup (like 6 validators, single team with  _maybe_ another team, enabling Milestone 1 &quot;solo&quot; networking PoC, easy to simulate and then run QUIC for real), &quot;medium&quot; setup (like 15-30 validators, enabling Milestone 2 &quot;multi-team&quot; networking PoC with like 4-5 teams, possible to simulate for a single team though with some basic resources) WELL before the 1023 validator set up (which few teams will have resources for, not sure if its even possible to simulate?).  I am wondering if a &quot;lite&quot; Erasure coding would be worth it to support tiny and medium cases for simplicity / speed of implementation in this tiny vs medium situation, and could have significant utility in the next 6-9 months?</div>
<div class='msg'><time>2024‑07‑04 23:04</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Thank you for this sketch, its very helpful!  Is it reasonable to have a &quot;tiny&quot; setup (like 6 validators, single team with  _maybe_ another team, enabling Milestone 1 &quot;solo&quot; networking PoC, easy to simulate and then run QUIC for real), &quot;medium&quot; setup (like 16-32 validators, enabling Milestone 2 &quot;multi-team&quot; networking PoC with like 4-5 teams, possible to simulate and do for real for a single team though with some basic resources) WELL before the 1023 validator set up (which few teams will have resources for, not sure if its even possible to simulate?).  I am wondering if a &quot;lite Appendix H&quot; (not in GP, but suitable for Milestone 1) Erasure coding would be worth it to support tiny and medium cases for simplicity / speed of implementation in this tiny vs medium situation, and could have significant utility in the next 6-9 months?</div>
<div class='msg'><time>2024‑07‑04 23:05</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Thank you for this sketch, its very helpful!  Is it reasonable to have a &quot;tiny&quot; setup (like 6 validators, single team with  _maybe_ another team, enabling Milestone 1 &quot;solo&quot; networking PoC, easy to simulate and then run QUIC for real), &quot;medium&quot; setup (like 16-32 validators, enabling Milestone 2 &quot;multi-team&quot; networking PoC with like 4-5 teams, possible to simulate and do for real for a single team though with some basic resources) WELL before the 1023 validator set up (which few teams will have resources for, not sure if its even possible to simulate?).  I am wondering if a &quot;lite Appendix H&quot; (not in GP, but suitable for Milestone 1+2) Erasure coding would be worth it to support tiny and medium cases for simplicity / speed of implementation in this tiny vs medium situation, and could have significant utility in the next 6-9 months?  </div>
<div class='msg'><time>2024‑07‑05 00:23</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: we will have JAM Toaster for the 1023 validators setup</div>
<div class='msg'><time>2024‑07‑05 00:24</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: those constants should be configurable and in theory all we need to do is config the node with corresponding values</div>
<div class='msg'><time>2024‑07‑05 00:25</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: (I had the mistake to hardcoded the constants and later need to refactor the code to make them configurable)</div>
<div class='msg'><time>2024‑07‑05 02:41</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Absolutely!  I mean to ask if before 341*3=1023 (JAM Toaster sized) we can have 
* tiny C=2 * 3 = 6 validators 
* xsmall  C = 4 x 3 = 12 validators
* small C = 6 x 3 = 18 validators
* medium  C = 10 x 3 = 30 validators
* large C = 30 x 3 = 90 validators
* xlarge C = 50 x 3 =150 validators
* xxlarge C = 100 x 3 = 300 validators 
* The Toaster C = 341 x 3 = 1023 validators
where we can just have different RS codes in various JAM configurations to match.  I believe we only need 3, but I think the RS code of 342:1026 is &quot;impedance matched&quot; to C=341+1 so probably there are more perfect values of C than others? 

Is the concept of a &quot;bootnode&quot; gone?  Where does the 18 byte per validator directory live?</div>
<div class='msg'><time>2024‑07‑05 02:42</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Absolutely!  I mean to ask if before 341\*3=1023 (JAM Toaster sized) we can have

- tiny C=2 x 3 = 6 validators
- xsmall  C = 4 x 3 = 12 validators
- small C = 6 x 3 = 18 validators
- medium  C = 10 x 3 = 30 validators
- large C = 30 x 3 = 90 validators
- xlarge C = 50 x 3 =150 validators
- xxlarge C = 100 x 3 = 300 validators
- The Toaster C = 341 x 3 = 1023 validators
where we can just have different RS codes in various JAM configurations to match.  I believe we only need 3 configurations (one for the first 3 milestones), but I think the RS code of 342:1026 is &quot;impedance matched&quot; to C=341+1 so probably there are more perfect values of C than others for smaller C?

Is the concept of a &quot;bootnode&quot; gone?  Where does the 18 byte per validator directory live?</div>
<div class='msg'><time>2024‑07‑05 02:43</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: there is a 32 bytes metadata in the validator key</div>
<div class='msg'><time>2024‑07‑05 02:43</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: which contains the ipv6 address</div>
<div class='msg'><time>2024‑07‑05 02:44</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: but I guess we still need some bootnodes, it is just that technically the network does need it to be alive so it doesn&#x27;t need to be specified?</div>
<div class='msg'><time>2024‑07‑05 02:45</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: we can still have some implementation specific genesis config that includes some bootnodes and could make it such way that all implementations to support such format. it is just that this doesn&#x27;t need to be defined in GP</div>
<div class='msg'><time>2024‑07‑05 04:45</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: &gt; &lt;@gav:polkadot.io&gt; There will likely be two revisions of the protocol - one initial JAMSNP focusing on simplicity and speed of implementation and a second JAMNP focussed on optimisation and security.

What&#x27;s the plan for in-browser light clients? Would be good to have something web socket based (or maybe even REST 🤪) since nothing more fancy can be initiated from the browser context afair.
Alternatively I can imagine a websocket&lt;&gt;jam gateway but if it&#x27;s not part of major client implementations we are risking heavy centralization and/or monoculture of implementations that one can connect to.</div>
<div class='msg'><time>2024‑07‑05 11:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; but I guess we still need some bootnodes, it is just that technically the network does need it to be alive so it doesn&#x27;t need to be specified?

bootnodes are always a painpoint. JAM won&#x27;t address them directly, but we might use something like IPFS or WebTorrent to distribute them</div>
<div class='msg'><time>2024‑07‑05 11:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; but I guess we still need some bootnodes, it is just that technically the network does need it to be alive so it doesn&#x27;t need to be specified?

 * bootnodes are always a painpoint. JAM won&#x27;t address them directly, but we might use something like IPFS or WebTorrent to distribute them in a resilient way.</div>
<div class='msg'><time>2024‑07‑05 11:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@tomusdrw:matrix.org&gt; What&#x27;s the plan for in-browser light clients? Would be good to have something web socket based (or maybe even REST 🤪) since nothing more fancy can be initiated from the browser context afair.
&gt; Alternatively I can imagine a websocket&lt;&gt;jam gateway but if it&#x27;s not part of major client implementations we are risking heavy centralization and/or monoculture of implementations that one can connect to.

yes indeed - this should be figured out and standardised fairly early on, but it&#x27;s not crucial for the (validator) protocol pre se.</div>
<div class='msg'><time>2024‑07‑05 11:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * yes indeed - this should be figured out and standardised fairly early on, but it&#x27;s not crucial for the (validator) protocol per se.</div>
<div class='msg'><time>2024‑07‑05 12:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: @room another new release https://github.com/gavofyork/graypaper/releases/tag/v0.2.3</div>
<div class='msg'><time>2024‑07‑05 13:04</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: * but I guess we still need some bootnodes, it is just that technically the network doesn’t need it to be alive so it doesn&#x27;t need to be specified?</div>
<div class='msg'><time>2024‑07‑06 13:55</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: Hi everyone! In Appendix H of the Gray paper, we are trying to understand what GF(16) means.  In the latest version of the Gray paper, it is mentioned that 16-bit GF points are selected, so we believe that the GF(16) here should refer to GF(2^16).  -- do we understand this correctly?</div>
<div class='msg'><time>2024‑07‑06 14:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: yes :)</div>
<div class='msg'><time>2024‑07‑07 03:04</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: &gt; &lt;@gav:polkadot.io&gt; yes :)

Thank you!</div>
<div class='msg'><time>2024‑07‑07 10:53</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: I dont understand how the selection of fallback keys works here. It looks like `k` is being indexed a random index (i assume `u32`).  
But `k` only has 600 elements, so it will try to access invalid indices? Is there a hidden modulo somewhere?</div>
<div class='msg'><time>2024‑07‑07 10:53</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: Screenshot 2024-07-07 at 12.49.08.png</div>
<div class='msg'><time>2024‑07‑07 10:54</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>:  * I dont understand how the selection of fallback keys works here. It looks like `k` is being indexed with a random index (i assume `u32`).  
But `k` only has 600 elements, so it will try to access invalid indices? Is there a hidden modulo somewhere?</div>
<div class='msg'><time>2024‑07‑07 11:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The little circular arrow functions as a modulus. </div>
<div class='msg'><time>2024‑07‑07 11:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: See the definition in the notation section. </div>
<div class='msg'><time>2024‑07‑08 05:36</time>&ensp;<span class='u' style='color:#c42eb3'>bhcme</span>: Hi everyone! 👋 

I wonder why the rate of 342:1026 is used for erasure coding, as stated in the opening sentence of Appendix H, Erasure Coding: “The foundation of the data-availability and distribution system of Jam is a systematic Reed-Solomon erasure coding function in gf(16) of rate 342:1026, as defined by Lin, Chung, and Han 2014.”

In particular, the precondition for the efficient implementation of the Reed-Solomon encoding and erasure decoding algorithm mentioned in the above paper only applies for (n = 2^r, k)</div>
<div class='msg'><time>2024‑07‑08 06:41</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Can we get PVM Host function test cases soon?  Here is my wish:
https://github.com/w3f/jamtestvectors/pull/3#issuecomment-2212706605

Some candidate typo fixes for Appendix B: [for GP v0.2.3]
1. For `info`, it has `b_o` instead of `o` on the 4th mutation lin3
2.  For `designate`, does the 176 (144+32 I gather?) might need to be 336 to match (51)-(55)?  If not, what is the content of the 176 bytes per validator?
3. For `peek`, it seems to need `l` instead of `i`  on 2nd and 3rd mutation lines 
4. Similarly for `poke`, it seems to need `l` instead of `i` on 3rd and 4th mutation lines
</div>
<div class='msg'><time>2024‑07‑08 08:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Appendix A and B are rather different things so it makes little sense to comment on that issue. </div>
<div class='msg'><time>2024‑07‑08 08:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Appendix A and B are rather different things so it makes little sense to comment on that PR. </div>
<div class='msg'><time>2024‑07‑08 08:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Can we get PVM Host function test cases soon?  Here is my wish:
&gt; https://github.com/w3f/jamtestvectors/pull/3#issuecomment-2212706605
&gt; 
&gt; Some candidate typo fixes for Appendix B: [for GP v0.2.3]
&gt; 1. For `info`, it has `b_o` instead of `o` on the 4th mutation lin3
&gt; 2.  For `designate`, does the 176 (144+32 I gather?) might need to be 336 to match (51)-(55)?  If not, what is the content of the 176 bytes per validator?
&gt; 3. For `peek`, it seems to need `l` instead of `i`  on 2nd and 3rd mutation lines 
&gt; 4. Similarly for `poke`, it seems to need `l` instead of `i` on 3rd and 4th mutation lines
&gt; 

Test vectors will arrive when they’re ready and in the order that they’re ready. I’d caution you not to be pushy about it. Doing so will not aid their swift arrival. </div>
<div class='msg'><time>2024‑07‑08 11:51</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Can we get PVM Host function test cases soon?  Here is my wish:
https://github.com/w3f/jamtestvectors/pull/3#issuecomment-2212706605

Some candidate typo fixes for Appendix B: \[for GP v0.2.3\]

1. For `info`, it has `b_o` instead of `o` on the 4th mutation line 3
2. For `designate`, does the 176 (144+32 I gather?) need to be 336 to match (51)-(55)?  If not, what is the content of the 176 bytes per validator?
3. For `peek`, it seems to need `l` instead of `i`  on 2nd and 3rd mutation lines
4. Similarly for `poke`, it seems to need `l` instead of `i` on 3rd and 4th mutation lines</div>
<div class='msg'><time>2024‑07‑08 19:38</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Can we get PVM Host function test cases soon?  Here is my wish:
https://github.com/w3f/jamtestvectors/pull/3#issuecomment-2212706605

Some candidate typo fixes for Appendix B: \[for GP v0.2.3\]

1. For `info`, it has `b_o` instead of `o` on the 4th mutation 
2. For `designate`, does the 176 (144+32 I gather?) need to be 336 to match (51)-(55)?  If not, what is the content of the 176 bytes per validator?
3. For `peek`, it seems to need `l` instead of `i`  on 2nd and 3rd mutation lines
4. Similarly for `poke`, it seems to need `l` instead of `i` on 3rd and 4th mutation lines</div>
<div class='msg'><time>2024‑07‑12 14:31</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: </div>
<div class='msg'><time>2024‑07‑12 14:32</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: jam-dependencies.jpeg</div>
<div class='msg reply'><time>2024‑07‑12 14:34</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: here is the source code for it (generate image at: https://yuml.me/pravaler)

```
// greek letters
// -----------------------
[τ&#x27;] -&gt; [H]

[β&#x27;] -&gt; [H]
[β&#x27;] -&gt; [EG]
[β&#x27;] -&gt; [C]

[γ&#x27;] -&gt; [H]
[γ&#x27;] -&gt; [τ]
[γ&#x27;] -&gt; [ET]
[γ&#x27;] -&gt; [γ]
[γ&#x27;] -&gt; [ι]
[γ&#x27;] -&gt; [η&#x27;]
[γ&#x27;] -&gt; [κ&#x27;]

[η&#x27;] -&gt; [H]
[η&#x27;] -&gt; [η]
[η&#x27;] -&gt; [τ]

[κ&#x27;] -&gt; [H]
[κ&#x27;] -&gt; [τ]
[κ&#x27;] -&gt; [κ]
[κ&#x27;] -&gt; [γ]
[κ&#x27;] -&gt; [ψ&#x27;]

[λ&#x27;] -&gt; [H]
[λ&#x27;] -&gt; [τ]
[λ&#x27;] -&gt; [λ]
[λ&#x27;] -&gt; [κ]

[ψ&#x27;] -&gt; [EJ]
[ψ&#x27;] -&gt; [ψ]

[δ†] -&gt; [EP]
[δ†] -&gt; [δ]
[δ†] -&gt; [τ&#x27;]

[ρ†] -&gt; [EJ]
[ρ†] -&gt; [ρ]

[ρ‡] -&gt; [EA]
[ρ‡] -&gt; [ρ†]

[ρ&#x27;] -&gt; [EG]
[ρ&#x27;] -&gt; [ρ‡]
[ρ&#x27;] -&gt; [κ]
[ρ&#x27;] -&gt; [τ&#x27;]

[δ&#x27;
χ&#x27;
ι&#x27;] -&gt; [EA]
[δ&#x27;
χ&#x27;
ι&#x27;] -&gt; [ρ&#x27;]
[δ&#x27;
χ&#x27;
ι&#x27;] -&gt; [δ†]
[δ&#x27;
χ&#x27;
ι&#x27;] -&gt; [χ]
[δ&#x27;
χ&#x27;
ι&#x27;] -&gt; [ι]
[δ&#x27;
χ&#x27;
ι&#x27;] -&gt; [φ] 

[φ&#x27;] -&gt; [EA]
[φ&#x27;] -&gt; [ρ&#x27;]
[φ&#x27;] -&gt; [δ†]
[φ&#x27;] -&gt; [χ]
[φ&#x27;] -&gt; [ι]
[φ&#x27;] -&gt; [φ] 

[C] -&gt; [EA]
[C] -&gt; [ρ&#x27;]
[C] -&gt; [ρ†]
[C] -&gt; [χ]
[C] -&gt; [ι]
[C] -&gt; [φ] 

[α&#x27;] -&gt; [EG]
[α&#x27;] -&gt; [φ&#x27;] 
[α&#x27;] -&gt; [α] 

[π&#x27;] -&gt; [EG]
[π&#x27;] -&gt; [EP]
[π&#x27;] -&gt; [EA]
[π&#x27;] -&gt; [ET]
[π&#x27;] -&gt; [τ&#x27;]
[π&#x27;] -&gt; [τ]
[π&#x27;] -&gt; [π]
```
</div>
<div class='msg'><time>2024‑07‑12 14:33</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: I have created a diagram mapping all state transition components dependencies. I hope it is useful.</div>
<div class='msg'><time>2024‑07‑12 14:34</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>:  * here is the source code for it (generate image at: https://yuml.me/)

```
// greek letters
// -----------------------
[τ&#x27;] -&gt; [H]

[β&#x27;] -&gt; [H]
[β&#x27;] -&gt; [EG]
[β&#x27;] -&gt; [C]

[γ&#x27;] -&gt; [H]
[γ&#x27;] -&gt; [τ]
[γ&#x27;] -&gt; [ET]
[γ&#x27;] -&gt; [γ]
[γ&#x27;] -&gt; [ι]
[γ&#x27;] -&gt; [η&#x27;]
[γ&#x27;] -&gt; [κ&#x27;]

[η&#x27;] -&gt; [H]
[η&#x27;] -&gt; [η]
[η&#x27;] -&gt; [τ]

[κ&#x27;] -&gt; [H]
[κ&#x27;] -&gt; [τ]
[κ&#x27;] -&gt; [κ]
[κ&#x27;] -&gt; [γ]
[κ&#x27;] -&gt; [ψ&#x27;]

[λ&#x27;] -&gt; [H]
[λ&#x27;] -&gt; [τ]
[λ&#x27;] -&gt; [λ]
[λ&#x27;] -&gt; [κ]

[ψ&#x27;] -&gt; [EJ]
[ψ&#x27;] -&gt; [ψ]

[δ†] -&gt; [EP]
[δ†] -&gt; [δ]
[δ†] -&gt; [τ&#x27;]

[ρ†] -&gt; [EJ]
[ρ†] -&gt; [ρ]

[ρ‡] -&gt; [EA]
[ρ‡] -&gt; [ρ†]

[ρ&#x27;] -&gt; [EG]
[ρ&#x27;] -&gt; [ρ‡]
[ρ&#x27;] -&gt; [κ]
[ρ&#x27;] -&gt; [τ&#x27;]

[δ&#x27;
χ&#x27;
ι&#x27;] -&gt; [EA]
[δ&#x27;
χ&#x27;
ι&#x27;] -&gt; [ρ&#x27;]
[δ&#x27;
χ&#x27;
ι&#x27;] -&gt; [δ†]
[δ&#x27;
χ&#x27;
ι&#x27;] -&gt; [χ]
[δ&#x27;
χ&#x27;
ι&#x27;] -&gt; [ι]
[δ&#x27;
χ&#x27;
ι&#x27;] -&gt; [φ] 

[φ&#x27;] -&gt; [EA]
[φ&#x27;] -&gt; [ρ&#x27;]
[φ&#x27;] -&gt; [δ†]
[φ&#x27;] -&gt; [χ]
[φ&#x27;] -&gt; [ι]
[φ&#x27;] -&gt; [φ] 

[C] -&gt; [EA]
[C] -&gt; [ρ&#x27;]
[C] -&gt; [ρ†]
[C] -&gt; [χ]
[C] -&gt; [ι]
[C] -&gt; [φ] 

[α&#x27;] -&gt; [EG]
[α&#x27;] -&gt; [φ&#x27;] 
[α&#x27;] -&gt; [α] 

[π&#x27;] -&gt; [EG]
[π&#x27;] -&gt; [EP]
[π&#x27;] -&gt; [EA]
[π&#x27;] -&gt; [ET]
[π&#x27;] -&gt; [τ&#x27;]
[π&#x27;] -&gt; [τ]
[π&#x27;] -&gt; [π]
```</div>
<div class='msg'><time>2024‑07‑13 19:19</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Hello everyone,

I have some questions, I don&#x27;t know if I should post them here or on the Jam Chat channel but 🤷‍♂️ here we go :

### Appendix G:

1. **Signature Set and Key Generation:**
   - To confirm, is \( F_{m,k} \) the set of signatures using the IETF VRF (as per Goldberg 2023) where keys are generated from the Bandersnatch curve?

2. **Size of Y:**
   - Why is \( Y \) of size 96 bytes? We perform `decode(x:32)` and `decode(x32:)`. Does this mean that the first 32 bytes are the public key and the rest is additional data?

3. **Merkle Root and Public Keys:**
   - To confirm, is \( O([H_B]) \) the Merkle root of the Merkle tree where the leaves are the authors&#x27; public keys?

4. **Use of RingVRF:**
   - To confirm, do we use the ring VRF from the Jeffrey 2023 paper, with the first ring VRF construction (part 4 of the paper) and with \( \text{Com}^*.\text{Commit}(\text{ring}) = O([H_B]) \)?

5. **Size of Y (second instance):**
   - Why is \( Y \) of size 784 bytes? We perform `decode(x:32)` and `decode(x32:)` again. Does this mean that the first 32 bytes are the public key and the rest is additional data?</div>
<div class='msg'><time>2024‑07‑13 19:20</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: ### Appendix I.4.5:

1. **$jam_fallback_seal:**
   - For `$jam_fallback_seal`, do we create an output with the VRF Bandersnatch as mentioned in the questions above? If yes, what arguments, context, and additional data are required?

2. **$jam_ticket_seal:**
   - For `$jam_ticket_seal`, do we use the VRF RingVRF? If yes, what arguments, context, and additional data are required?

3. **$jam_entropy:**
   - For `$jam_entropy`, related to on-chain entropy generation, what does it mean, and how do we compute it?

### Equation (59):

1. **Understanding Components:**
   - What are \( i_y \), \( i_r \), \( H_a \), \( H \), and \( E_U(H) \)?

### Equation (60):

1. **Defining \( H_a \):**
   - Do we define \( H_a \) with the \( i \) from the equation &quot;let \( i = \gamma_s&#x27;[H_t]^{\circlearrow}&quot;?

2. **Understanding \( H \) and \( E_U(H) \):**
   - What is \( H \) and \( E_U(H) \)?


</div>
<div class='msg'><time>2024‑07‑13 19:20</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Let me know if I should move them to other channel or if you need more precisions
Thank you in advance</div>
<div class='msg'><time>2024‑07‑13 19:22</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>:  * Hello everyone,

I have some questions, I don&#x27;t know if I should post them here or on the Jam Chat channel but 🤷‍♂️ here we go :

### Appendix G:

1. **Signature Set and Key Generation:**
    - To confirm, is ( F\_{m,k} ) the set of signatures using the IETF VRF (as per Goldberg 2023) where keys are generated from the Bandersnatch curve?
2. **Size of Y:**
    - Why is ( Y ) of size 96 bytes? We perform `decode(x:32)` and `decode(x32:)`. Does this mean that the first 32 bytes are the public key and the rest is additional data?
3. **Merkle Root and Public Keys:**
    - To confirm, is ( O(\[H\_B\]) ) the Merkle root of the Merkle tree where the leaves are the authors&#x27; public keys?
4. **Use of RingVRF:**
    - To confirm, do we use the ring VRF from the Jeffrey 2023 paper, with the first ring VRF construction (part 4 of the paper) and with \( \text{Com}^*.\text{Commit}(\text{ring}) = O([H_B]) \)**Size of Y (second instance):**
    - Why is ( Y ) of size 784 bytes? We perform `decode(x:32)` and `decode(x32:)` again. Does this mean that the first 32 bytes are the public key and the rest is additional data?</div>
<div class='msg'><time>2024‑07‑13 19:23</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>:  * Hello everyone,

I have some questions, I don&#x27;t know if I should post them here or on the Jam Chat channel but 🤷‍♂️ here we go :

### Appendix G:

1. **Signature Set and Key Generation:**
    - To confirm, is ( F\_{m,k} ) the set of signatures using the IETF VRF (as per Goldberg 2023) where keys are generated from the Bandersnatch curve?
2. **Size of Y:**
    - Why is ( Y ) of size 96 bytes? We perform `decode(x:32)` and `decode(x32:)`. Does this mean that the first 32 bytes are the public key and the rest is additional data?
3. **Merkle Root and Public Keys:**
    - To confirm, is ( O(\[H\_B\]) ) the Merkle root of the Merkle tree where the leaves are the authors&#x27; public keys?
4. **Use of RingVRF:**
    - To confirm, do we use the ring VRF from the Jeffrey 2023 paper, with the first ring VRF construction (part 4 of the paper) and with \( \text{Com}^*.\text{Commit}(\text{ring}) = O([H_B]) \)
5. **Size of Y (second instance):**
    - Why is ( Y ) of size 784 bytes? We perform `decode(x:32)` and `decode(x32:)` again. Does this mean that the first 32 bytes are the public key and the rest is additional data?</div>
<div class='msg'><time>2024‑07‑14 06:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@celadari:matrix.org&gt; Hello everyone,
&gt; 
&gt; I have some questions, I don&#x27;t know if I should post them here or on the Jam Chat channel but 🤷‍♂️ here we go :
&gt; 
&gt; ### Appendix G:
&gt; 
&gt; 1. **Signature Set and Key Generation:**
&gt;     - To confirm, is ( F\_{m,k} ) the set of signatures using the IETF VRF (as per Goldberg 2023) where keys are generated from the Bandersnatch curve?
&gt; 2. **Size of Y:**
&gt;     - Why is ( Y ) of size 96 bytes? We perform `decode(x:32)` and `decode(x32:)`. Does this mean that the first 32 bytes are the public key and the rest is additional data?
&gt; 3. **Merkle Root and Public Keys:**
&gt;     - To confirm, is ( O(\[H\_B\]) ) the Merkle root of the Merkle tree where the leaves are the authors&#x27; public keys?
&gt; 4. **Use of RingVRF:**
&gt;     - To confirm, do we use the ring VRF from the Jeffrey 2023 paper, with the first ring VRF construction (part 4 of the paper) and with \( \text{Com}^*.\text{Commit}(\text{ring}) = O([H_B]) \)
&gt; 5. **Size of Y (second instance):**
&gt;     - Why is ( Y ) of size 784 bytes? We perform `decode(x:32)` and `decode(x32:)` again. Does this mean that the first 32 bytes are the public key and the rest is additional data?

Your interpretation of the use of the colon in subscripting is correct. </div>
<div class='msg'><time>2024‑07‑14 06:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The rest will need [@davxy:matrix.org](https://matrix.to/#/@davxy:matrix.org)to chime in. </div>
<div class='msg'><time>2024‑07‑14 06:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@celadari:matrix.org&gt; ### Appendix I.4.5:
&gt; 
&gt; 1. **$jam_fallback_seal:**
&gt;    - For `$jam_fallback_seal`, do we create an output with the VRF Bandersnatch as mentioned in the questions above? If yes, what arguments, context, and additional data are required?
&gt; 
&gt; 2. **$jam_ticket_seal:**
&gt;    - For `$jam_ticket_seal`, do we use the VRF RingVRF? If yes, what arguments, context, and additional data are required?
&gt; 
&gt; 3. **$jam_entropy:**
&gt;    - For `$jam_entropy`, related to on-chain entropy generation, what does it mean, and how do we compute it?
&gt; 
&gt; ### Equation (59):
&gt; 
&gt; 1. **Understanding Components:**
&gt;    - What are \( i_y \), \( i_r \), \( H_a \), \( H \), and \( E_U(H) \)?
&gt; 
&gt; ### Equation (60):
&gt; 
&gt; 1. **Defining \( H_a \):**
&gt;    - Do we define \( H_a \) with the \( i \) from the equation &quot;let \( i = \gamma_s&#x27;[H_t]^{\circlearrow}&quot;?
&gt; 
&gt; 2. **Understanding \( H \) and \( E_U(H) \):**
&gt;    - What is \( H \) and \( E_U(H) \)?
&gt; 
&gt; 
&gt; 

Appendix I is the index. Maybe ask your questions in terms of the actual protocol specification?</div>
<div class='msg'><time>2024‑07‑14 07:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Re 59, you can find all the information in the text around it. E.g. i is determined from subscripting gamma’_s, a member of the sequence of tickets, telling you that it’s a ticket and thus that i_y is a VRF output, used as a ticket identifier (see (50) and text around it). </div>
<div class='msg'><time>2024‑07‑14 07:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Don’t expect to be spoon fed this stuff. It’s not playschool. You need to read carefully. </div>
<div class='msg'><time>2024‑07‑14 07:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: https://youtu.be/QS9buJLt5jo?si=5Sh8Qc-teI-dxVJ_ might be helpful to watch as well as others in the series. </div>
<div class='msg'><time>2024‑07‑14 07:05</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: &gt; &lt;@gav:polkadot.io&gt; Appendix I is the index. Maybe ask your questions in terms of the actual protocol specification?

I&#x27;m not sure to understand what you mean by &quot;Appendix I is the index&quot; 🤔

At least the term `$jam_entropy` =&gt; can you give pointer to this term please ?</div>
<div class='msg'><time>2024‑07‑14 07:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I’m not sure why you think it reasonable to ask for someone else to do a PDF text search for you like I’ve nothing better to be doing Sunday morning.. (62) X_E  = $jam_entropy</div>
<div class='msg'><time>2024‑07‑14 07:14</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: As i say do not expect to be spoon fed. Any more such questions may elicit little response. </div>
<div class='msg'><time>2024‑07‑14 07:14</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * I’m not sure why you think it reasonable to ask for someone else to do a PDF text search for you like they’ve nothing better to be doing Sunday morning.. (62) X_E  = $jam_entropy</div>
<div class='msg'><time>2024‑07‑14 07:15</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * I’m not sure why you think it reasonable to ask for someone else to do a PDF text search for you like they’ve nothing better to be doing Sunday morning.. anyway (62) X_E  = $jam_entropy</div>
<div class='msg'><time>2024‑07‑15 10:50</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-07-15 at 10.50.10 PM.png</div>
<div class='msg'><time>2024‑07‑15 10:50</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: just to confirm, a validator key can be selected multiple times right</div>
<div class='msg'><time>2024‑07‑15 11:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: That is indeed an implication of that formula</div>
<div class='msg'><time>2024‑07‑15 11:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * That is indeed an implication of the formula</div>
<div class='msg'><time>2024‑07‑15 11:59</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: @room v0.3.0 is out; mostly corrections but with some reworking of the Guarantees and Verdicts (né Judgements) extrinsic. https://github.com/gavofyork/graypaper/releases/tag/v0.3.0</div>
<div class='msg'><time>2024‑07‑15 12:08</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: &gt; &lt;@gav:polkadot.io&gt; @room v0.3.0 is out; mostly corrections but with some reworking of the Guarantees and Verdicts (né Judgements) extrinsic. https://github.com/gavofyork/graypaper/releases/tag/v0.3.0

I think only the version on the file header was updated, not the version on the first page: https://github.com/gavofyork/graypaper/pull/40/files</div>
<div class='msg'><time>2024‑07‑15 12:08</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: Screenshot 2024-07-15 at 14.08.23.png</div>
<div class='msg'><time>2024‑07‑15 12:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@oliver.tale-yazdi:parity.io&gt; I think only the version on the file header was updated, not the version on the first page: https://github.com/gavofyork/graypaper/pull/40/files

Should be good now</div>
<div class='msg'><time>2024‑07‑15 13:40</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: Reading integer encoding in appendix C, I&#x27;m unable to understand how x=0 is handled by the general natural serialization rules 272; if x is 0, I can&#x27;t apply the first `if` since 2**0 == 1 (so it does not exist a valid `l`), but applying the second if doesn&#x27;t seems correct either.
Am I missing something, or the case where x=0 is not present?</div>
<div class='msg'><time>2024‑07‑15 13:47</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>:  * Reading integer encoding in appendix C, I&#x27;m unable to understand how x=0 is handled by the general natural serialization rule 272; if x is 0, I can&#x27;t apply the first `if` since 2\*\*0 == 1 (so it does not exist a valid `l`), but applying the second `if` doesn&#x27;t seems correct either.
Am I missing something, or the case where x=0 is not present?</div>
<div class='msg'><time>2024‑07‑15 13:47</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>:  * Reading integer encoding in appendix C, I&#x27;m unable to understand how x=0 is handled by the general natural serialization rule 272; if x is 0, I can&#x27;t apply the first `if` since `(2\*\*0 == 1) &gt; 0` (so it does not exist a valid `l`), but applying the second `if` doesn&#x27;t seems correct either.
Am I missing something, or the case where x=0 is not present?</div>
<div class='msg'><time>2024‑07‑15 13:48</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>:  * Reading integer encoding in appendix C, I&#x27;m unable to understand how x=0 is handled by the general natural serialization rule 272; if x is 0, I can&#x27;t apply the first `if` since `(2**0 == 1) &gt; 0` (so it does not exist a valid `l`), but applying the second `if` doesn&#x27;t seems correct either.
Am I missing something, or the case where x=0 is not present?</div>
<div class='msg'><time>2024‑07‑15 13:59</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: image.png</div>
<div class='msg'><time>2024‑07‑15 13:59</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: You mean this function right ?</div>
<div class='msg'><time>2024‑07‑15 14:00</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: I think $l$ is supposed to be fixed here no ?</div>
<div class='msg'><time>2024‑07‑15 14:00</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: image.png</div>
<div class='msg'><time>2024‑07‑15 14:01</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>:  * Reading integer encoding in appendix C, I&#x27;m unable to understand how x=0 is handled by the general natural serialization rule 274; if x is 0, I can&#x27;t apply the first `if` since `(2**0 == 1) &gt; 0` (so it does not exist a valid `l`), but applying the second `if` doesn&#x27;t seems correct either.
Am I missing something, or the case where x=0 is not present?</div>
<div class='msg'><time>2024‑07‑15 14:01</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: &gt; &lt;@dakkk:matrix.org&gt; sent an image.

then in this case, 0 &lt; 2**64 no ?</div>
<div class='msg'><time>2024‑07‑15 14:04</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: yes, but following this path, 0 is encoded as \xff\x00\x00\x00\x00\x00\x00\x00\x00; it doesn&#x27;t seem right to me </div>
<div class='msg'><time>2024‑07‑15 14:08</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: I think you might be right, let me just check something</div>
<div class='msg'><time>2024‑07‑15 14:10</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: what happens when you generate several elements from 1 to 2**7</div>
<div class='msg'><time>2024‑07‑15 14:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dakkk:matrix.org&gt; yes, but following this path, 0 is encoded as \xff\x00\x00\x00\x00\x00\x00\x00\x00; it doesn&#x27;t seem right to me

yeah, zero is a special case and should be in the first branch</div>
<div class='msg'><time>2024‑07‑15 14:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: i&#x27;ll correct now.</div>
<div class='msg'><time>2024‑07‑15 14:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: image.png</div>
<div class='msg'><time>2024‑07‑15 14:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: https://github.com/gavofyork/graypaper/pull/45</div>
<div class='msg'><time>2024‑07‑15 21:00</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: In-depth question about erasure coding:

https://github.com/w3f/jamtestvectors/pull/4#issuecomment-2229422696

where we see a discrepancy between GP Appendix H and the test vector PR.  </div>
<div class='msg'><time>2024‑07‑16 07:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; In-depth question about erasure coding:
&gt; 
&gt; https://github.com/w3f/jamtestvectors/pull/4#issuecomment-2229422696
&gt; 
&gt; where we see a discrepancy between GP Appendix H and the test vector PR.  

648 bytes should be 684 bytes</div>
<div class='msg reply'><time>2024‑07‑16 18:07</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Right sorry -- 684 is still not a multiple of 64 or power of 2.</div>
<div class='msg reply'><time>2024‑07‑17 13:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: No it’s 342 x 2 bytes. 
It’s therefore the minimum reconstructible datum. </div>
<div class='msg reply'><time>2024‑07‑18 03:38</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Right, we understand that what the GP says but thats not cheme&#x27;s PR test vectors are doing.  We have our encoder + decoder FFI using his backend (and &quot;passing&quot;), but it is clearly on a different page than the GP.  </div>
<div class='msg reply'><time>2024‑07‑18 07:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Right, we understand that is what the GP says but that&#x27;s not what cheme&#x27;s PR test vectors are doing.  We have our encoder + decoder FFI using the Rust libraries (and &quot;passing&quot; for arbitrary blob sizes), but the process by which cheme&#x27;s erasure coding test vectors are generated are clearly on a different page than the GP&#x27;s Appendix H.  

Ok. Is it possible that “Parity implementation (serialized)” is just 6 of the graypaper ECs concatenated?</div>
<div class='msg'><time>2024‑07‑16 07:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; In-depth question about erasure coding:
&gt; 
&gt; https://github.com/w3f/jamtestvectors/pull/4#issuecomment-2229422696
&gt; 
&gt; where we see a discrepancy between GP Appendix H and the test vector PR.  

* Typo: 648 bytes should be 684 bytes</div>
<div class='msg'><time>2024‑07‑16 07:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: [@emeric:parity.io](https://matrix.to/#/@emeric:parity.io)^^</div>
<div class='msg'><time>2024‑07‑16 09:21</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-07-16 at 9.21.10 PM.png</div>
<div class='msg'><time>2024‑07‑16 09:22</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I don&#x27;t get this. what does it mean by &quot;the lowest items of the sorted union &quot;?</div>
<div class='msg'><time>2024‑07‑16 09:23</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: is the tickets accumulator a sorted array by the ticket id?</div>
<div class='msg'><time>2024‑07‑16 09:34</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: ok after read the sassafras RFC, I think I get it. Please confirm. This is basically a PoW-ish mining process and validators are trying to mine ticket with lowest VRF output and they have limited submission allowance and only EPOCH-LENGTH number of tickets will be accepted</div>
<div class='msg'><time>2024‑07‑16 09:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; ok after read the sassafras RFC, I think I get it. Please confirm. This is basically a PoW-ish mining process and validators are trying to mine ticket with lowest VRF output and they have limited submission allowance and only EPOCH-LENGTH number of tickets will be accepted

That&#x27;s about right.</div>
<div class='msg'><time>2024‑07‑16 09:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &quot;union&quot; =&gt; combining two sets. &quot;sorted&quot; =&gt; sorting that. &quot;lowest items&quot; =&gt; take only the first N items.</div>
<div class='msg'><time>2024‑07‑16 09:38</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I see. So the ticket extrinsic shouldn&#x27;t contain invalid ticket (with high VRF output) otherwise the block become invalid?</div>
<div class='msg'><time>2024‑07‑16 09:38</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>:  * I see. So the ticket extrinsic shouldn&#x27;t contain invalid ticket (when pool is full and high VRF output) otherwise the block become invalid?</div>
<div class='msg'><time>2024‑07‑16 09:40</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: &gt; &lt;@xlchen:matrix.org&gt; I see. So the ticket extrinsic shouldn&#x27;t contain invalid ticket (when pool is full and high VRF output) otherwise the block become invalid?

or incorrectly sorted. The conformance tests cover these cases</div>
<div class='msg'><time>2024‑07‑16 09:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes, broadly speaking we always put the onus on the block-producer to make blocks which don&#x27;t waste the block importer&#x27;s time.</div>
<div class='msg'><time>2024‑07‑16 12:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Some important fixes in main now especially for disputes/judgements/verdicts; if you&#x27;re working on that, best to use `main`.</div>
<div class='msg'><time>2024‑07‑16 12:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Some fixes just went in especially for disputes/judgements/verdicts; if you&#x27;re working on that, best to use `main`.</div>
<div class='msg'><time>2024‑07‑16 19:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: </div>
<div class='msg'><time>2024‑07‑16 19:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: </div>
<div class='msg'><time>2024‑07‑17 09:19</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-07-17 at 9.19.35 PM.png</div>
<div class='msg'><time>2024‑07‑17 09:19</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: for serialization of numbers, what is the default serialization method?</div>
<div class='msg'><time>2024‑07‑17 09:20</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-07-17 at 9.19.59 PM.png</div>
<div class='msg'><time>2024‑07‑17 09:20</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I guess when unspecified, it is the general natural number serialization method which is a variable length one?</div>
<div class='msg'><time>2024‑07‑17 09:21</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: also I can&#x27;t find where (273) is used?</div>
<div class='msg'><time>2024‑07‑17 11:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It was used in an older version of the PVM. It might be used again in the future, but right now it&#x27;s superfluous.</div>
<div class='msg'><time>2024‑07‑17 14:33</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: equation (59) is for the normal lottery case (header &quot;anonymously&quot; signed with ringVRF) right ? 
so shouldn&#x27;t it be 
$$\mathbf{H}_s \in \bar{\mathbb{F}}_{\gamma_z}^{[]}\langle{X_T\frown \eta_3^{&#x27;} ++ i_r }\rangle$$ ?</div>
<div class='msg'><time>2024‑07‑17 14:35</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>:  * equation (59) is for the normal lottery case (header &quot;anonymously&quot; signed with ringVRF) right ?
so shouldn&#x27;t it be
$$\\mathbf{H}_s \\in \\bar{\\mathbb{F}}_{\\gamma\_z}^{\[\]}\\langle{X\_T\\frown \\eta\_3^{&#x27;} ++ i\_r }\\rangle$$ ?</div>
<div class='msg'><time>2024‑07‑17 15:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: No - neither case is anonymous.  </div>
<div class='msg'><time>2024‑07‑17 15:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * No - neither case is anonymous at the point of seal verification. It’s only anonymous at the point of ticket submission. </div>
<div class='msg'><time>2024‑07‑17 15:18</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Oh I see</div>
<div class='msg'><time>2024‑07‑17 16:11</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>: Probably just a minor detail, two lines after (214): The PVM exit reason `r`. Shouldn&#x27;t this be $\varepsilon$?</div>
<div class='msg'><time>2024‑07‑17 17:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@subotic:matrix.org&gt; Probably just a minor detail, two lines after (214): The PVM exit reason `r`. Shouldn&#x27;t this be $\varepsilon$?

yes - typo. will be fixed in the next release. thanks</div>
<div class='msg'><time>2024‑07‑17 20:06</time>&ensp;<span class='u' style='color:#74d8d2'>proxy720</span>: Hi @gav, I&#x27;m looking at the latest version of the paper (DRAFT 0.3.0). I think there is a typo in a couple of equations in appendix C (the scale encoder):
- (273): first case: ... ^ E_l(x mod 2*8l), should it be E_{l-1} ?
- (273): second case: ... ^ E_3, I think it wants to be E_2
- (274): the same, I think the indices should be decreasing
But maybe I&#x27;m wrong...</div>
<div class='msg'><time>2024‑07‑17 20:14</time>&ensp;<span class='u' style='color:#74d8d2'>proxy720</span>: &gt; &lt;@proxy720:matrix.org&gt; Hi @gav, I&#x27;m looking at the latest version of the paper (DRAFT 0.3.0). I think there is a typo in a couple of equations in appendix C (the scale encoder):
&gt; - (273): first case: ... ^ E_l(x mod 2*8l), should it be E_{l-1} ?
&gt; - (273): second case: ... ^ E_3, I think it wants to be E_2
&gt; - (274): the same, I think the indices should be decreasing
&gt; But maybe I&#x27;m wrong...

Yes, I am wrong the expressions are not recursive but refer to (272). Sorry, my bad.</div>
<div class='msg'><time>2024‑07‑17 23:27</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: A small annoyance, all the formula are numbered which is obviously very useful for many reasons. However, the number are not fixed and subject to change between versions. This makes referring to a particular formula from code a bit harder as it also needs to fixed to a specific GP version as well and then eventually the repo will contain references to multiple GP versions and just makes things harder. I don&#x27;t know if there is a solution to this but it will be great if we have a good way to reference to GP from code comment / docs / chats</div>
<div class='msg'><time>2024‑07‑18 03:39</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Right, we understand that what the GP says but thats not  what cheme&#x27;s PR test vectors are doing.  We have our encoder + decoder FFI using his backend (and &quot;passing&quot;), but the erasure coding test vectors are clearly on a different page than the GP Appendix H.   </div>
<div class='msg'><time>2024‑07‑18 03:40</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Right, we understand that what the GP says but thats not  what cheme&#x27;s PR test vectors are doing.  We have our encoder + decoder FFI using the Rust backend (and &quot;passing&quot; for arbitrary blob sizes), but the process by which the erasure coding test vectors are generated are clearly on a different page than the GP Appendix H.</div>
<div class='msg'><time>2024‑07‑18 03:40</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Right, we understand that is what the GP says but that&#x27;s not what cheme&#x27;s PR test vectors are doing.  We have our encoder + decoder FFI using the Rust backend (and &quot;passing&quot; for arbitrary blob sizes), but the process by which the erasure coding test vectors are generated are clearly on a different page than the GP Appendix H.</div>
<div class='msg'><time>2024‑07‑18 03:46</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Right, we understand that is what the GP says but that&#x27;s not what cheme&#x27;s PR test vectors are doing.  We have our encoder + decoder FFI using the Rust libraries (and &quot;passing&quot; for arbitrary blob sizes), but the process by which cheme&#x27;s erasure coding test vectors are generated are clearly on a different page than the GP&#x27;s Appendix H.  </div>
<div class='msg'><time>2024‑07‑18 07:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; A small annoyance, all the formula are numbered which is obviously very useful for many reasons. However, the number are not fixed and subject to change between versions. This makes referring to a particular formula from code a bit harder as it also needs to fixed to a specific GP version as well and then eventually the repo will contain references to multiple GP versions and just makes things harder. I don&#x27;t know if there is a solution to this but it will be great if we have a good way to reference to GP from code comment / docs / chats

Once there is a 1.0 then this should be better. Until then if you want a fixed reference you could use the latex label, where there is one (and if there isn’t, then let me know or make a pr)</div>
<div class='msg'><time>2024‑07‑18 08:31</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Cheme&#x27;s process is as follows:

Encoding:
* blob is split into 4096-byte segments
* each 4096-byte segment is erasure coded into 12-byte shards shared among 1026 (342 x 3) validators, ie 12312 bytes

Decoding:
* available 12-byte chunks in a 12312 byte encoding (only 342 of which are needed for reconstruction) are used to reconstruct the 4096-byte segment
* each of the 4096-byte segments are put together to reconstruct the blob

GP wants 4104-byte segments (W_C = 684, W_S = 6) instead of 4096.  </div>
<div class='msg'><time>2024‑07‑18 08:40</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Cheme&#x27;s erasure coding process (now ours, via FFI into the same Rust libs) is as follows:

Encoding:

- blob is split into 4096-byte segments
- each 4096-byte segment is erasure coded into 12-byte shards shared among 1026 (342 x 3) validators, ie 12312 bytes

Decoding:

- available 12-byte chunks in a 12312 byte encoding (only 342 of which are needed for reconstruction) are used to reconstruct the 4096-byte segment
- each of the 4096-byte segments are put together to reconstruct the blob

GP wants 4104-byte segments (W\_C = 684, W\_S = 6) instead of 4096.</div>
<div class='msg'><time>2024‑07‑18 08:41</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Cheme&#x27;s erasure coding process (now ours, via FFI into the same Rust libs) is as follows:

Encoding:

- blob is split into 4096-byte segments
- each 4096-byte segment is erasure coded into 12-byte shards shared among 1026 (342 x 3) validators, ie 12312 bytes

Decoding:

- available 12-byte chunks in a 12312 byte encoding (only 342 of which are needed for reconstruction) are used to reconstruct the 4096-byte segment
- each of the 4096-byte segments are put together to reconstruct the blob

GP wants 4104-byte segments (W\_C = 684, W\_S = 6) instead of 4096.   This is a real discrepancy.  </div>
<div class='msg'><time>2024‑07‑18 08:43</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Cheme&#x27;s erasure coding process (now ours, via FFI into the same Rust libs) is as follows:

Encoding:

- blob is split into 4096-byte segments
- each 4096-byte segment is erasure coded into 12-byte subshards shared among 1026 (342 x 3) validators, ie 12,312 bytes

Decoding:

- available 12-byte subshards in a 12,312 byte encoding (only 342 of which are needed for reconstruction) are used to reconstruct the 4096-byte segment
- each of the 4096-byte segments are put together to reconstruct the blob

GP wants 4104-byte segments (W\_C = 684 x W\_S = 6) instead of 4096.   This is a real discrepancy.</div>
<div class='msg'><time>2024‑07‑18 09:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Ok - yeah cheme&#x27;s current system is incorrect and the test vectors shouldn&#x27;t have been generated.</div>
<div class='msg'><time>2024‑07‑18 09:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: If you&#x27;re confident you have the GP properly implemented, feel free to create your own test vectors and submit them as a PR.</div>
<div class='msg'><time>2024‑07‑18 09:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The lowest reconstructible datum of EC should be 684 bytes, reconstructible from 342 parties out of a total generated during EC of 1026, each presenting 2 bytes.</div>
<div class='msg'><time>2024‑07‑18 09:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: So 342 byte-pairs gets expanded to 1026 byte-pairs and from this any 342 byte-pairs can be used to reconstruct the original 342 byte-pairs.

For ECing segments (4104 bytes, 2052 byte-pairs), then we basically do the ECing above 6 times in parallel and concatenate.</div>
<div class='msg'><time>2024‑07‑18 09:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: For ECing the Work-Bundle, then we do the above N times in parallel and concatenate where N is `CEIL(WORK_BUNDLE_SIZE / 684)`</div>
<div class='msg'><time>2024‑07‑18 09:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * For ECing the Work-Bundle, then we do the above N times in parallel and concatenate, where N is `CEIL(WORK_BUNDLE_SIZE / 684)`</div>
<div class='msg'><time>2024‑07‑18 09:17</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Understood!  But I think we&#x27;re up against the fact that Lin, Chung, and Han 2014 referenced in GP only works with powers of 2, and need to get down into like &quot;what package can do _that_&quot; nitty gritty. </div>
<div class='msg'><time>2024‑07‑18 09:30</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: This paper (who Han pointed one of our team to) appears to get over the &quot;powers of 2 limitation&quot; and get what the GP wants:
 https://ieeexplore.ieee.org/document/8955804
but I don&#x27;t believe its reasonable for teams to be implementing it independently.   IMHO every team should have an FFI into a very widely used erasure coding package, or (similar to davxy Bandersnatch repo, I imagine) we all just use the same one.</div>
<div class='msg'><time>2024‑07‑18 09:31</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * This paper (who Han pointed one of our team to) appears to get over the &quot;powers of 2&quot; limitations and gets to what the GP wants:
 https://ieeexplore.ieee.org/document/8955804
but I don&#x27;t believe its reasonable for teams to be implementing it independently.   IMHO every team should have an FFI into a very widely used erasure coding package, or (similar to davxy Bandersnatch repo, I imagine) we all just use the same one, implemented once, well?</div>
<div class='msg'><time>2024‑07‑18 09:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; This paper (who Han pointed one of our team to) appears to get over the &quot;powers of 2&quot; limitations and gets to what the GP wants:
&gt;  https://ieeexplore.ieee.org/document/8955804
&gt; but I don&#x27;t believe its reasonable for teams to be implementing it independently.   IMHO every team should have an FFI into a very widely used erasure coding package, or (similar to davxy Bandersnatch repo, I imagine) we all just use the same one, implemented once, well?

Agreed, implementation of the underlying RS EC is not something which is needed for the prize. I&#x27;d very very happy to see an high quality treasury-funded implementation for use across client implementations.</div>
<div class='msg'><time>2024‑07‑18 09:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Agreed, implementation of the underlying RS EC is not something which is needed for the prize. I&#x27;d be very happy to see an high quality treasury-funded implementation for use across client implementations.</div>
<div class='msg'><time>2024‑07‑18 10:43</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Before we go down that (not as resilient?!) rabbit-hole, here are two solutions:
* **Solution A: Change 342:1026 to powers of 2 (e.g., 256:1024).**  Instead of using the leapord package 
https://github.com/catid/leopard/tree/master
we use the original author package
https://github.com/SianJhengLin/Fast-algorithms-of-Reed-Solomon-erasure-codes

* *Solution B: Change Y_2 in the paper**
This could be Y_64, or Y_192 as implemented by Parity here:
https://github.com/paritytech/erasure-coding/blob/6c22e28a7402cfc75381e430483defe8189df486/src/subshard.rs#L317
or any multiple of 64 as per the docs:
https://github.com/catid/leopard/blob/6e5725ebdf9da4370b0bcc4f70fa8eb66f4e6198/README.md?plain=1#L27
where n and k represent &quot;original data length&quot; and &quot;recovery data length&quot;.

Neither solution requires building new packages (good!) but both require some parameter changes to the GP.  </div>
<div class='msg'><time>2024‑07‑18 10:44</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Before we go down that (not as resilient?!) rabbit-hole, here are two solutions:

- **Solution A: Change 342:1026 to powers of 2 (e.g., 256:1024).**  Instead of using the leapord package
https://github.com/catid/leopard/tree/master
we use the original author package
https://github.com/SianJhengLin/Fast-algorithms-of-Reed-Solomon-erasure-codes
- **Solution B: Change Y\_2 in the paper_\**
This could be Y\_64, or Y\_192 as implemented by Parity here:
https://github.com/paritytech/erasure-coding/blob/6c22e28a7402cfc75381e430483defe8189df486/src/subshard.rs#L317
or any multiple of 64 as per the docs:
https://github.com/catid/leopard/blob/6e5725ebdf9da4370b0bcc4f70fa8eb66f4e6198/README.md?plain=1#L27
where n and k represent &quot;original data length&quot; and &quot;recovery data length&quot;.

Neither solution requires building new packages (good!) but both require some parameter changes to the GP.</div>
<div class='msg'><time>2024‑07‑18 10:44</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Before we go down that (not as resilient?!) rabbit-hole, here are two solutions:

- **Solution A: Change 342:1026 to powers of 2 (e.g., 256:1024).**  Instead of using the leapord package
https://github.com/catid/leopard/tree/master
we use the original author package
https://github.com/SianJhengLin/Fast-algorithms-of-Reed-Solomon-erasure-codes
- **Solution B: Change Y\_2 in GP**
This could be Y\_64, or Y\_192 as implemented by Parity here:
https://github.com/paritytech/erasure-coding/blob/6c22e28a7402cfc75381e430483defe8189df486/src/subshard.rs#L317
or any multiple of 64 as per the docs:
https://github.com/catid/leopard/blob/6e5725ebdf9da4370b0bcc4f70fa8eb66f4e6198/README.md?plain=1#L27
where n and k represent &quot;original data length&quot; and &quot;recovery data length&quot;.

Neither solution requires building new packages (good!) but both require some parameter changes to the GP.</div>
<div class='msg'><time>2024‑07‑18 10:46</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Before we go down that (not as resilient?!) rabbit-hole, here are two solutions:

- **Solution A: Change 342:1026 to powers of 2 (e.g., 256:1024).**  Instead of using the leopard package
https://github.com/catid/leopard/tree/master
we use the original author&#x27;s package:
https://github.com/SianJhengLin/Fast-algorithms-of-Reed-Solomon-erasure-codes
- **Solution B: Change Y\_2 in GP**
This could be Y\_64, or Y\_192 as implemented by Parity here:
https://github.com/paritytech/erasure-coding/blob/6c22e28a7402cfc75381e430483defe8189df486/src/subshard.rs#L317
or any multiple of 64 as per the docs:
https://github.com/catid/leopard/blob/6e5725ebdf9da4370b0bcc4f70fa8eb66f4e6198/README.md?plain=1#L27
where n and k represent &quot;original data length&quot; and &quot;recovery data length&quot;.

Neither solution requires building new packages (good!) but both require some parameter changes to the GP.</div>
<div class='msg'><time>2024‑07‑18 10:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: https://gist.github.com/gavofyork/4cde92327cd91eff3e2ab91d316cb83a</div>
<div class='msg'><time>2024‑07‑18 10:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: here&#x27;s a test vector for the &quot;atomic&quot; EC.</div>
<div class='msg'><time>2024‑07‑18 10:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 684 bytes split out into 1026 * 2 bytes, and 342 of which can be used to reconstruct.</div>
<div class='msg'><time>2024‑07‑18 10:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: once you&#x27;ve got this to match, the rest should be straightforward.</div>
<div class='msg'><time>2024‑07‑18 10:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Before we go down that (not as resilient?!) rabbit-hole, here are two solutions:
&gt; 
&gt; - **Solution A: Change 342:1026 to powers of 2 (e.g., 256:1024).**  Instead of using the leopard package
&gt; https://github.com/catid/leopard/tree/master
&gt; we use the original author&#x27;s package:
&gt; https://github.com/SianJhengLin/Fast-algorithms-of-Reed-Solomon-erasure-codes
&gt; - **Solution B: Change Y\_2 in GP**
&gt; This could be Y\_64, or Y\_192 as implemented by Parity here:
&gt; https://github.com/paritytech/erasure-coding/blob/6c22e28a7402cfc75381e430483defe8189df486/src/subshard.rs#L317
&gt; or any multiple of 64 as per the docs:
&gt; https://github.com/catid/leopard/blob/6e5725ebdf9da4370b0bcc4f70fa8eb66f4e6198/README.md?plain=1#L27
&gt; where n and k represent &quot;original data length&quot; and &quot;recovery data length&quot;.
&gt; 
&gt; Neither solution requires building new packages (good!) but both require some parameter changes to the GP.

no.</div>
<div class='msg'><time>2024‑07‑18 10:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * no. please stick to the spec. thanks.</div>
<div class='msg'><time>2024‑07‑18 10:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 684 bytes split out into 1026 \* 2 bytes, any 342 of which can be used to reconstruct.</div>
<div class='msg'><time>2024‑07‑18 11:36</time>&ensp;<span class='u' style='color:#c74b98'>alistair</span>: &gt; &lt;@gav:polkadot.io&gt; 684 bytes split out into 1026 \* 2 bytes, any 342 of which can be used to reconstruct.

Why? When this should be 1024*2</div>
<div class='msg'><time>2024‑07‑18 11:36</time>&ensp;<span class='u' style='color:#c74b98'>alistair</span>: </div>
<div class='msg'><time>2024‑07‑18 11:55</time>&ensp;<span class='u' style='color:#c74b98'>alistair</span>: * This could be 1024*2.</div>
<div class='msg'><time>2024‑07‑18 11:59</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: &gt; &lt;@gav:polkadot.io&gt; once you&#x27;ve got this to match, the rest should be straightforward.

yep i can recover it from a random 342 subset of these</div>
<div class='msg'><time>2024‑07‑18 12:02</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: image.png</div>
<div class='msg'><time>2024‑07‑18 12:02</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: I&#x27;ll briefly explain the method from the paper mentioned in GP Appendix H, using 256:1024 as an example:
Use the original 256 GF points as the values of the evaluation points, and then reverse-generate a polynomial expression, which is defined by the authors.
Therefore, substituting the 0th to 255th elements into this polynomial will give us the original data we need.
Next, substitute the 256th to 1023th elements sequentially into the polynomial to obtain the redundancy data we need.
And this method for quickly computing the values of the evaluation points is a recursive formula. inverse tranform is a recursive formula too



</div>
<div class='msg'><time>2024‑07‑18 12:03</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>:  * I&#x27;ll briefly explain the method from the paper mentioned in GP Appendix H, using 256:1024 as an example:
1. Use the original 256 GF points as the values of the evaluation points, and then reverse-generate a polynomial expression, which is defined by the authors.
2. Therefore, substituting the 0th to 255th elements into this polynomial will give us the original data we need.
3. Next, substitute the 256th to 1023th elements sequentially into the polynomial to obtain the redundancy data we need.
And this method for quickly computing the values of the evaluation points is a recursive formula. inverse tranform is a recursive formula too



</div>
<div class='msg'><time>2024‑07‑18 12:04</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: 
Could you explain more clearly how you generated this vector? No matter how I look at it, it doesn&#x27;t seem like it can be used for 342:1026.</div>
<div class='msg'><time>2024‑07‑18 12:10</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: The provided test vector contains original data with 1026 bytes, which is 513 octet pairs (Y_2). According to GP, every 342 octet pairs will be packed into 1 &quot;segment&quot; for encoding. Therefore, in this case, we should get 2 &quot;segments&quot; of codewords, totaling 1026 * 2 = 2052 octet pairs.

However, this provided test vector only contains 1 segment (1026 octet pairs) of codewords.

Please let me know if I got anything wrong.</div>
<div class='msg'><time>2024‑07‑18 12:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Which test vector?</div>
<div class='msg'><time>2024‑07‑18 12:25</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: This one

https://gist.github.com/gavofyork/4cde92327cd91eff3e2ab91d316cb83a</div>
<div class='msg'><time>2024‑07‑18 12:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The one I provided in the gist `9c07...a574` is 1368 nibbles, which is 684 bytes.</div>
<div class='msg'><time>2024‑07‑18 12:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: This gets ECed into 1026 byte-pairs</div>
<div class='msg'><time>2024‑07‑18 12:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * The one I provided in the gist `9c07...a574` is 1368 nibbles, which is 684 bytes (342 byte-pairs).</div>
<div class='msg'><time>2024‑07‑18 12:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * This gets ECed into 1026 byte-pairs.</div>
<div class='msg'><time>2024‑07‑18 12:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * This gets ECed into 1026 byte-pairs (`segment_ec`).</div>
<div class='msg'><time>2024‑07‑18 12:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * The `data` I provided in the gist `9c07...a574` is 1368 nibbles, which is 684 bytes (342 byte-pairs).</div>
<div class='msg'><time>2024‑07‑18 12:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * This gets ECed into 1026 byte-pairs (`segment_ec`) - concatenating the first 342 result in the `data`.</div>
<div class='msg'><time>2024‑07‑18 12:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * This gets ECed into 1026 byte-pairs (`segment_ec`) - concatenating the first 342 result in the `data`. The other 684 byte-pairs are the additional redundancy.</div>
<div class='msg'><time>2024‑07‑18 12:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Once you can do this, then you just need to glue 6 of them together to do segment encoding (4104 = 684 * 6).</div>
<div class='msg'><time>2024‑07‑18 12:31</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: </div>
<div class='msg'><time>2024‑07‑18 12:39</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: Sorry for that. I originally thought it was base64 (because the other vectors are encoded using base64), but this doesn&#x27;t answer my question. The paper has strict limitation of (n,k)should be 2^r, so how did you apply them to generate this vector?

</div>
<div class='msg'><time>2024‑07‑18 12:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yeah, that paper probably shouldn&#x27;t be referenced.</div>
<div class='msg'><time>2024‑07‑18 12:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I&#x27;ll remove the reference in the next revision.</div>
<div class='msg'><time>2024‑07‑18 12:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: For now just assume it&#x27;s a normal systematic RS EC in GF(2^16)</div>
<div class='msg'><time>2024‑07‑18 12:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: https://ieeexplore.ieee.org/document/8955804 might be an interesting paper when you come to optimisation, assuming there is no existing impl which can come via FFI.</div>
<div class='msg'><time>2024‑07‑18 12:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: We have found that the crate parity uses for EC can parallelise effectively if you&#x27;re careful about which shards are which.</div>
<div class='msg'><time>2024‑07‑18 12:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * We have found that the crate parity uses for EC can parallelise effectively if you&#x27;re careful about which shards are which and you ensure indices are equivalent for all shards.</div>
<div class='msg'><time>2024‑07‑18 12:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: We&#x27;ll probably improve this in the future to allow for 32x parallelism using 4 indices (8 shards per index), which should get very close to the theoretical maximum performance without necessitating a fresh implementation.</div>
<div class='msg'><time>2024‑07‑18 12:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: However, for M1/M2 none of this is especially relevant.</div>
<div class='msg'><time>2024‑07‑18 12:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * However, for M1/M2 performance is not especially relevant - you just need to be able to do the regular ECing.</div>
<div class='msg'><time>2024‑07‑18 12:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * However, for M1/M2 performance is not especially relevant - you just need to be able to get the right EC results.</div>
<div class='msg'><time>2024‑07‑18 12:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: As for hex/base64, yeah I switched it - I&#x27;m not sure why base64 was ever used as it makes it largely unreadable to human eyes.</div>
<div class='msg'><time>2024‑07‑18 12:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * As for hex/base64, yeah I switched it - I&#x27;m not sure why base64 was ever used as it makes it largely unreadable to human eyes. I&#x27;ll push people to stick to hex so it&#x27;s trivial to see things like string lengths right in a text editor.</div>
<div class='msg'><time>2024‑07‑18 12:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * As for hex/base64, yeah I switched it - I&#x27;m not sure why base64 was ever used as it makes it largely unreadable to human eyes. I&#x27;ll push people to stick to hex so it&#x27;s trivial to see things like string lengths right in a text editor and not worry about weird padding artefacts.</div>
<div class='msg'><time>2024‑07‑18 13:18</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: Got it, thanks for clarifying.

However, we still have some concerns: the term &quot;normal systematic RS EC&quot; is quite ambiguous. 
In our understanding, RS coding (Reed Solomon) are more likely a &quot;category&quot; of coding algorithm, there&#x27;re at least two type of RS coding: original view and BCH view. See: https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#:~:text=There%20are%20two%20basic%20types%20of%20Reed%E2%80%93Solomon%20codes%C2%A0%E2%80%93%20original%20view%20and%20BCH%20view%C2%A0%E2%80%93%20with%20BCH%20view%20being%20the%20most%20common%2C%20as%20BCH%20view%20decoders%20are%20faster%20and%20require%20less%20working%20storage%20than%20original%20view%20decoders.

Different algorithms (or even just different implementations) of RS coding could lead to different encoding results. Therefore, if RS coding doesn&#x27;t align among each JAM implementation, the encoding results might not be compatible with each other and may not decode correctly.</div>
<div class='msg'><time>2024‑07‑18 13:19</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: So in the future, it is possible that there will be changes in the encoding rate and data segmentation, right? When will this be confirmed, and what would you recommend we do for our implementation in the meantime?</div>
<div class='msg'><time>2024‑07‑18 13:29</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: Regarding the recovery of the test vector you provided earlier, Can you provide us with more relevant implementation details?
I want to make sure that our approach is correct.</div>
<div class='msg'><time>2024‑07‑18 14:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@shwchg:matrix.org&gt; So in the future, it is possible that there will be changes in the encoding rate and data segmentation, right? When will this be confirmed, and what would you recommend we do for our implementation in the meantime?

No changes are planned and I don&#x27;t view any changes as unlikely.</div>
<div class='msg'><time>2024‑07‑18 14:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@shwchg:matrix.org&gt; So in the future, it is possible that there will be changes in the encoding rate and data segmentation, right? When will this be confirmed, and what would you recommend we do for our implementation in the meantime?

 * No changes are planned and I don&#x27;t view any changes as likely.</div>
<div class='msg'><time>2024‑07‑18 14:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I believe this is the paper describing the underlying EC schema: D. G. Cantor, &quot;On arithmetical algorithms over finite fields&quot;,
    Journal of Combinatorial Theory, Series A, vol. 50, no. 2, pp. 285-300, 1989.</div>
<div class='msg'><time>2024‑07‑18 14:46</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: ok! Thank u!</div>
<div class='msg'><time>2024‑07‑18 14:48</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: image.png</div>
<div class='msg'><time>2024‑07‑18 14:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * I believe this is the paper describing the underlying EC schema: D. G. Cantor, &quot;On arithmetical algorithms over finite fields&quot;,
    Journal of Combinatorial Theory, Series A, vol. 50, no. 2, pp. 285-300, 1989.

Reed Solomon Finite-Field Erasure Codec, GF(2^16), Cantor basis 2

</div>
<div class='msg'><time>2024‑07‑18 14:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * I believe this is the paper describing the underlying EC schema: D. G. Cantor, &quot;On arithmetical algorithms over finite fields&quot;,
    Journal of Combinatorial Theory, Series A, vol. 50, no. 2, pp. 285-300, 1989.

Systematic Reed Solomon Finite-Field Erasure Codec, GF(2^16), Cantor basis 2

</div>
<div class='msg'><time>2024‑07‑18 14:56</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: hello when trying to implement the codec for the `dictionary encoding` &quot;method 1&quot;. or this formal definition, i find it hard to write a generic codec. let me explain better.

the notation seems to indicate that when encoding a single key,value pair then the following steps should be taken:

- encode number of keys/valuepairs ( formula 275 )
- then for each key value pair
- concatenate the encoded key
- concatenate the encoded corresponding value

if my understanding is true, then lets think about a dict with different keytypes and value types each with variable length. There is no explicit mechanism in the formal specification that would allow an implementation to properly encode &amp; decode the key value pairs.


I would&#x27;ve expected to also see some kind of `E(k*) = E(|k|) concatenated with E(k)` . same for ` </div>
<div class='msg'><time>2024‑07‑18 14:56</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * hello when trying to implement the codec for the `dictionary encoding` &quot;method 1&quot;. or this formal definition, i find it hard to write a generic codec. let me explain better.

the notation seems to indicate that when encoding a single key,value pair then the following steps should be taken:

- encode number of keys/valuepairs ( formula 275 )
- then for each key value pair
- concatenate the encoded key
- concatenate the encoded corresponding value

if my understanding is true, then lets think about a dict with different keytypes and value types each with variable length. There is no explicit mechanism in the formal specification that would allow an implementation to properly encode &amp; decode the key value pairs.

I would&#x27;ve expected to also see some kind of `E(k*) = E(|k|) concatenated with E(k)` . same for `d[k]`</div>
<div class='msg'><time>2024‑07‑18 14:58</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: unless i am misinterpreting the formula (which is a strong possibility here)</div>
<div class='msg'><time>2024‑07‑18 14:59</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * hello when trying to implement the codec for the `dictionary encoding` &quot;method 1&quot;. or this formal definition, i find it hard to write a generic codec. let me explain better.

the notation seems to indicate that when the dictionary then the following steps should be taken:

- encode number of keys/valuepairs ( formula 275 )
- then for each key value pair
- concatenate the encoded key
- concatenate the encoded corresponding value

if my understanding is true, then lets think about a dict with different keytypes and value types each with variable length. There is no explicit mechanism in the formal specification that would allow an implementation to properly encode &amp; decode the key value pairs.

I would&#x27;ve expected to also see some kind of `E(k*) = E(|k|) concatenated with E(k)` . same for `d[k]`</div>
<div class='msg'><time>2024‑07‑18 15:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: No dictionary with differing key/value types use this encode function.</div>
<div class='msg'><time>2024‑07‑18 15:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (In fact, AFAIR I don&#x27;t think it&#x27;s used at all, currently)</div>
<div class='msg'><time>2024‑07‑18 15:03</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@gav:polkadot.io&gt; No dictionary with differing key/value types use this encode function.

thanks. maybe it&#x27;s worth mentioning in the graypaper?</div>
<div class='msg'><time>2024‑07‑18 15:05</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: also for future reference `i think` it might be a good idea. In case jam ends up needing to use it. we might want to be sure that we only use it when that condition is satisfied</div>
<div class='msg'><time>2024‑07‑18 15:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I&#x27;ll just remove the definitions for now</div>
<div class='msg'><time>2024‑07‑18 15:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * I&#x27;ll just remove the definitions for now.</div>
<div class='msg'><time>2024‑07‑18 16:28</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Oliver Tale-Yazdi: Which package did you use to decode the https://gist.github.com/gavofyork/4cde92327cd91eff3e2ab91d316cb83a &quot;normal systematic RS EC in GF(2^16)&quot;?  Can you post your (I presume Rust) decoder in a similar gist?  

Happy to submit a PR with the same shape of test vectors as cheme&#x27;s PR after we succeed, have you review it, based on the above.</div>
<div class='msg'><time>2024‑07‑18 16:34</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Oliver Tale-Yazdi: Which package did you use to decode the https://gist.github.com/gavofyork/4cde92327cd91eff3e2ab91d316cb83a &quot;normal systematic RS EC in GF(2^16)&quot;?  Can you post your (I presume Rust) decoder in a similar gist?  A encode-decode combo?

Happy to submit a PR with the same shape of test vectors as cheme&#x27;s PR after we succeed, have you review it, based on the above.</div>
<div class='msg'><time>2024‑07‑18 16:36</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Oliver Tale-Yazdi: Which package did you use to decode the https://gist.github.com/gavofyork/4cde92327cd91eff3e2ab91d316cb83a &quot;normal systematic RS EC in GF(2^16)&quot;?  Can you post your (I presume Rust) decoder in a similar gist?  A encode-decode combo?
&gt; 
&gt; Happy to submit a PR with the same shape of test vectors as cheme&#x27;s PR after we succeed, have you review it, based on the above.

I just used the decoder from here https://github.com/paritytech/erasure-coding/blob/main/src/subshard.rs</div>
<div class='msg'><time>2024‑07‑18 17:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: this might be useful for anyone wanting to get their head around what keysets are used when: https://hackmd.io/@polkadot/jamkeysets</div>
<div class='msg'><time>2024‑07‑18 19:42</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Updated 
https://github.com/w3f/jamtestvectors/pull/4#issuecomment-2237386980
with a snippet of Rust code
https://gist.github.com/sourabhniyogi/f448e213134c814d652d2eccf086bf53 
covering the first test vector for JAM&#x27;s erasure decoding.  If this somehow breaks hygiene, please explain? </div>
<div class='msg'><time>2024‑07‑19 17:14</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: gav: Do you have wire format preferences for JAMSNP 
https://hackmd.io/@polkadot/jamsnp 
For speed, I&#x27;d like to suggest we start with JSON and end with scale or protobuf.  Not arguing for protobuf over scale here but even though  JSON is something engineers tend to snicker at, but it usually makes debugging easier, between individuals and especially between teams, at the expense of a bunch of (I suggest, temporary) serialization/deserialization.  Or perhaps JAMSNP can support more than 1 wire format. 

Are the details of JAMSNP appropriate to develop by implementers and then turned into a GP Appendix after being reduced to code completeness, or do you (+JAM protocol engineers) own this problem?  
If you don&#x27;t own this, should implementers put into a polkadot-fellows RFC and then GP compatible notation?  
</div>
<div class='msg'><time>2024‑07‑19 17:15</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * gav: Do you have wire format preferences for JAMSNP
https://hackmd.io/@polkadot/jamsnp
For speed, I&#x27;d like to suggest we start with JSON and end with scale or protobuf.  Not arguing for protobuf over scale here ... but even though  JSON is something engineers tend to snicker at,  it usually makes debugging life easier, between individuals and especially between teams, at the expense of a bunch of (I suggest, temporary) serialization/deserialization.  Or perhaps JAMSNP can support more than 1 wire format.

Are the details of JAMSNP appropriate to develop by implementers and then turned into a GP Appendix after being reduced to code completeness, or do you (+JAM protocol engineers) own this problem?

If you don&#x27;t own this, should implementers put into a polkadot-fellows RFC and then GP compatible notation?</div>
<div class='msg'><time>2024‑07‑19 17:46</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * gav: Do you have wire format preferences for JAMSNP
https://hackmd.io/@polkadot/jamsnp
For speed, I&#x27;d like to suggest we start with JSON and end with scale or protobuf.  Not arguing for protobuf over scale here ... but even though  JSON is something engineers tend to snicker at,  it usually makes debugging life easier, between individuals and especially between teams, at the expense of a bunch of (I suggest, temporary) serialization/deserialization.  Or perhaps JAMSNP can support more than 1 wire format.

Are the details of JAMSNP appropriate to develop by implementers and then turned into a GP Appendix after we get a couple &quot;serious&quot; implementations in to code complete form, or do you (+JAM protocol engineers) own this problem?

If you don&#x27;t own this, should implementers put into a polkadot-fellows RFC and then GP compatible notation?</div>
<div class='msg'><time>2024‑07‑19 17:47</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * gav: Do you have wire format preferences for JAMSNP
https://hackmd.io/@polkadot/jamsnp
For speed, I&#x27;d like to suggest we start with JSON and end with scale or protobuf.  Not arguing for protobuf over scale here ... but even though  JSON is something engineers tend to snicker at,  it usually makes debugging life easier, between individuals and especially between teams, at the expense of a bunch of (I suggest, temporary) serialization/deserialization.  Or perhaps JAMSNP can support more than 1 wire format.

Are the details of JAMSNP appropriate to develop by implementers and then turned into a GP Appendix after we get a couple &quot;serious&quot; implementations in to code complete form, or do you (+JAM protocol engineers) own this problem?

If you don&#x27;t own this, should implementers put something together into a polkadot-fellows RFC and then GP compatible notation?

</div>
<div class='msg'><time>2024‑07‑19 20:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: SCALE, to the degree it matters. Most items will have a standard binary representation anyway. </div>
<div class='msg'><time>2024‑07‑21 20:07</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Ok -- maybe C.2 should be expanded to cover all the SCALE encodings, not just for blocks but for JAMSNP stream objects?  Here are my notes

* CE: Ticket submission - `Ticket` is an _element_ of ${\bf E}_T$ (Section 6.7 Equation 73) -- serialization of elements of  $\mathbb{C}$ in C.2 (Equation 288)
* CE: Work Report publication - `Guaranteed Work Report` is an _element_ of ${\bf E}_G$ (Section 11.4 Equation 136) -- Serialization of $\mathbb{W}$ is C.2 (Equation 286)
* CE: Assurance publication - `Assurance` is an _element_ of ${\bf E}_A$ (Section 11.2 Equation 123) -- need serialization in C.2 and a set definition in I.1.1.
* CE: Judgement publication - `Dispute` is an _component_ of ${\bf E}_D$ (Section 10.2 Equation 97 in ) -- need serialization in C.2, though ${\bf B}$ covers ${\bf c}, {\bf v}, {\bf f}$ components.
* CE: Preimage publication - `Preimage` is an _element_ of ${\bf E}_P$ (Equation 153) -- need serialization in C.2 and set definition in I.2.
* CE: Block publication - `Block` is just Equation 13, serialization of ${\bf B}$ in C.2 (Equations 280-282).
* CE: Work Package Submission and Sharing - `Work Package` is (174), serialization of elements of $\mathbb{P}$ in C.2 (Equation 287). 
* CE: Audit-announcement - `Announcement` - see Equation 196.  Need serialization in C.2 and set definition in I.1.1.
* CE: AuditDA query `AuditDAQuery` &amp; response `AuditDAResponse` - need serialization in C.2 and a set definition in I.1.1.
* CE: ImportDA query `ImportDAQuery` &amp; response `ImportDAResponse` - need serialization in C.2 and maybe a set definition in I.1.1
* CE: Public ImportDA reconstruction `ImportDAReconstructionQuery` &amp; response `ImportDAReconstructionResponse` - need serialization in C.2 and maybe a set definition in I.1.1 

Beyond the aove encoding nitty gritty, it would be powerful to have JAMSNP, for each stream, have a short description of when the sender is expected to send and the expected behavior of the receiver when receiving each of the above.  You could leave it an exercise for JAM implementers, but why?

Pedantic question: Why is V=1023, C=341 and not V=1026, C=342 where the latter  matches Appendix H&#x27;s 1026? Do you have a recommendation on how implementers get started with a &quot;tiny&quot; C, V, W_C, W_S?

In addition, the start of section 14 is messed up.</div>
<div class='msg'><time>2024‑07‑21 20:50</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Ok -- maybe C.2 should be expanded to cover all the SCALE encodings, not just for blocks but for JAMSNP stream objects?  Here are my notes

- CE: Ticket submission - `Ticket` is an _element_ of ${\\bf E}\_T$ (Section 6.7 Equation 73) -- serialization of elements of  $\\mathbb{C}$ in C.2 (Equation 288)
- CE: Work Report publication - `Guaranteed Work Report` is an _element_ of ${\\bf E}\_G$ (Section 11.4 Equation 136) -- Serialization of $\\mathbb{W}$ is C.2 (Equation 286)
- CE: Assurance publication - `Assurance` is an _element_ of ${\\bf E}\_A$ (Section 11.2 Equation 123) -- need serialization in C.2 and a set definition in I.1.1.
- CE: Judgement publication - `Dispute` is an _component_ of ${\\bf E}\_D$ (Section 10.2 Equation 97 in ) -- need serialization in C.2, though ${\\bf B}$ covers ${\\bf c}, {\\bf v}, {\\bf f}$ components.
- CE: Preimage publication - `Preimage` is an _element_ of ${\\bf E}\_P$ (Equation 153) -- need serialization in C.2 and set definition in I.2.
- CE: Block publication - `Block` is just Equation 13, serialization of ${\\bf B}$ in C.2 (Equations 280-282).
- CE: Work Package Submission and Sharing - `Work Package` is (174), serialization of elements of $\\mathbb{P}$ in C.2 (Equation 287).
- CE: Audit-announcement - `Announcement` - see Equation 196.  Need serialization in C.2 and set definition in I.1.1.
- CE: AuditDA query `AuditDAQuery` &amp; response `AuditDAResponse` - need serialization in C.2 and a set definition in I.1.1.
- CE: ImportDA query `ImportDAQuery` &amp; response `ImportDAResponse` - need serialization in C.2 and maybe a set definition in I.1.1
- CE: Public ImportDA reconstruction `ImportDAReconstructionQuery` &amp; response `ImportDAReconstructionResponse` - need serialization in C.2 and maybe a set definition in I.1.1

Beyond the above encoding nitty gritty, it would be powerful to have JAMSNP, for each stream, have a short description of when the sender is typically expected to send and the expected behavior of the receiver when receiving each of the above.  You could leave it as an exercise for JAM implementers, but why?

Pedantic question: Why is V=1023, C=341 and not V=1026, C=342 where the latter  matches Appendix H&#x27;s 1026? Do you have a recommendation on how implementers get started with a &quot;tiny&quot; C, V, W\_C, W\_S?

In addition, the start of section 14 is messed up.</div>
<div class='msg'><time>2024‑07‑21 21:03</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Ok -- maybe C.2 should be expanded to cover all the SCALE encodings, not just for blocks but for JAMSNP stream objects?  Here are my notes:

- CE: Ticket submission - `Ticket` is an _element_ of ${\\bf E}\_T$ (Section 6.7 Equation 73) -- serialization of elements of  $\\mathbb{C}$ in C.2 (Equation 288)
- CE: Work Report publication - `Guaranteed Work Report` is an _element_ of ${\\bf E}\_G$ (Section 11.4 Equation 136) -- Serialization of $\\mathbb{W}$ is C.2 (Equation 286)
- CE: Assurance publication - `Assurance` is an _element_ of ${\\bf E}\_A$ (Section 11.2 Equation 123) -- need serialization in C.2 and a set definition in I.1.1.
- CE: Judgement publication - `Dispute` is an _component_ of ${\\bf E}\_D$ (Section 10.2 Equation 97 in ) -- need serialization in C.2, though ${\\bf B}$ covers ${\\bf c}, {\\bf v}, {\\bf f}$ components.
- CE: Preimage publication - `Preimage` is an _element_ of ${\\bf E}\_P$ (Equation 153) -- need serialization in C.2 and set definition in I.1.1.
- CE: Block publication - `Block` is  Section 4.1 Equation 13, serialization of ${\\bf B}$ is thorough in C.2 (Equations 280-282).
- CE: Work Package Submission and Sharing - `Work Package` is Section 14.3 Equation (174), serialization of elements of $\\mathbb{P}$ in C.2 (Equation 287).
- CE: Audit-announcement - `Announcement` - see Equation 196.  Need serialization in C.2 and set definition in I.1.1.
- CE: AuditDA query `AuditDAQuery` &amp; response `AuditDAResponse` - need serialization in C.2 and a maybe a set definition in I.1.1.
- CE: ImportDA query `ImportDAQuery` &amp; response `ImportDAResponse` - need serialization in C.2 and maybe a set definition in I.1.1
- CE: Public ImportDA reconstruction `ImportDAReconstructionQuery` &amp; response `ImportDAReconstructionResponse` - need serialization in C.2 and maybe a set definition in I.1.1

Beyond the above encoding nitty gritty, it would be powerful to have JAMSNP, for each stream, have a short description of when the sender is typically expected to send and the expected behavior of the receiver when receiving each of the above.  You could leave it as an exercise for JAM implementers, but why?

Pedantic question: Why is V=1023, C=341 and not V=1026, C=342 where the latter  matches Appendix H&#x27;s 1026? Do you have a recommendation on how implementers get started with a &quot;tiny&quot; C, V, W\_C, W\_S?

In addition, the start of section 14 is messed up.</div>
<div class='msg'><time>2024‑07‑21 21:04</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Ok -- maybe C.2 should be expanded to cover all the SCALE encodings, not just for blocks but for JAMSNP stream objects?  Here are my notes:

- CE: Ticket submission - `Ticket` is an _element_ of ${\\bf E}\_T$ (Section 6.7 Equation 73) -- serialization of elements of  $\\mathbb{C}$ in C.2 (Equation 288)
- CE: Work Report publication - `Guaranteed Work Report` is an _element_ of ${\\bf E}\_G$ (Section 11.4 Equation 136) -- Serialization of $\\mathbb{W}$ is C.2 (Equation 286)
- CE: Assurance publication - `Assurance` is an _element_ of ${\\bf E}\_A$ (Section 11.2 Equation 123) -- need serialization in C.2 and a set definition in I.1.1.
- CE: Judgement publication - `Dispute` is an _component_ of ${\\bf E}\_D$ (Section 10.2 Equation 97 in ) -- need serialization in C.2, though ${\\bf B}$ covers ${\\bf c}, {\\bf v}, {\\bf f}$ components.
- CE: Preimage publication - `Preimage` is an _element_ of ${\\bf E}\_P$ (Equation 153) -- need serialization in C.2 and set definition in I.1.1.
- CE: Block publication - `Block` is  Section 4.1 Equation 13, serialization of ${\\bf B}$ is thorough in C.2 (Equations 280-282).
- CE: Work Package Submission and Sharing - `Work Package` is Section 14.3 Equation (174), serialization of elements of $\\mathbb{P}$ in C.2 (Equation 287).
- CE: Audit-announcement - `Announcement` - see Equation 196.  Need serialization in C.2 and set definition in I.1.1.
- CE: AuditDA query `AuditDAQuery` &amp; response `AuditDAResponse` - need serialization in C.2 and a maybe a set definition in I.1.1.
- CE: ImportDA query `ImportDAQuery` &amp; response `ImportDAResponse` - need serialization in C.2 and maybe a set definition in I.1.1
- CE: Public ImportDA reconstruction `ImportDAReconstructionQuery` &amp; response `ImportDAReconstructionResponse` - need serialization in C.2 and maybe a set definition in I.1.1

Beyond the above encoding nitty gritty, it would be powerful to have JAMSNP, for each stream, have a short description of when the sender is typically expected to send and the expected behavior of the receiver when receiving each of the above.  You could leave it as an exercise for JAM implementers, but why?

Pedantic question: Why is V=1023, C=341 and not V=1026, C=342 where the latter  matches Appendix H&#x27;s 1026? Do you have a recommendation on how implementers get started with a &quot;tiny&quot; C, V, W\_C, W\_S?

Above is relative to 0.3.1 (7/17/24) -- In addition, the start of section 14 is messed up.</div>
<div class='msg'><time>2024‑07‑21 21:08</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Ok -- maybe C.2 should be expanded to cover all the SCALE encodings, not just for blocks but for JAMSNP stream objects?  Here are my notes:

- CE: Ticket submission - `Ticket` is an _element_ of ${\\bf E}\_T$ (Section 6.7 Equation 73) -- serialization of elements of  $\\mathbb{C}$ in C.2 (Equation 288)
- CE: Work Report publication - `Guaranteed Work Report` is an _element_ of ${\\bf E}\_G$ (Section 11.4 Equation 136) -- Serialization of $\\mathbb{W}$ is C.2 (Equation 286)
- CE: Assurance publication - `Assurance` is an _element_ of ${\\bf E}\_A$ (Section 11.2 Equation 123) -- need serialization in C.2 and a set definition in I.1.1.
- CE: Judgement publication - `Dispute` is an _component_ of ${\\bf E}\_D$ (Section 10.2 Equation 97) -- need serialization in C.2, though ${\\bf B}$ covers ${\\bf c}, {\\bf v}, {\\bf f}$ components.
- CE: Preimage publication - `Preimage` is an _element_ of ${\\bf E}\_P$ (Section 1.2 Equation 153) -- need serialization in C.2 and set definition in I.1.1.
- CE: Block publication - `Block` is  Section 4.1 Equation 13, serialization of ${\\bf B}$ is thorough in C.2 (Equations 280-282).
- CE: Work Package Submission and Sharing - `Work Package` is Section 14.3 Equation (174), serialization of elements of $\\mathbb{P}$ in C.2 (Equation 287).
- CE: Audit-announcement - `Announcement` - see Section 17.3 Equation 196.  Need serialization in C.2 and set definition in I.1.1.
- CE: AuditDA query `AuditDAQuery` &amp; response `AuditDAResponse` - need serialization in C.2 and a maybe a set definition in I.1.1.
- CE: ImportDA query `ImportDAQuery` &amp; response `ImportDAResponse` - need serialization in C.2 and maybe a set definition in I.1.1
- CE: Public ImportDA reconstruction `ImportDAReconstructionQuery` &amp; response `ImportDAReconstructionResponse` - need serialization in C.2 and maybe a set definition in I.1.1

Beyond the above encoding nitty gritty, it would be powerful to have JAMSNP, for each stream, have a short description of when the sender is typically expected to send and the expected behavior of the receiver when receiving each of the above.  You could leave it as an exercise for JAM implementers, but why?

Pedantic question: Why is V=1023, C=341 and not V=1026, C=342 where the latter  matches Appendix H&#x27;s 1026? Do you have a recommendation on how implementers get started with a &quot;tiny&quot; C, V, W\_C, W\_S?

Above is relative to 0.3.1 (7/17/24) -- In addition, the start of section 14 is messed up.</div>
<div class='msg'><time>2024‑07‑21 21:46</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Ok -- maybe C.2 should be expanded to cover all the SCALE encodings, not just for blocks but for JAMSNP stream objects?  Here are my notes:

- CE: Ticket submission - `Ticket` is an _element_ of ${\\bf E}\_T$ (Section 6.7 Equation 73) -- serialization of elements of  $\\mathbb{C}$ in C.2 (Equation 288)
- CE: Work Report publication - `Guaranteed Work Report` is an _element_ of ${\\bf E}\_G$ (Section 11.4 Equation 136) -- Serialization of $\\mathbb{W}$ is C.2 (Equation 286)
- CE: Assurance publication - `Assurance` is an _element_ of ${\\bf E}\_A$ (Section 11.2 Equation 123) -- need serialization in C.2 and a set definition in I.1.1.
- CE: Judgement publication - `Dispute` is an _component_ of ${\\bf E}\_D$ (Section 10.2 Equation 97) -- need serialization in C.2, though ${\\bf B}$ covers ${\\bf c}, {\\bf v}, {\\bf f}$ components.
- CE: Preimage publication - `Preimage` is an _element_ of ${\\bf E}\_P$ (Section 1.2 Equation 153) -- need serialization in C.2 and set definition in I.1.1.
- CE: Block publication - `Block` is  Section 4.1 Equation 13, serialization of ${\\bf B}$ is thorough in C.2 (Equations 280-282).
- CE: Work Package Submission and Sharing - `Work Package` is Section 14.3 Equation (174), serialization of elements of $\\mathbb{P}$ in C.2 (Equation 287).
- CE: Audit-announcement - `Announcement` - see Section 17.3 Equation 196.  Need serialization in C.2 and set definition in I.1.1.
- CE: AuditDA query `AuditDAQuery` &amp; response `AuditDAResponse` - need serialization in C.2 and a maybe a set definition in I.1.1.
- CE: ImportDA query `ImportDAQuery` &amp; response `ImportDAResponse` - need serialization in C.2 and maybe a set definition in I.1.1
- CE: Public ImportDA reconstruction `ImportDAReconstructionQuery` &amp; response `ImportDAReconstructionResponse` - need serialization in C.2 and maybe a set definition in I.1.1

Beyond the above encoding nitty gritty, it would be powerful to have JAMSNP, for each stream, have a short description of when the sender is typically expected to send and the expected behavior of the receiver when receiving each of the above.  You could leave it as an exercise for JAM implementers, but why?

Pedantic question: Why is V=1023, C=341 and not V=1026, C=342 where the latter  matches Appendix H&#x27;s 1026? 

Do you have a recommendation on how implementers get started with a &quot;tiny&quot; C, V, W\_C, W\_S?

Above is relative to 0.3.1 (7/17/24) -- In addition, the start of section 14 is messed up.</div>
<div class='msg'><time>2024‑07‑21 23:22</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Ok -- maybe C.2 should be expanded to cover all the SCALE encodings, not just for blocks but for JAMSNP stream objects?  Here are my notes:

- CE: Ticket submission - `Ticket` is an _element_ of ${\\bf E}\_T$ (Section 6.7 Equation 73) -- serialization of elements of  $\\mathbb{C}$ in C.2 (Equation 288)
- CE: Work Report publication - `Guaranteed Work Report` is an _element_ of ${\\bf E}\_G$ (Section 11.4 Equation 136) -- Serialization of $\\mathbb{W}$ is C.2 (Equation 286)
- CE: Assurance publication - `Assurance` is an _element_ of ${\\bf E}\_A$ (Section 11.2 Equation 123) -- need serialization in C.2 and a set definition in I.1.1.
- CE: Judgement publication - `Dispute` contains _component_ of ${\\bf E}\_D$ (Section 10.2 Equation 97) -- need serialization in C.2, though ${\\bf B}$ covers ${\\bf c}, {\\bf v}, {\\bf f}$ components.
- CE: Preimage publication - `Preimage` is an _element_ of ${\\bf E}\_P$ (Section 1.2 Equation 153) -- need serialization in C.2 and set definition in I.1.1.
- CE: Block publication - `Block` is  Section 4.1 Equation 13, serialization of ${\\bf B}$ is thorough in C.2 (Equations 280-282).
- CE: Work Package Submission and Sharing - `Work Package` is Section 14.3 Equation (174), serialization of elements of $\\mathbb{P}$ in C.2 (Equation 287).
- CE: Audit-announcement - `Announcement` - see Section 17.3 Equation 196.  Need serialization in C.2 and set definition in I.1.1.
- CE: AuditDA query `AuditDAQuery` &amp; response `AuditDAResponse` - need serialization in C.2 and  maybe set definitions in I.1.1.
- CE: ImportDA query `ImportDAQuery` &amp; response `ImportDAResponse` - need serialization in C.2 and maybe set definitions in I.1.1
- CE: Public ImportDA reconstruction `ImportDAReconstructionQuery` &amp; response `ImportDAReconstructionResponse` - need serialization in C.2 and maybe set definitions in I.1.1

Beyond the above encoding nitty gritty, it would be powerful to have JAMSNP, for each stream, have a short description of when the sender is typically expected to send and the expected behavior of the receiver when receiving each of the above.  You could leave it as an exercise for JAM implementers, but why?

Pedantic question: Why is V=1023, C=341 and not V=1026, C=342 where the latter  matches Appendix H&#x27;s 1026?

Do you have a recommendation on how implementers get started with a &quot;tiny&quot; C, V, W\_C, W\_S?

Above is relative to 0.3.1 (7/17/24) -- In addition, the start of section 14 is messed up.</div>
<div class='msg'><time>2024‑07‑21 23:23</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Ok -- maybe C.2 should be expanded to cover all the SCALE encodings, not just for blocks but for JAMSNP stream objects?  Here are my notes:

- CE: Ticket submission - `Ticket` is an _element_ of ${\\bf E}\_T$ (Section 6.7 Equation 73) -- serialization of elements of  $\\mathbb{C}$ in C.2 (Equation 288)
- CE: Work Report publication - `Guaranteed Work Report` is an _element_ of ${\\bf E}\_G$ (Section 11.4 Equation 136) -- Serialization of $\\mathbb{W}$ is C.2 (Equation 286)
- CE: Assurance publication - `Assurance` is an _element_ of ${\\bf E}\_A$ (Section 11.2 Equation 123) -- need serialization in C.2 and a set definition in I.1.1.
- CE: Judgement publication - `Dispute` contains _components_ of ${\\bf E}\_D$ (Section 10.2 Equation 97) -- need serialization in C.2, though ${\\bf B}$ covers ${\\bf c}, {\\bf v}, {\\bf f}$ components.
- CE: Preimage publication - `Preimage` is an _element_ of ${\\bf E}\_P$ (Section 1.2 Equation 153) -- need serialization in C.2 and set definition in I.1.1.
- CE: Block publication - `Block` is  Section 4.1 Equation 13, serialization of ${\\bf B}$ is thorough in C.2 (Equations 280-282).
- CE: Work Package Submission and Sharing - `Work Package` is Section 14.3 Equation (174), serialization of elements of $\\mathbb{P}$ in C.2 (Equation 287).
- CE: Audit-announcement - `Announcement` - see Section 17.3 Equation 196.  Need serialization in C.2 and set definition in I.1.1.
- CE: AuditDA query `AuditDAQuery` &amp; response `AuditDAResponse` - need serialization in C.2 and  maybe set definitions in I.1.1.
- CE: ImportDA query `ImportDAQuery` &amp; response `ImportDAResponse` - need serialization in C.2 and maybe set definitions in I.1.1
- CE: Public ImportDA reconstruction `ImportDAReconstructionQuery` &amp; response `ImportDAReconstructionResponse` - need serialization in C.2 and maybe set definitions in I.1.1

Beyond the above encoding nitty gritty, it would be powerful to have JAMSNP, for each stream, have a short description of when the sender is typically expected to send and the expected behavior of the receiver when receiving each of the above.  You could leave it as an exercise for JAM implementers, but why?

Pedantic question: Why is V=1023, C=341 and not V=1026, C=342 where the latter  matches Appendix H&#x27;s 1026?

Do you have a recommendation on how implementers get started with a &quot;tiny&quot; C, V, W\_C, W\_S?

Above is relative to 0.3.1 (7/17/24) -- In addition, the start of section 14 is messed up.</div>
<div class='msg'><time>2024‑07‑21 23:24</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Ok -- maybe C.2 should be expanded to cover all the SCALE encodings, not just for blocks but for JAMSNP stream objects?  Here are my notes:

- CE: Ticket submission - `Ticket` is an _element_ of ${\\bf E}\_T$ (Section 6.7 Equation 73) -- serialization of elements of  $\\mathbb{C}$ in C.2 (Equation 288)
- CE: Work Report publication - `Guaranteed Work Report` is an _element_ of ${\\bf E}\_G$ (Section 11.4 Equation 136) -- Serialization of $\\mathbb{W}$ is C.2 (Equation 286)
- CE: Assurance publication - `Assurance` is an _element_ of ${\\bf E}\_A$ (Section 11.2 Equation 123) -- need serialization in C.2 and a set definition in I.1.1.
- CE: Judgement publication - `Dispute` contains _components_ of ${\\bf E}\_D$ (Section 10.2 Equation 97) -- need serialization in C.2, though ${\\bf B}$ covers ${\\bf c}, {\\bf v}, {\\bf f}$ components.
- CE: Preimage publication - `Preimage` is an _element_ of ${\\bf E}\_P$ (Section 11.2 Equation 153) -- need serialization in C.2 and set definition in I.1.1.
- CE: Block publication - `Block` is  Section 4.1 Equation 13, serialization of ${\\bf B}$ is thorough in C.2 (Equations 280-282).
- CE: Work Package Submission and Sharing - `Work Package` is Section 14.3 Equation (174), serialization of elements of $\\mathbb{P}$ in C.2 (Equation 287).
- CE: Audit-announcement - `Announcement` - see Section 17.3 Equation 196.  Need serialization in C.2 and set definition in I.1.1.
- CE: AuditDA query `AuditDAQuery` &amp; response `AuditDAResponse` - need serialization in C.2 and  maybe set definitions in I.1.1.
- CE: ImportDA query `ImportDAQuery` &amp; response `ImportDAResponse` - need serialization in C.2 and maybe set definitions in I.1.1
- CE: Public ImportDA reconstruction `ImportDAReconstructionQuery` &amp; response `ImportDAReconstructionResponse` - need serialization in C.2 and maybe set definitions in I.1.1

Beyond the above encoding nitty gritty, it would be powerful to have JAMSNP, for each stream, have a short description of when the sender is typically expected to send and the expected behavior of the receiver when receiving each of the above.  You could leave it as an exercise for JAM implementers, but why?

Pedantic question: Why is V=1023, C=341 and not V=1026, C=342 where the latter  matches Appendix H&#x27;s 1026?

Do you have a recommendation on how implementers get started with a &quot;tiny&quot; C, V, W\_C, W\_S?

Above is relative to 0.3.1 (7/17/24) -- In addition, the start of section 14 is messed up.</div>
<div class='msg'><time>2024‑07‑22 12:36</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: I have a question regarding the safrole algorithm. Since the author of the block &quot;gives away who he is,&quot; shouldn&#x27;t the header also include proof that they are entitled to the ticket? From my understanding, $$H_s$$ is a Bandersnatch signature of the headers, but I don&#x27;t see how it is sufficient to prove ownership of the ticket.

Shouldn&#x27;t we also include opring, using the notation from the 2023 paper by Jeffrey Burdges, where opring contains a NARK.Proof(comring, pk, ring)
?

I also reviewed the code in the Bandersnatch VRFs spec example. I noticed that the code assumes the prover_key_index is the correct one by using the same variable `prover_key_index` for both signing and verification.

I feel there is something obvious that I am not seeing :)</div>
<div class='msg reply'><time>2024‑07‑22 12:58</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: &gt;gives away who he is,&quot; shouldn&#x27;t the header also include proof that they are entitled to the ticket

IIUC: the header seal signature is the proof. It is a bandersnatch sig (not a bandersnatch ring sig).  
This sig can only be created by the holder of the key for the slot of that block - which was determined in advance by the ticket contest.  

So by issuing a standard bandersnatch signature, they give away that they control the respective authoring key.</div>
<div class='msg reply'><time>2024‑07‑22 13:12</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: I agree that it is a bandersnatch signature but the ticket itself is generated using a bandersnatch ring signature.

How do you &quot;relate&quot; the holder of the key with the ticket seal in $$\gamma_s$$ ?

$$i$$ is known ($$\gamma_s[H_t]$$) - and so is the expected Y(H_s) - so what prevents me from signing with my own key E_U(H), sign $$H_v$$ as well (since I know expected Y(H_s)) then pretend I am the owner of the ticket ?</div>
<div class='msg reply'><time>2024‑07‑22 13:19</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: Not sure if i understand what you are asking, but if you just sign `Y(H_v)` with a different key, then it wont verify.  
`Y(H_v)` is passed into the signature verification function `vrf_verify` alongside with the public key. Only the author key can verify for that `Y(H_v)`.  
so you cannot just &quot;steal&quot; the ticket by copying the `Y(H_v)`.</div>
<div class='msg reply'><time>2024‑07‑22 13:29</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: What do you mean by &quot;sign Y(H_v)&quot; ? H_v and H_s are both headers provided by the one submitting the block.

The vrf value/ticket is known (looking at `$$\gamma_s$$`) that is we know what $$Y(H_s)$$ is supposed to be. So we know the context of $$H_v$$ signature. So I can sign [] with context X_E+Y(H_s) using my own key and sign E_U(H) with context X_T+eta_3+i_r (I can try i_r equals 0 or 1), I don&#x27;t see what is gonna fail here</div>
<div class='msg'><time>2024‑07‑22 12:45</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>:  * I have a question regarding the safrole algorithm. Since the author of the block &quot;gives away who he is,&quot; shouldn&#x27;t the header also include proof that they are entitled to the ticket? From my understanding, $$H\_s$$ is a Bandersnatch signature of $$E_U(H)$$, but I don&#x27;t see how it is sufficient to prove ownership of the ticket.

Shouldn&#x27;t we also include opring, using the notation from the 2023 paper by Jeffrey Burdges, where opring contains a NARK.Proof(comring, pk, ring)
?

I also reviewed the code in the Bandersnatch VRFs spec example. I noticed that the code assumes the prover\_key\_index is the correct one by using the same variable `prover_key_index` for both signing and verification.

I feel there is something obvious that I am not seeing :)</div>
<div class='msg'><time>2024‑07‑22 12:46</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>:  * I have a question regarding the safrole algorithm. Since the author of the block &quot;gives away who he is,&quot; shouldn&#x27;t the header also include proof that they are entitled to the ticket? From my understanding, $$H\_s$$ is a Bandersnatch signature of $$E\_U(H)$$ with same context as ticket, but I don&#x27;t see how it is sufficient to prove ownership of the ticket.

Shouldn&#x27;t we also include opring, using the notation from the 2023 paper by Jeffrey Burdges, where opring contains a NARK.Proof(comring, pk, ring)
?

I also reviewed the code in the Bandersnatch VRFs spec example. I noticed that the code assumes the prover\_key\_index is the correct one by using the same variable `prover_key_index` for both signing and verification.

I feel there is something obvious that I am not seeing :)</div>
<div class='msg'><time>2024‑07‑22 13:14</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>:  * I agree that it is a bandersnatch signature but the ticket itself is generated using a bandersnatch ring signature.

How do you &quot;relate&quot; the holder of the key with the ticket seal in $$\\gamma\_s$$ ?

$$i$$ is known ($$\\gamma\_s\[H\_t\]$$) - and so is the expected Y(H\_s) - so what prevents me from signing with my own key E\_U(H), sign [] with context $$X_E + Y(H_v)$$ as well (since I know expected Y(H\_s)) then pretend I am the owner of the ticket ?</div>
<div class='msg'><time>2024‑07‑22 19:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; Pedantic question: Why is V=1023, C=341 and not V=1026, C=342 where the latter matches Appendix H&#x27;s 1026?

Keeping the number no greater than 1024 is (or at least was) helpful for a few algorithms, including EC and SNARKs.</div>
<div class='msg reply'><time>2024‑07‑22 19:30</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Looks like Safrole wants V=1023
https://github.com/w3f/jamtestvectors/blob/master/safrole/README.md
and EC wants V=1026.  </div>
<div class='msg reply'><time>2024‑07‑22 20:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Looks like Safrole wants V=1023
&gt; https://github.com/w3f/jamtestvectors/blob/master/safrole/README.md
&gt; and EC wants V=1026.  This needs to be resolved for GP self-consistency, right? 
&gt; Alistair said something about &quot;This could be 1024*2.&quot; a couple of days back and he has the path to reconcile this?
&gt; 

The numbers are correct. </div>
<div class='msg reply'><time>2024‑07‑22 23:18</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Got it.  Clarifying that chunks for &quot;1023..1024..1025&quot; in 342:1026 don&#x27;t actually get distributed to anyone might be useful.</div>
<div class='msg reply'><time>2024‑07‑23 09:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Got it.  Clarifying that chunks for &quot;1023..1024..1025&quot; in 342:1026 don&#x27;t actually get distributed to anyone might be useful, in a footnote in H.1 or 14.2.  

In fact the latest GP (`main` branch) revises this to a rate of 342..1023, thereby removing this weirdness. </div>
<div class='msg'><time>2024‑07‑22 19:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * &gt; Pedantic question: Why is V=1023, C=341 and not V=1026, C=342 where the latter matches Appendix H&#x27;s 1026?

Keeping the number no greater than 1024 is (or at least was) helpful for ensuring the speed of a few algorithms, including EC and SNARKs.</div>
<div class='msg'><time>2024‑07‑22 19:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; Do you have a recommendation on how implementers get started with a &quot;tiny&quot; C, V, W_C, W_S?

Don&#x27;t know what you mean.</div>
<div class='msg reply'><time>2024‑07‑22 19:36</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: I mean that for those of us who want to just start doing producing blocks with a single machine simulating V nodes will choose a tiny V, like 6 (C=2).  But the EC parameters have to match.  Ideally we&#x27;d have &quot;tiny&quot; test vectors with very low V to match the &quot;full&quot; test vectors.  Safrole test vectors have tiny V=6 already and V=1024.  So the recommendation request is how to adjust other parameters W_C, W_S, ... and the EC procedure such that all teams can do basically the same thing.  

For me this low V situation (V=6 or 9 or 12) enables a quick way for 2-4 teams to test against each other, in a ZombieNet like way, instead of the impractically large V=1023 or V=1026 situation.  </div>
<div class='msg reply'><time>2024‑07‑22 20:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; I mean that for those of us who want to just start doing producing blocks with a single machine simulating V nodes will choose a tiny V, like 6 (C=2).  But the EC parameters have to match.  Ideally we&#x27;d have &quot;tiny&quot; test vectors with very low V to match the &quot;full&quot; test vectors.  Safrole test vectors have tiny V=6 already and V=1024.  So the recommendation request is how to adjust other parameters W\_C, W\_S, ... and the EC procedure such that all teams can do basically the same thing.  
&gt; 
&gt; For me this low V situation (V=6 or 9 or 12) enables a quick way for 2-4 teams to test against each other, in a ZombieNet like way, instead of the impractically large V=1023 or V=1026 situation (not for mainnet, just for a single team to get all components working together).  The EC component is most glaring so we&#x27;ll just use some other Reed-Solomon parameters in the low V case but I&#x27;m sure you will have better parameter selection? 

Safrole should have test vectors for V=1023. [@davxy:matrix.org](https://matrix.to/#/@davxy:matrix.org)please confirm. </div>
<div class='msg reply'><time>2024‑07‑22 23:10</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Yes the Safrole test vectors are V=1023.  </div>
<div class='msg'><time>2024‑07‑22 19:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; In addition, the start of section 14 is messed up.

Don&#x27;t know what you mean.</div>
<div class='msg reply'><time>2024‑07‑22 19:25</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: image.png</div>
<div class='msg reply'><time>2024‑07‑22 19:29</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: see final pdf.  Not a big deal, but maybe you had some content there. </div>
<div class='msg reply'><time>2024‑07‑22 20:17</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; sent an image.

No idea how you generated that. My pdf (and that uploaded to github) is fine. </div>
<div class='msg reply'><time>2024‑07‑22 23:15</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: The present
https://graypaper.com/graypaper_inverted.pdf
https://graypaper.com/graypaper_no_background.pdf
have the above problem 
https://graypaper.com/graypaper.pdf 
do not.  </div>
<div class='msg'><time>2024‑07‑22 19:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; but I don&#x27;t see how it is sufficient to prove ownership of the ticket.

See the top line of (60)</div>
<div class='msg'><time>2024‑07‑22 19:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: image.png</div>
<div class='msg'><time>2024‑07‑22 19:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The ticket ID (VRF output) is required to be the same. This guarantees the sealer is the ticket owner.</div>
<div class='msg'><time>2024‑07‑22 19:28</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: image.png</div>
<div class='msg'><time>2024‑07‑22 19:28</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: But how do we go from bandersnatch signature (H_s) to bandersnatch ringVRF ? :)

When I look at the ringVRF construction from 2023 Jeffrey Burdges I don&#x27;t see how we can do this ?</div>
<div class='msg'><time>2024‑07‑22 19:31</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Maybe we can go to bed for now 😅</div>
<div class='msg'><time>2024‑07‑22 19:33</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>:  * But how do we go from bandersnatch signature (H\_s) to bandersnatch ringVRF ? :)

When I look at the ringVRF construction from 2023 Jeffrey Burdges I don&#x27;t see how we can do this ?

And the ticket is signed with message/additional data equal to empty [] and H_s is supposed to be on E_U : I think the signature changes if additional data/message changes</div>
<div class='msg'><time>2024‑07‑22 19:35</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>:  * But how do we go from bandersnatch signature (H\_s) to bandersnatch ringVRF ? :)
(The only obvious way I see is to have `opring`)

When I look at the ringVRF construction from 2023 Jeffrey Burdges I don&#x27;t see how we can do this ?

And the ticket is signed with message/additional data equal to empty \[\] and H\_s is supposed to be on E\_U : I think the signature changes if additional data/message changes</div>
<div class='msg'><time>2024‑07‑22 19:35</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>:  * But how do we go from bandersnatch signature (H\_s) to bandersnatch ringVRF ? :)
(The only obvious way I see is to have `opring`)

When I look at the ringVRF construction from 2023 Jeffrey Burdges I don&#x27;t see how we can do this (aside from using `opring`) ?

And the ticket is signed with message/additional data equal to empty \[\] and H\_s is supposed to be on E\_U : I think the signature changes if additional data/message changes</div>
<div class='msg'><time>2024‑07‑22 20:00</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * I mean that for those of us who want to just start doing producing blocks with a single machine simulating V nodes will choose a tiny V, like 6 (C=2).  But the EC parameters have to match.  Ideally we&#x27;d have &quot;tiny&quot; test vectors with very low V to match the &quot;full&quot; test vectors.  Safrole test vectors have tiny V=6 already and V=1024.  So the recommendation request is how to adjust other parameters W\_C, W\_S, ... and the EC procedure such that all teams can do basically the same thing.  

For me this low V situation (V=6 or 9 or 12) enables a quick way for 2-4 teams to test against each other, in a ZombieNet like way, instead of the impractically large V=1023 or V=1026 situation (not for mainnet, just for a single team to get all components working together).  The EC component is most glaring so we&#x27;ll just use some other Reed-Solomon parameters in the low V case but I&#x27;m sure you will have better parameter selection? </div>
<div class='msg'><time>2024‑07‑22 20:04</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Looks like Safrole wants V=1023
https://github.com/w3f/jamtestvectors/blob/master/safrole/README.md
and EC wants V=1026.  This needs to be resolved for GP self-consistency, right? 
Alistair said something about &quot;This could be 1024*2.&quot; a couple of days back and he has the path to reconcile this?
</div>
<div class='msg'><time>2024‑07‑22 20:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Looks like Safrole wants V=1023
&gt; https://github.com/w3f/jamtestvectors/blob/master/safrole/README.md
&gt; and EC wants V=1026.  This needs to be resolved for GP self-consistency, right? 
&gt; Alistair said something about &quot;This could be 1024*2.&quot; a couple of days back and he has the path to reconcile this?
&gt; 

* The numbers are correct. There is nothing to resolve. </div>
<div class='msg'><time>2024‑07‑22 20:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@celadari:matrix.org&gt; But how do we go from bandersnatch signature (H\_s) to bandersnatch ringVRF ? :)
&gt; (The only obvious way I see is to have `opring`)
&gt; 
&gt; When I look at the ringVRF construction from 2023 Jeffrey Burdges I don&#x27;t see how we can do this (aside from using `opring`) ?
&gt; 
&gt; And the ticket is signed with message/additional data equal to empty \[\] and H\_s is supposed to be on E\_U : I think the signature changes if additional data/message changes

Will need to defer to [@davxy:matrix.org](https://matrix.to/#/@davxy:matrix.org)for the RingVRF/Bandersnatch specifics. </div>
<div class='msg'><time>2024‑07‑22 20:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Looks like Safrole wants V=1023
&gt; https://github.com/w3f/jamtestvectors/blob/master/safrole/README.md
&gt; and EC wants V=1026.  This needs to be resolved for GP self-consistency, right? 
&gt; Alistair said something about &quot;This could be 1024*2.&quot; a couple of days back and he has the path to reconcile this?
&gt; 

* The numbers are correct. There is nothing to resolve. There are 1023 validators and 342 are required for EC reconstruction. </div>
<div class='msg'><time>2024‑07‑22 20:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I have no plans to alter the EC; the tiny Safrole test vectors were given only as a convenience since proof generation can be quite slow. The same is not true for EC. </div>
<div class='msg'><time>2024‑07‑22 20:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: V=6 seems fair for a testnet but it’s totally up to you. Experiment. </div>
<div class='msg'><time>2024‑07‑22 20:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * V=6 seems fair for a testnet but it’s totally up to you. Experiment. </div>
<div class='msg'><time>2024‑07‑22 23:15</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * The present
https://graypaper.com/graypaper\_inverted.pdf
https://graypaper.com/graypaper\_no\_background.pdf
have the above problem 
https://graypaper.com/graypaper.pdf 
does not.  </div>
<div class='msg'><time>2024‑07‑22 23:30</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Got it.  Clarifying that chunks for &quot;1023..1024..1025&quot; in 342:1026 don&#x27;t actually get distributed to anyone might be useful, in a footnote in H.1 or 14.2.  </div>
<div class='msg'><time>2024‑07‑22 23:43</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Got it.  Clarifying that chunks for &quot;1023..1024..1025&quot; in Appendix H 342:1026 don&#x27;t actually get distributed to anyone might be useful, in a footnote in H.1 or 14.2.  This suppresses others like me who perceive a discrepancy.  </div>
<div class='msg'><time>2024‑07‑23 00:48</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * The key insight, we found, is from RFC 26 \[which we&#x27;re not supposed to get too confused by but is an excellent introduction\] in these:

(a) 
```
ietf\_vrf\_output (Non anonymous VRF): vrf\_output(secret, input) == vrf\_signed\_output(signature) 
```

(b) 
```
ring\_vrf\_output (Anonymous VRF): vrf\_signed\_output(signature) == ring\_vrf\_signed\_output(ring\_signature);
```

The (a) case has the block author reveal himself through the signature of (a), you can consider that &quot;Non anonymous VRF&quot;

The (b)  does not reveal the ticket submitter, you can consider that a &quot;Anonymous VRF&quot;, which is the beauty of RingVRFs, an important invention.  

The key AHA I think for people is put (a)+(b) together: 

vrf\_output(secret, input) == vrf\_signed\_output(signature) == ring\_vrf\_signed\_output(ring\_signature)

which maps onto this line here:

https://github.com/davxy/bandersnatch-vrfs-spec/blob/1ec75e9a3af3a2be7dbca5090171c01e29ac5854/example/src/main.rs#L268C33-L268C48

Once you understand that, all the GP notation will fall into place for you I hope.

</div>
<div class='msg'><time>2024‑07‑23 00:49</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * The key insight, we found, is from RFC 26 \[which we&#x27;re not supposed to get too confused by but is an excellent introduction\] in these:

(a)

```
ietf_vrf_output (Non anonymous VRF): vrf_output(secret, input) == vrf_signed_output(signature) 
```

(b)

```
ring_vrf_output (Anonymous VRF): vrf_signed_output(signature) == ring_vrf_signed_output(ring_signature);
```

The (a) case has the block author reveal himself through the signature of (a), you can consider that &quot;Non anonymous VRF&quot;

The (b)  does not reveal the ticket submitter, you can consider that a &quot;Anonymous VRF&quot;, which is the beauty of RingVRFs, an important invention.

The key AHA I think for people is you will put (a)+(b) together with the same Bandersnatch key like so:

vrf\_output(secret, input) == vrf\_signed\_output(signature) == ring\_vrf\_signed\_output(ring\_signature)

and this basically maps onto this line here from davxy :

https://github.com/davxy/bandersnatch-vrfs-spec/blob/1ec75e9a3af3a2be7dbca5090171c01e29ac5854/example/src/main.rs#L268C33-L268C48

Once you understand that, all the GP notation will fall into place for you I hope.</div>
<div class='msg'><time>2024‑07‑23 00:52</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * The key insight, we found, is from RFC 26 \[which we&#x27;re not supposed to get too confused by but is an excellent introduction\] in these:

(a)

```
ietf_vrf_output (Non anonymous VRF): vrf_output(secret, input) == vrf_signed_output(signature) 
```

(b)

```
ring_vrf_output (Anonymous VRF): vrf_signed_output(signature) == ring_vrf_signed_output(ring_signature);
```

The (a) case has the block author reveal himself through the signature of (a) in block authoring, and you can consider that &quot;Non anonymous VRF&quot;

The (b) does NOT reveal the ticket submitter, you can consider that a &quot;Anonymous VRF&quot;, which is the beauty of RingVRFs, an important invention.

The key AHA I think for people is you will put (a)+(b) together with the same Bandersnatch key like so:

vrf\_output(secret, input) == vrf\_signed\_output(signature) == ring\_vrf\_signed\_output(ring\_signature)

and this basically maps onto this line here from davxy :

https://github.com/davxy/bandersnatch-vrfs-spec/blob/1ec75e9a3af3a2be7dbca5090171c01e29ac5854/example/src/main.rs#L268C33-L268C48

Once you understand that, all the GP notation will fall into place for you I hope.</div>
<div class='msg'><time>2024‑07‑23 00:54</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * The key insight, we found, is from RFC 26 \[which we&#x27;re not supposed to get too confused by but is an excellent introduction\] in these:

(a)

```
ietf_vrf_output (Non anonymous VRF): vrf_output(secret, input) == vrf_signed_output(signature) 
```

(b)

```
ring_vrf_output (Anonymous VRF): vrf_signed_output(signature) == ring_vrf_signed_output(ring_signature);
```

The (a) case has the block author reveal himself through the signature of (a) in block authoring, and you can consider that &quot;Non anonymous VRF&quot;

The (b) does NOT reveal the ticket submitter, you can consider that a &quot;Anonymous VRF&quot;, which is the beauty of RingVRFs, an important invention.

The key AHA I think for people is you will put (a)+(b) together with the same Bandersnatch key like so:

vrf\_output(secret, input) == vrf\_signed\_output(signature) == ring\_vrf\_signed\_output(ring\_signature)

and this basically maps onto this line here from davxy :

https://github.com/davxy/bandersnatch-vrfs-spec/blob/1ec75e9a3af3a2be7dbca5090171c01e29ac5854/example/src/main.rs#L268C33-L268C48

Once you understand that, all the GP notation will fall into place for you I hope.  The ticket submitter uses (b) and once its time to author blocks (assuming its the non-fallback case, and ), he uses (a) when its his turn to author the block.  </div>
<div class='msg'><time>2024‑07‑23 00:56</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * The key insight, we found, is from RFC 26 \[which we&#x27;re not supposed to get too confused by but is an excellent introduction\] in these:

(a)

```
ietf_vrf_output (Non anonymous VRF): vrf_output(secret, input) == vrf_signed_output(signature) 
```

(b)

```
ring_vrf_output (Anonymous VRF): vrf_signed_output(signature) == ring_vrf_signed_output(ring_signature);
```

The (a) case has the block author reveal himself through the signature of (a) in block authoring, and you can consider that &quot;Non anonymous VRF&quot;

The (b) does NOT reveal the ticket submitter, you can consider that a &quot;Anonymous VRF&quot;, which is the beauty of RingVRFs, an important invention.

The key AHA I think for people is you will put (a)+(b) together with the same Bandersnatch key like so:

vrf\_output(secret, input) == vrf\_signed\_output(signature) == ring\_vrf\_signed\_output(ring\_signature)

and this basically maps onto this line here from davxy :

https://github.com/davxy/bandersnatch-vrfs-spec/blob/1ec75e9a3af3a2be7dbca5090171c01e29ac5854/example/src/main.rs#L268C33-L268C48

Once you understand that, all the GP notation will fall into place for you I hope.  The ticket submitter uses (b) and once its time to author blocks (assuming its the non-fallback case, and his ticket submission is among the lowest), he uses (a).  </div>
<div class='msg'><time>2024‑07‑23 00:56</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * The key insight, we found, is from RFC 26 \[which we&#x27;re not supposed to get too confused by but is an excellent introduction\] in these:

(a)

```
ietf_vrf_output (Non anonymous VRF): vrf_output(secret, input) == vrf_signed_output(signature) 
```

(b)

```
ring_vrf_output (Anonymous VRF): vrf_signed_output(signature) == ring_vrf_signed_output(ring_signature);
```

The (a) case has the block author reveal himself through the signature of (a) in block authoring, and you can consider that &quot;Non anonymous VRF&quot;

The (b) does NOT reveal the ticket submitter, you can consider that a &quot;Anonymous VRF&quot;, which is the beauty of RingVRFs, an important invention.

The key AHA I think for people is you will put (a)+(b) together with the same Bandersnatch key like so:

vrf\_output(secret, input) == vrf\_signed\_output(signature) == ring\_vrf\_signed\_output(ring\_signature)

and this basically maps onto this line here from davxy :

https://github.com/davxy/bandersnatch-vrfs-spec/blob/1ec75e9a3af3a2be7dbca5090171c01e29ac5854/example/src/main.rs#L268C33-L268C48

Once you understand that, all the GP notation will fall into place for you I hope.  The ticket submitter uses (b) _anonymously_ and once its time to author blocks (assuming its the non-fallback case, and his ticket submission is among the lowest), he uses (a) _non-anonymously_.  The ticketid is the VRF output common to both (a)+(b).</div>
<div class='msg'><time>2024‑07‑23 00:57</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * The key insight, we found, is from RFC 26 \[which we&#x27;re not supposed to read and get too confused by because Safrole != Sassafras, but is an excellent introduction nevertheless \] in these:

(a)

```
ietf_vrf_output (Non anonymous VRF): vrf_output(secret, input) == vrf_signed_output(signature) 
```

(b)

```
ring_vrf_output (Anonymous VRF): vrf_signed_output(signature) == ring_vrf_signed_output(ring_signature);
```

The (a) case has the block author reveal himself through the signature of (a) in block authoring, and you can consider that &quot;Non anonymous VRF&quot;

The (b) does NOT reveal the ticket submitter, you can consider that a &quot;Anonymous VRF&quot;, which is the beauty of RingVRFs, an important invention.

The key AHA I think for people is you will put (a)+(b) together with the same Bandersnatch key like so:

vrf\_output(secret, input) == vrf\_signed\_output(signature) == ring\_vrf\_signed\_output(ring\_signature)

and this basically maps onto this line here from davxy :

https://github.com/davxy/bandersnatch-vrfs-spec/blob/1ec75e9a3af3a2be7dbca5090171c01e29ac5854/example/src/main.rs#L268C33-L268C48

Once you understand that, all the GP notation will fall into place for you I hope.  The ticket submitter uses (b) _anonymously_ and once its time to author blocks (assuming its the non-fallback case, and his ticket submission is among the lowest), he uses (a) _non-anonymously_.  The ticketid is the VRF output common to both (a)+(b).</div>
<div class='msg'><time>2024‑07‑23 06:14</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@gav:polkadot.io&gt; Safrole should have test vectors for V=1023. [@davxy:matrix.org](https://matrix.to/#/@davxy:matrix.org)please confirm. 

I confirm that &quot;full&quot; vectors are generated with V=1023</div>
<div class='msg'><time>2024‑07‑23 06:24</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@gav:polkadot.io&gt; Will need to defer to [@davxy:matrix.org](https://matrix.to/#/@davxy:matrix.org)for the RingVRF/Bandersnatch specifics. 

@sourabhniyogi reply is quite insightful :-) @celadari I&#x27;ll add something later (currently afk)</div>
<div class='msg'><time>2024‑07‑23 09:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Got it.  Clarifying that chunks for &quot;1023..1024..1025&quot; in 342:1026 don&#x27;t actually get distributed to anyone might be useful, in a footnote in H.1 or 14.2.  

* In fact the latest GP (`main` branch) revises this to a rate of 342:1023, thereby removing this weirdness.</div>
<div class='msg'><time>2024‑07‑23 10:33</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: On another topic, I think some `max`s on appendix A should be `min`s, since they are used to disallow &quot;out of bounds&quot; access</div>
<div class='msg'><time>2024‑07‑23 10:34</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: Screenshot 2024-07-22 at 21.28.05.png</div>
<div class='msg'><time>2024‑07‑23 10:34</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: In all of these sections that calculate `l_x` or `l_y`</div>
<div class='msg'><time>2024‑07‑23 10:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yeah, there’s a fix incoming for that. </div>
<div class='msg'><time>2024‑07‑23 11:24</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@davxy:matrix.org&gt; @sourabhniyogi reply is quite insightful :-) @celadari I&#x27;ll add something later (currently afk)

This gist may be helpful: https://gist.github.com/davxy/c3327f799cb70a7c55087c97741fa8d9
(for struct defs, etc. refer to the example in bandersnatch specs repo)</div>
<div class='msg reply'><time>2024‑07‑23 14:10</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Thank you Davide 🙌, After checking the gist I realized that the ietfVRF output and ringVRF output are the same: obvious when looking at the 2024 paper but not obvious when looking at the 2023 paper

SO a ietfVRF Proof on an output made by ringVRF is still valid
SO even if the ticket in gamma_s was made using ringVRF, using the ietfVRF.Verify with H_s as signature, H_a as public key and E_U(H) as aux_data should produce the same output (since output is independant from aux_data)</div>
<div class='msg'><time>2024‑07‑23 14:05</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: </div>
<div class='msg'><time>2024‑07‑24 22:45</time>&ensp;<span class='u' style='color:#d25e85'>shawntabrizi</span>: gav - off grid, slow to respond: perhaps add a link to this channel to the header: https://www.youtube.com/@JamPrizeTour/videos

It has all videos of the JAM lectures, including Buenos Aries, Singapore, and Brussels</div>
<div class='msg'><time>2024‑07‑29 13:16</time>&ensp;<span class='u' style='color:#65c4c9'>jay-chrawnna</span>: Hi folks. We&#x27;re pleased to introduce the new lecture section of the graypaper website:
https://graypaper.com/lectures/</div>
<div class='msg'><time>2024‑07‑29 13:17</time>&ensp;<span class='u' style='color:#65c4c9'>jay-chrawnna</span>: Gray Paper Website.png</div>
<div class='msg'><time>2024‑07‑29 13:19</time>&ensp;<span class='u' style='color:#65c4c9'>jay-chrawnna</span>: This was filed and created as a join project by [Key Picutres](https://x.com/KeyPictures) &amp; [The Kus](https://x.com/TheKusamarian) under OpenGov Ref. 763</div>
<div class='msg'><time>2024‑07‑29 13:20</time>&ensp;<span class='u' style='color:#65c4c9'>jay-chrawnna</span>: More lectures and resources will be added over time. Please DM me directly if you have a request to make it more useful!</div>
<div class='msg'><time>2024‑07‑29 13:20</time>&ensp;<span class='u' style='color:#65c4c9'>jay-chrawnna</span>:  * This was filmed and created as a join project by [Key Picutres](https://x.com/KeyPictures) &amp; [The Kus](https://x.com/TheKusamarian) under OpenGov Ref. 763</div>
<div class='msg'><time>2024‑07‑29 13:20</time>&ensp;<span class='u' style='color:#65c4c9'>jay-chrawnna</span>:  * This was filmed and created as a joint project by [Key Picutres](https://x.com/KeyPictures) &amp; [The Kus](https://x.com/TheKusamarian) under OpenGov Ref. 763</div>
<div class='msg'><time>2024‑07‑29 13:23</time>&ensp;<span class='u' style='color:#65c4c9'>jay-chrawnna</span>: thanks Philip for all the help getting it live!</div>
<div class='msg reply'><time>2024‑07‑29 13:26</time>&ensp;<span class='u' style='color:#58d23c'>philip.poloczek</span>: Glad I could help. 👍️:)</div>
<div class='msg'><time>2024‑07‑29 13:24</time>&ensp;<span class='u' style='color:#65c4c9'>jay-chrawnna</span>:  * This was filmed and created as a joint project by [Key Pictures](https://x.com/KeyPictures) &amp; [The Kus](https://x.com/TheKusamarian) under OpenGov Ref. 763</div>
<div class='msg'><time>2024‑07‑29 14:20</time>&ensp;<span class='u' style='color:#65c4c9'>jay-chrawnna</span>: &gt; &lt;@shawntabrizi:matrix.org&gt; gav - off grid, slow to respond: perhaps add a link to this channel to the header: https://www.youtube.com/@JamPrizeTour/videos
&gt; 
&gt; It has all videos of the JAM lectures, including Buenos Aries, Singapore, and Brussels

if using YouTube, checkout the Playlist to see them in order!
https://www.youtube.com/watch?v=5UonAD0EpKI&amp;list=PLwcnAOKMj-Ab7sDej2P4peqGxu2mTGYNy&amp;index=35</div>
<div class='msg'><time>2024‑07‑29 14:20</time>&ensp;<span class='u' style='color:#65c4c9'>jay-chrawnna</span>:  * if using YouTube, checkout the Playlist to see them in order!
https://www.youtube.com/watch?v=wbnTnBQNDr4&amp;list=PLwcnAOKMj-Ab7sDej2P4peqGxu2mTGYNy&amp;index=1</div>
<div class='msg'><time>2024‑07‑29 14:36</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: &gt; &lt;@davxy:matrix.org&gt; sourabhniyogi:
&gt; 
&gt; 1. For Safrole test vectors the only thing we use is $jam\_ticket\_seal.
&gt; In particular this is used for the ring-vrf input construction (context in the GP) to obtain the ticket score (aka ticket-id)  during the candidate ticket verification procedure.
&gt; The value of $jam\_ticket\_seal&quot; is constant and defined as &quot;jam\_ticket\_seal&quot; ASCII string.
&gt; This is a thing that applies in general for values starting with `$` (e.g. `$foo` in the GP =&gt; `&quot;foo&quot;` ascii string).
&gt; (Thank you BTW as I&#x27;ve just spotted that I was using &quot;jam\_seal&quot; instead of &quot;jam\_ticket\_seal&quot;, I&#x27;ll add the fix to the upcoming vectors PR)
&gt; The other constant strings ($jam\_fallback\_seal and $jam\_entropy) are used for block verification and per-block entropy production (which is passed as input to Safrole).
&gt; NOTE: The actual value of per-block entropy used by the Safrole test vectors is not relevant to have been really produced using the signature in the header. Here we abstract away from the value&#x27;s origin, we don&#x27;t really care for the sake of the Safrole test vectors and Safrole STF. In the specific case I&#x27;ve used:
&gt; 
&gt;     - entropy\_0 = blake2b(\[42\_u8; 32\])\[..32\]
&gt;     - entropy\_i+1 = blake2b(entropy\_i)\[..32\]
&gt; 2. If you take as a reference the Sassafras RFC then there some differences.
&gt; One of these is the attempts number and redundancy factor, which in the GP are in practice simplified to one single thing (attempts number).
&gt; Threshold is gone.
&gt; Even though reading Sassafras RFC can help (as it is a quite similar protocol), always take the GP as the source of truth for JAM.
&gt; 3. Sure thing. I&#x27;ll post here as soon as it is ready.
&gt; 4. This is a very interesting observation. Current implementation serializes 3 extra fields (part of the SNARK SRS).
&gt; Serialization of these fields may be important **in a general application**, but here these values are constant.
&gt; I will definitely get rid of these from serialized data (I&#x27;m on it). The final size will be 144 (i.e. the last 144 bytes of what you see right now)

Hi Davide,

I&#x27;m quoting this old message as it is related to my doubt. I have checked messages on the chat here and there and I just wanted to confirm my understanding of the test vectors regarding safrole.

- Just to confirm, in the test vectors &quot;input.entropy&quot; refers here to Y(H_v) of the GP, right?
- Thus, in the test vectors we don&#x27;t verify equations (59) and (60) (parts related to ark-ec-vrfs that I asked you about last week), right?</div>
<div class='msg'><time>2024‑07‑29 17:42</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@celadari:matrix.org&gt; Hi Davide,
&gt; 
&gt; I&#x27;m quoting this old message as it is related to my doubt. I have checked messages on the chat here and there and I just wanted to confirm my understanding of the test vectors regarding safrole.
&gt; 
&gt; - Just to confirm, in the test vectors &quot;input.entropy&quot; refers here to Y(H_v) of the GP, right?
&gt; - Thus, in the test vectors we don&#x27;t verify equations (59) and (60) (parts related to ark-ec-vrfs that I asked you about last week), right?

- As that old message reports, the `input.entropy` **for the vest vectors** is generated in some &quot;arbitrary&quot; manner (the quoted message reports how I generated it). In a real scenario YES, it is generated as per equation (66) of the last GP release (DRAFT 0.3.1 Jul 17). In the context of the safrole test vectors,  is not really important how we generate it as `H_v` is not present at all.
- In safrole test vectors **we don&#x27;t verify** the validity of the signatures contained within the header (i.e. H_v and H_s) simply because are not part of the safrole&#x27;s specific STF. These will be probably verified in some upcoming test vectors which verify the block&#x27;s header validity
</div>
<div class='msg reply'><time>2024‑07‑29 17:52</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Thank you</div>
<div class='msg'><time>2024‑07‑29 17:42</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * - As that old message reports, the `input.entropy` **for the vest vectors** is generated in some &quot;arbitrary&quot; manner (the quoted message reports how I generated it). In a real scenario YES, it is generated as per equation (66) of the last GP release (DRAFT 0.3.1 Jul 17). In the context of the safrole test vectors,  is not really important how we generate it as `H_v` is not present at all.
- In safrole test vectors **we don&#x27;t verify** the validity of the signatures contained within the header (i.e. H\_v and H\_s) simply because are not part of the safrole&#x27;s specific STF. These will be probably verified in some upcoming test vectors to asses block&#x27;s header validity</div>
<div class='msg'><time>2024‑07‑29 18:36</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Regarding &quot;recent history&quot;, why do we assign H_r to beta[0] instead of beta[|beta| - 1] ?

Since we produce beta&#x27; by appending the new elements to the end and taking the last H elements of the array (equation 81) I would have thought the last element of beta should be used for equation (80)</div>
<div class='msg'><time>2024‑07‑30 04:32</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-07-30 at 4.31.47 PM.png</div>
<div class='msg'><time>2024‑07‑30 04:33</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: not 100% sure what is the modulo subscription operator is doing here. does it mean the memory access is never out of bonds but wrapped?</div>
<div class='msg'><time>2024‑07‑30 10:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: </div>
<div class='msg'><time>2024‑07‑30 10:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; not 100% sure what is the modulo subscription operator is doing here. does it mean the memory access is never out of bonds but wrapped?

Yes.</div>
<div class='msg'><time>2024‑07‑30 10:42</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>:  * Regarding &quot;recent history&quot;, why do we assign H\_r to beta\[0\] instead of assigning it to beta\[|beta| - 1\] ?

Since we produce beta&#x27; by appending the new elements to the end and taking the last H elements of the array (equation 81) I would have thought the last element of beta should be used for equation (80)</div>
<div class='msg'><time>2024‑07‑31 09:01</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: am I wrong or there is no definition of what `Xv` is? being used in `98` first and `101`. I have the feeling `99` might miss something?</div>
<div class='msg'><time>2024‑07‑31 09:02</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: image.png</div>
<div class='msg'><time>2024‑07‑31 09:15</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: I think there is a bug in the version without background:
https://graypaper.com/graypaper_no_background.pdf

</div>
<div class='msg'><time>2024‑07‑31 09:15</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Screenshot 2024-07-31 at 10.13.30.png</div>
<div class='msg'><time>2024‑07‑31 09:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; am I wrong or there is no definition of what `Xv` is? being used in `98` first and `101`. I have the feeling `99` might miss something?

v is either true or false. Both possibilities are defined in (99)</div>
<div class='msg'><time>2024‑07‑31 09:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; I think there is a bug in the version without background:
&gt; https://graypaper.com/graypaper_no_background.pdf
&gt; 
&gt; 

I don’t know who produced these. [@philip.poloczek:parity.io](https://matrix.to/#/@philip.poloczek:parity.io) please remove them if they’re broken, thanks. </div>
<div class='msg'><time>2024‑07‑31 09:19</time>&ensp;<span class='u' style='color:#8e60c3'>obi</span>: </div>
<div class='msg'><time>2024‑07‑31 09:20</time>&ensp;<span class='u' style='color:#8e60c3'>obi</span>: </div>
<div class='msg'><time>2024‑07‑31 09:20</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@gav:polkadot.io&gt; v is either true or false. Both possibilities are defined in (99)

thanks for the answer. I might miss the link between `v`and `99` then. but thanks for confirming</div>
<div class='msg'><time>2024‑07‑31 09:20</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@gav:polkadot.io&gt; v is either true or false. Both possibilities are defined in (99)

 * thanks for the answer. I might miss the link between `v`and `(99)` then. but thanks for confirming</div>
<div class='msg'><time>2024‑07‑31 10:04</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: &gt; &lt;@prematurata:matrix.org&gt; thanks for the answer. I might miss the link between `v`and `(99)` then. but thanks for confirming

that `T` is true and the upside down `⟂` is false. Should be explained somewhere</div>
<div class='msg'><time>2024‑07‑31 10:05</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: &gt; &lt;@prematurata:matrix.org&gt; thanks for the answer. I might miss the link between `v`and `(99)` then. but thanks for confirming

 * that `T` is true and the upside down `⟂` is false. </div>
<div class='msg'><time>2024‑07‑31 10:05</time>&ensp;<span class='u' style='color:#58d23c'>philip.poloczek</span>: &gt; &lt;@danicuki:matrix.org&gt; I think there is a bug in the version without background:
&gt; https://graypaper.com/graypaper_no_background.pdf

Thanks for reporting this. It&#x27;s fixed now. Sorry for the inconvenience. 

I&#x27;ve added a disclaimer to the site that the white version is just for convenience and the gray version/github release being the decisive one</div>
<div class='msg'><time>2024‑07‑31 10:11</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: &gt; &lt;@danicuki:matrix.org&gt; I think there is a bug in the version without background:
&gt; https://graypaper.com/graypaper_no_background.pdf

there are some unofficial alternative renders in three color schemata here as well: https://jamcha.in/spec. They are automatically re-rendered from the main branch with at most 2hr delay. just in case you want the latest unreleased changes </div>
<div class='msg'><time>2024‑07‑31 12:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: @room v0.3.2 is tagged and PDF available https://github.com/gavofyork/graypaper/releases/tag/v0.3.2</div>
<div class='msg'><time>2024‑07‑31 14:55</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: I think i migght have found a typo in `129]</div>
<div class='msg'><time>2024‑07‑31 14:56</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * I think i migght have found a typo in `129`</div>
<div class='msg'><time>2024‑07‑31 14:56</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: image.png</div>
<div class='msg'><time>2024‑07‑31 14:56</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: let me know if that&#x27;s correct i will gladly open a PR with the fix</div>
<div class='msg'><time>2024‑07‑31 14:57</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: &gt; &lt;@celadari:matrix.org&gt; Regarding &quot;recent history&quot;, why do we assign H\_r to beta\[0\] instead of assigning it to beta\[|beta| - 1\] ?
&gt; 
&gt; Since we produce beta&#x27; by appending the new elements to the end and taking the last H elements of the array (equation 81) I would have thought the last element of beta should be used for equation (80)

sorry for insisting but shouldn&#x27;t we use</div>
<div class='msg'><time>2024‑07‑31 14:57</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: image.png</div>
<div class='msg'><time>2024‑07‑31 14:57</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: instead of</div>
<div class='msg'><time>2024‑07‑31 14:57</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: image.png</div>
<div class='msg'><time>2024‑07‑31 14:57</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: since we do append new elements at the end:</div>
<div class='msg'><time>2024‑07‑31 14:58</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>:  * since we do append new elements at the end and only take the H last elements:</div>
<div class='msg'><time>2024‑07‑31 14:58</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: image.png</div>
<div class='msg'><time>2024‑07‑31 14:58</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>:  * since we append new elements at the end and only take the H last elements:</div>
<div class='msg'><time>2024‑07‑31 15:00</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>:  * sorry for insisting but shouldn&#x27;t we use ?</div>
<div class='msg'><time>2024‑07‑31 15:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@celadari:matrix.org&gt; sorry for insisting but shouldn&#x27;t we use ?

yes that looks to be a typo...</div>
<div class='msg'><time>2024‑07‑31 17:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; I think i migght have found a typo in `129`

https://github.com/gavofyork/graypaper/pull/54/commits/c6d3af2abac9ab170e04ac820a40a6525c782b49 - thanks!</div>
<div class='msg'><time>2024‑08‑01 11:34</time>&ensp;<span class='u' style='color:#6ecf94'>qiwei</span>: image.png</div>
<div class='msg'><time>2024‑08‑01 11:35</time>&ensp;<span class='u' style='color:#6ecf94'>qiwei</span>: this should be `m` instead of `m&#x27;`?</div>
<div class='msg'><time>2024‑08‑01 12:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@qiwei:matrix.org&gt; this should be `m` instead of `m&#x27;`?

Yes :) https://github.com/gavofyork/graypaper/pull/54/commits/4a98e1f7180ed6d01d62ab5109092e2cb806d984</div>
<div class='msg'><time>2024‑08‑02 11:19</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: image.png</div>
<div class='msg'><time>2024‑08‑02 11:19</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: what is this sentence referring to? I tried to find the `above condition` that its being referred there but I am unsure</div>
<div class='msg'><time>2024‑08‑02 11:26</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>: &gt; &lt;@prematurata:matrix.org&gt; what is this sentence referring to? I tried to find the `above condition` that its being referred there but I am unsure

maybe it should say `above conditions are not met`? This is how I understood it a least.</div>
<div class='msg'><time>2024‑08‑02 11:27</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@subotic:matrix.org&gt; maybe it should say `above conditions are not met`? This is how I understood it a least.

oh that might also make more sense. but i dont see any conditions (there) the 3 above elements are just decoding instructions so I&#x27;m still confused</div>
<div class='msg'><time>2024‑08‑02 11:28</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@subotic:matrix.org&gt; maybe it should say `above conditions are not met`? This is how I understood it a least.

 * oh that might also make more sense. but i dont see any conditions (there) the 3 above elements are just definitions</div>
<div class='msg'><time>2024‑08‑02 11:28</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * oh that might also make more sense. but i dont see any conditions (there) the 3 above elements are just definitions, that&#x27;s part of the reason why i&#x27;m confused</div>
<div class='msg'><time>2024‑08‑02 11:32</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>: &gt; &lt;@prematurata:matrix.org&gt; oh that might also make more sense. but i dont see any conditions (there) the 3 above elements are just definitions, that&#x27;s part of the reason why i&#x27;m confused

hmm, good point.</div>
<div class='msg'><time>2024‑08‑02 12:32</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: I interpreted it as `if the definitions can&#x27;t be computed`</div>
<div class='msg'><time>2024‑08‑02 12:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@cisco:parity.io&gt; I interpreted it as `if the definitions can&#x27;t be computed`

Yes</div>
<div class='msg'><time>2024‑08‑02 12:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The condition it is refering to is the equality of v_x.</div>
<div class='msg'><time>2024‑08‑02 12:36</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@cisco:parity.io&gt; I interpreted it as `if the definitions can&#x27;t be computed`

I thought about that as well ... as far as I can think of there is only one case when that cannot be computed. and if the next istruction is just right after the one we&#x27;re evaluating</div>
<div class='msg'><time>2024‑08‑02 12:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Because of its inverse encoding (E^-1), there&#x27;s a possibility it can fail.</div>
<div class='msg'><time>2024‑08‑02 12:36</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: ha!</div>
<div class='msg'><time>2024‑08‑02 12:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The others can always be met.</div>
<div class='msg'><time>2024‑08‑02 12:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * The other conditions (equalities) can always be met.</div>
<div class='msg'><time>2024‑08‑02 12:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Because of its inverse encoding (E^-1), there&#x27;s a possibility it can fail (i.e. that there is no v_x which can satisfy the condition)</div>
<div class='msg'><time>2024‑08‑02 12:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: For a simple example, suppose I had defined v_x as i: 1&lt;i&lt;0.</div>
<div class='msg'><time>2024‑08‑02 12:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: then that condition would obviously not be possible to be met. No value exists which is both greater than 1 and less than 0.</div>
<div class='msg'><time>2024‑08‑02 12:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It&#x27;s not (always) about being evaluatable or computable.</div>
<div class='msg'><time>2024‑08‑02 12:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * It&#x27;s not (always) about being evaluatable or computable. Of course practical implementations must evaluate/compute, but formal specs only need specify relations and conditions.</div>
<div class='msg'><time>2024‑08‑02 12:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Therefore we say &quot;if the condition cannot be met&quot; rather than &quot;if you can&#x27;t compute the value&quot;.</div>
<div class='msg'><time>2024‑08‑02 12:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There are various reasons why a value may not be computable - perhaps you don&#x27;t have the operands, perhaps you don&#x27;t know an algorithm to do it... </div>
<div class='msg'><time>2024‑08‑02 12:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * There are various reasons why a value &quot;may not be computable&quot; - perhaps you don&#x27;t have the operands, perhaps you don&#x27;t know an algorithm to do it... there are practical concerns.</div>
<div class='msg'><time>2024‑08‑02 12:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * There are various reasons why a value &quot;may not be computable&quot; - perhaps you don&#x27;t have the operands, perhaps you don&#x27;t know an algorithm to do it... there are practical concerns since computable is practical endeavour.</div>
<div class='msg'><time>2024‑08‑02 12:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Meeting a condition is not a practical endeavour. It&#x27;s purely theoretical.</div>
<div class='msg'><time>2024‑08‑02 12:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * There are various reasons why a value &quot;may not be computable&quot; - perhaps you don&#x27;t have the operands, perhaps you don&#x27;t know an algorithm to do it, perhaps the CPU is broken... there are practical concerns since computable is practical endeavour.</div>
<div class='msg'><time>2024‑08‑02 12:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * There are various reasons why a value &quot;may not be computable&quot; - perhaps you don&#x27;t have the operands, perhaps you don&#x27;t know an algorithm to do it, perhaps the CPU is broken... there are practical concerns since computable is practical endeavour. We wouldn&#x27;t want to define the protocol in terms of practical concerns.</div>
<div class='msg'><time>2024‑08‑02 12:56</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: i am still trying to wrap my head around that. so i can&#x27;t really find a practical  `l_x` for which `E_lx` is not computable. (not considering the case where the arguments input size is zero or formally `ζı+1 ∈ ϖ`).

I understand the reasoning about `condition` vs `computable` but, feel free to correct me. Since the `E^-1` is the inverse of `E` for which  there is no input for which `E` fails to produce output... then I&#x27;d expect (always mathematically speaking) that if the inverse function is &quot;called&quot; with a member of the output set of `E`which is **Y**l (aka a sequence of `l`octects) then, unless otherwise specified, there would be no reason to believe the inverse fails for some inputs.


</div>
<div class='msg'><time>2024‑08‑02 12:58</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: So if my reasoning is correct, then I&#x27;d propose that either the `disclaymner</div>
<div class='msg'><time>2024‑08‑02 12:58</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * So if my reasoning is correct, then I&#x27;d propose that either the \`disclaymer` is set to be </div>
<div class='msg'><time>2024‑08‑02 12:59</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * So if my reasoning is correct, then I&#x27;d propose that either the \`disclaymer\` is set to be `global` or considered to be removed. What confused me is that (and I can still be wrong) there is no way for the previous condition to be `incomputable` </div>
<div class='msg'><time>2024‑08‑02 14:15</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * So if my reasoning is correct, then I&#x27;d propose that either the `disclaymer` is `global`. If, for some reason, the defined values cannot be computed then a panic should occur</div>
<div class='msg'><time>2024‑08‑02 15:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Well, there are sequences of octets which when passes into E^-1 do not provide a value in N_(2^32), right?</div>
<div class='msg'><time>2024‑08‑02 15:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Well, there are sequences of octets which when passed into E^-1 do not provide a value in N_(2^32), right?</div>
<div class='msg'><time>2024‑08‑02 15:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: As such the decoding may fail. </div>
<div class='msg'><time>2024‑08‑02 15:18</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@gav:polkadot.io&gt; Well, there are sequences of octets which when passed into E^-1 do not provide a value in N_(2^32), right?

yes you&#x27;re right. but if you mean when the input sequence is longer than 4 octects... well that should be enforced by the `min</div>
<div class='msg'><time>2024‑08‑02 15:18</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@gav:polkadot.io&gt; Well, there are sequences of octets which when passed into E^-1 do not provide a value in N_(2^32), right?

 * yes you&#x27;re right. but if you mean when the input sequence is longer than 4 octects... well that should be enforced by the `min`</div>
<div class='msg'><time>2024‑08‑02 15:18</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * yes you&#x27;re right. but if you mean when the input sequence is longer than 4 octects... well that should be enforced by the `min` in the `l_x`</div>
<div class='msg'><time>2024‑08‑02 15:20</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * yes you&#x27;re right. but if you mean when the input sequence is longer than 4 octects... well that should be enforced by the `min` in `l_x` definition . </div>
<div class='msg'><time>2024‑08‑02 15:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I don’t mean that. </div>
<div class='msg'><time>2024‑08‑02 15:37</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: I don&#x27;t see how little endian encoding which is defined in 273 has a way for its inverse to not produce a value in `N_(2^32)`. </div>
<div class='msg'><time>2024‑08‑02 15:38</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * I don&#x27;t see how little endian encoding which is defined in 273 has a way for its inverse to produce a value **not** in `N_(2^32)`.</div>
<div class='msg'><time>2024‑08‑02 15:43</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * I don&#x27;t see how little endian encoding which is defined in 273 has a way for its inverse to produce a value **not** in `N_(2^32)`. when subscripted with `4`</div>
<div class='msg'><time>2024‑08‑02 15:44</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * I don&#x27;t see how little endian encoding which is defined in 273 has a way for its inverse to produce a value **not** in `N_(2^32)`. when subscripted with `&lt;=4`</div>
<div class='msg'><time>2024‑08‑02 15:44</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * I don&#x27;t see how little endian encoding which is defined in 273 has a way for its inverse to produce a value **not** in `N_(2^32)`. when subscripted with `x` being `0&lt;=x&lt;=4`</div>
<div class='msg'><time>2024‑08‑02 17:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes indeed.</div>
<div class='msg'><time>2024‑08‑02 17:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (Until 0.3 series with the PVM changes that equation was originally the decode function without the subscript, implying that it could fail to decode. That&#x27;s no longer the case so I&#x27;ll remove the now-superfluous disclaimer.)</div>
<div class='msg'><time>2024‑08‑02 18:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Yes indeed: https://github.com/gavofyork/graypaper/pull/54/commits/d474ed4da1032cfa1398c11afc0b3edf37f3934b</div>
<div class='msg'><time>2024‑08‑04 10:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 0.3.3 released with all the recent corrections: https://github.com/gavofyork/graypaper/releases/tag/v0.3.3</div>
<div class='msg'><time>2024‑08‑04 10:17</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Heads-up: 0.4 will likely include a formalisation of #57 (dependent on final review).</div>
<div class='msg'><time>2024‑08‑05 03:23</time>&ensp;<span class='u' style='color:#65c4c9'>jay-chrawnna</span>: we&#x27;ve released the clips of the Belgium lecture for those using the YouTube [playlist](https://www.youtube.com/watch?v=wbnTnBQNDr4&amp;list=PLwcnAOKMj-Ab7sDej2P4peqGxu2mTGYNy). Because the Gray Paper is a living project, we opt to title &amp; number the clips based on the version of the graypaper at time of lecture.

You&#x27;ll find them on graypaper.com soon™️</div>
<div class='msg'><time>2024‑08‑05 04:35</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: A minor inconsistency, `e` is used as epoch index for Safrole, but`m` is used as epoch index for validator activity statistics</div>
<div class='msg'><time>2024‑08‑05 04:35</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-08-05 at 4.35.22 PM.png</div>
<div class='msg'><time>2024‑08‑05 04:35</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-08-05 at 4.35.34 PM.png</div>
<div class='msg'><time>2024‑08‑05 04:43</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: the state deps graph for `π` seems to be incomplete?</div>
<div class='msg'><time>2024‑08‑05 04:43</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-08-05 at 4.43.18 PM.png</div>
<div class='msg'><time>2024‑08‑05 04:43</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-08-05 at 4.43.35 PM.png</div>
<div class='msg'><time>2024‑08‑05 04:43</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: it doesn&#x27;t have `Hi`</div>
<div class='msg'><time>2024‑08‑05 06:06</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: is this a typo? (this part is super confusing because judgements now renamed to verdicts but there is still a variable j used in verdicts)</div>
<div class='msg'><time>2024‑08‑05 06:07</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-08-05 at 6.06.57 PM.png</div>
<div class='msg'><time>2024‑08‑05 06:07</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-08-05 at 6.07.17 PM.png</div>
<div class='msg'><time>2024‑08‑05 06:12</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-08-05 at 6.12.08 PM.png</div>
<div class='msg'><time>2024‑08‑05 06:13</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I am also unsure what exactly is the squared part mean here. It reads like epoch index minus 2? But it doesn&#x27;t make much sense to me here</div>
<div class='msg'><time>2024‑08‑05 06:15</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I guess it means that value `a` must be either the current epoch index or the previous one?</div>
<div class='msg reply'><time>2024‑08‑05 09:06</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: yes 11:28 https://www.youtube.com/watch?v=iMAqVPGppbs&amp;t=688s</div>
<div class='msg reply'><time>2024‑08‑05 09:09</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: thanks. this reminds me I should finish watching the jam lectures </div>
<div class='msg'><time>2024‑08‑05 06:23</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>: In 226, shouldn&#x27;t the o</div>
<div class='msg reply'><time>2024‑08‑05 07:52</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: &gt; Specifically, the machine does not halt, the instruction counter increments by one</div>
<div class='msg reply'><time>2024‑08‑05 07:52</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: so during normal execution, the counter will be updated</div>
<div class='msg reply'><time>2024‑08‑05 07:52</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: we don&#x27;t want to update it twice, or make an exception case here</div>
<div class='msg reply'><time>2024‑08‑05 08:05</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>: so this means that the first case is covered through (220). Got it. Thanks!</div>
<div class='msg reply'><time>2024‑08‑05 09:49</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: &gt; &lt;@xlchen:matrix.org&gt; we don&#x27;t want to update it twice, or make an exception case here

Yes but following the formalism if we go to `b` we execute it first. We don&#x27;t do `b + 1 + skip(b)`, we first go to `b`and execute it. So I think what Ivan said makes sense 🤔</div>
<div class='msg reply'><time>2024‑08‑05 23:13</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: the instruction updates the counter and that&#x27;s it. </div>
<div class='msg reply'><time>2024‑08‑05 23:13</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: and the usual steps continues. i.e. increment the counter and execute the next instruction</div>
<div class='msg reply'><time>2024‑08‑08 10:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: This is correct.</div>
<div class='msg'><time>2024‑08‑05 06:24</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>:  * In 226, shouldn&#x27;t the iota in the first case be `i + 1 + skip(i)`?</div>
<div class='msg'><time>2024‑08‑05 06:24</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>: image.png</div>
<div class='msg'><time>2024‑08‑05 10:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; is this a typo? (this part is super confusing because judgements now renamed to verdicts but there is still a variable j used in verdicts)

Yes. I’ve cleared up the naming. </div>
<div class='msg'><time>2024‑08‑05 10:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Disputes includes verdicts and offenders. </div>
<div class='msg'><time>2024‑08‑05 10:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Verdicts are made up of individual judgements. </div>
<div class='msg'><time>2024‑08‑05 10:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Disputes includes verdicts and offenders (faults and culprits). </div>
<div class='msg'><time>2024‑08‑05 10:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (In previous versions, we did not have offenders and judgements and verdicts were both called judgements, confusingly)</div>
<div class='msg'><time>2024‑08‑05 10:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Verdicts are made up of individual judgements (which is a vote and a valid signature). </div>
<div class='msg'><time>2024‑08‑05 12:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Disputes includes verdicts (a final aggregated decision on whether a WR was bad) and offenders (proofs of those validators who issued judgements against such a verdict).</div>
<div class='msg'><time>2024‑08‑05 12:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Verdicts are made up of individual judgements (which is a vote and a validator&#x27;s signature).</div>
<div class='msg'><time>2024‑08‑05 12:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * (In previous versions, we did not have offenders, and both judgements and verdicts were called judgements, confusingly)</div>
<div class='msg'><time>2024‑08‑06 09:21</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: Hey there! The last couple of days I&#x27;ve been working on a tool that would help to read and annotate the Gray Paper. Looking for some feedback:
https://graypaper.fluffylabs.dev/

On the top of the priority list to implement is to display the notes within the document and migrate them between versions. I found myself having a lot of notes on a printed version, but they are hard to maintain when the document keeps changing, hence the website.

Another important feature for me is the ability to share a link to a selection - I&#x27;ve noticed here that many people share screenshots (which I believe is still good), but if the screenshots were augmented with such a link it&#x27;s easier for others to find the context of the  discussion (and the graypaper version the quote is coming from).

Curious to hear what would be important for you or what you&#x27;d like to see improved. The (pretty hacky) code is on github, so feel free to file an issue or a PR there.</div>
<div class='msg reply'><time>2024‑08‑06 09:44</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: The linking feature is awesome! I tried a few things to have links to a specific formular but this is top. Does it search for the text or how does it resolve a link to a spot in the paper?</div>
<div class='msg reply'><time>2024‑08‑06 09:56</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: &gt; &lt;@oliver.tale-yazdi:parity.io&gt; The linking feature is awesome! I tried a few things to have links to a specific formular but this is top. Does it search for the text or how does it resolve a link to a spot in the paper?

As mentioned earlier it&#x27;s pretty hacky :D The PDF is converted to HTML and it has a very specific structure. The link saves the HTML nodes that are selected and then searches for these exact nodes  when loaded. I&#x27;m still trying to figure out how to best &quot;migrate&quot; the selection from one version to another, but I&#x27;m positive I&#x27;ll figure something out, given I have full information about the selection (including page, section, subsection, gp version and the text content)</div>
<div class='msg reply'><time>2024‑08‑06 09:57</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: The migration to newer version will most likely need some fuzzy searching if the exact text is not found, but at least we can limit that to some particular section.</div>
<div class='msg reply'><time>2024‑08‑06 09:58</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: We are also working on using synctex to map PDF/HTML selection to raw latex sources as another option.</div>
<div class='msg reply'><time>2024‑08‑06 10:07</time>&ensp;<span class='u' style='color:#ad33c0'>kianenigma</span>: This is super useful, thanks for sharing! will start using it and share feedback :) </div>
<div class='msg reply'><time>2024‑08‑06 10:28</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: Awesome tool! I also took a lot of notes on a printed version but all the changes make my notes harder to find.

You could maybe show the visual diffs between the different versions and associate notes to a particular version if stuff changed</div>
<div class='msg'><time>2024‑08‑06 12:09</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: </div>
<div class='msg'><time>2024‑08‑06 12:10</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: </div>
<div class='msg'><time>2024‑08‑06 12:10</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: </div>
<div class='msg'><time>2024‑08‑06 12:11</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: </div>
<div class='msg'><time>2024‑08‑06 12:11</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: </div>
<div class='msg'><time>2024‑08‑06 12:14</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: Hello, i believe there is no formalism on how to properly encode/decode workresults. The `o` term is either `byte array` or `enum`. (123 and 124) .

considering the `Eg` exstrinsic is a tuple containing workreport `138` and `119`. And that there is no specific formalism for term `o` in 123 on appendix `C`, i believe that note `20` at page `49` might also apply here?</div>
<div class='msg'><time>2024‑08‑06 12:25</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: </div>
<div class='msg'><time>2024‑08‑06 12:25</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * ~Hello, i believe there is no formalism on how to properly encode/decode workresults. The `o` term is either `byte array` or `enum`. (123 and 124) .

considering the `Eg` exstrinsic is a tuple containing workreport `138` and `119`. And that there is no specific formalism for term `o` in 123 on appendix `C`, i believe that note `20` at page `49` might also apply here?~</div>
<div class='msg'><time>2024‑08‑06 12:25</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * ~~Hello, i believe there is no formalism on how to properly encode/decode workresults. The `o` term is either `byte array` or `enum`. (123 and 124) .

considering the `Eg` exstrinsic is a tuple containing workreport `138` and `119`. And that there is no specific formalism for term `o` in 123 on appendix `C`, i believe that note `20` at page `49` might also apply here?~~</div>
<div class='msg'><time>2024‑08‑06 12:25</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * &lt;del&gt;~~Hello, i believe there is no formalism on how to properly encode/decode workresults. The `o` term is either `byte array` or `enum`. (123 and 124) .&lt;/del&gt;

&lt;del&gt;considering the `Eg` exstrinsic is a tuple containing workreport `138` and `119`. And that there is no specific formalism for term `o` in 123 on appendix `C`, i believe that note `20` at page `49` might also apply here?~~&lt;/del&gt;</div>
<div class='msg'><time>2024‑08‑06 13:14</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: image.png</div>
<div class='msg'><time>2024‑08‑06 13:15</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: is (284) correct? it misses the `segment-root` from the `S` set</div>
<div class='msg'><time>2024‑08‑06 17:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Incorrect. Will be fixed!</div>
<div class='msg'><time>2024‑08‑06 17:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Should appear after the regular erasure root. </div>
<div class='msg'><time>2024‑08‑07 13:01</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: AFAICT the PVM program should run up until it reaches an invalid instruction. What&#x27;s the reason for that? Couldn&#x27;t programs with invalid instructions be cheaply rejected during some initial (linear) validation based on the instruction mask? We also have well-defined trap instruction to terminate the program, so no need for that to panic (like there was in EVM afair).

The only reasons I could think of is:
1. Avoid the need of pre-validation completely (i.e. don&#x27;t assume there is anything like that in GP)
2. Support some future extensions?

Is there anything I&#x27;m missing here? Perhaps the compilers generate a code with invalid instructions in case of panic?</div>
<div class='msg'><time>2024‑08‑07 14:18</time>&ensp;<span class='u' style='color:#c77c36'>luke_f</span>: image.png</div>
<div class='msg'><time>2024‑08‑07 14:22</time>&ensp;<span class='u' style='color:#c77c36'>luke_f</span>: hello.
i think there is a mistake in recent history -  equation 83
**the subscript s is supposed to be subscript x**

since *s* is an availability specification, that does no have a *p* sub-component (eq 122)
*x*, however is refinement context , that does have *p* component that is a hash (eq 121)
</div>
<div class='msg'><time>2024‑08‑07 14:30</time>&ensp;<span class='u' style='color:#c77c36'>luke_f</span>:  * hello.
i think there is a mistake in recent history -  equation 83
**the subscript s is supposed to be subscript x**

since _s_ is an availability specification, that does no have a _p_ sub-component (eq 122)
_x_, however is refinement context , that does have _p_ component that is a hash (eq 121)


or maybe it refers to *S* subscript *h*? the work package hash?</div>
<div class='msg'><time>2024‑08‑07 17:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It refers to the work package hash in the specification component. </div>
<div class='msg'><time>2024‑08‑08 01:58</time>&ensp;<span class='u' style='color:#c77c36'>luke_f</span>: &gt; &lt;@gav:polkadot.io&gt; It refers to the work package hash in the specification component.

thank you</div>
<div class='msg'><time>2024‑08‑08 07:26</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: &gt; &lt;@tomusdrw:matrix.org&gt; AFAICT the PVM program should run up until it reaches an invalid instruction. What&#x27;s the reason for that? Couldn&#x27;t programs with invalid instructions be cheaply rejected during some initial (linear) validation based on the instruction mask? We also have well-defined trap instruction to terminate the program, so no need for that to panic (like there was in EVM afair).
&gt; 
&gt; The only reasons I could think of is:
&gt; 1. Avoid the need of pre-validation completely (i.e. don&#x27;t assume there is anything like that in GP)
&gt; 2. Support some future extensions?
&gt; 
&gt; Is there anything I&#x27;m missing here? Perhaps the compilers generate a code with invalid instructions in case of panic?

@gav any comments on this one? My current read of the GP is that it&#x27;s fine to have programs with invalid instructions, since they obviously might never be reached in code and we still need to panic only if that particular instruction is reached during execution. And obviously that&#x27;s payed for. 
However I&#x27;m thinking if it would be &quot;less wasteful&quot; to disallow programs with invalid instructions to be executed at all. But perhaps it&#x27;s over complication or not practical for some reasons yet unknown for me?</div>
<div class='msg'><time>2024‑08‑08 07:27</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: image.png</div>
<div class='msg'><time>2024‑08‑08 07:27</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: image.png</div>
<div class='msg'><time>2024‑08‑08 07:34</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: I think there&#x27;s a typo in 59. k_b should be `k_e`</div>
<div class='msg'><time>2024‑08‑08 08:52</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: image.png</div>
<div class='msg'><time>2024‑08‑08 08:52</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: and maybe this is also a typo </div>
<div class='msg'><time>2024‑08‑08 08:53</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * and maybe this is also a typo... `posterior m` can be &gt; than `Y` but then `|ya|` would not be = to `E`... what I think we want to make sure is that the *current* `m` is &gt; than `Y` so that we know the lottery &quot;time&quot; is over</div>
<div class='msg'><time>2024‑08‑08 09:11</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>:  * gav:  any comments on this one? My current read of the GP is that it&#x27;s fine to have programs with invalid instructions, since they obviously might never be reached in code and we still need to panic only if that particular instruction is reached during execution. And obviously that&#x27;s payed for.
However I&#x27;m thinking if it would be &quot;less wasteful&quot; to disallow programs with invalid instructions to be executed at all. But perhaps it&#x27;s over complication or not practical for some reasons yet unknown for me?</div>
<div class='msg'><time>2024‑08‑08 10:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@tomusdrw:matrix.org&gt; AFAICT the PVM program should run up until it reaches an invalid instruction. What&#x27;s the reason for that? Couldn&#x27;t programs with invalid instructions be cheaply rejected during some initial (linear) validation based on the instruction mask? We also have well-defined trap instruction to terminate the program, so no need for that to panic (like there was in EVM afair).
&gt; 
&gt; The only reasons I could think of is:
&gt; 1. Avoid the need of pre-validation completely (i.e. don&#x27;t assume there is anything like that in GP)
&gt; 2. Support some future extensions?
&gt; 
&gt; Is there anything I&#x27;m missing here? Perhaps the compilers generate a code with invalid instructions in case of panic?

Point 1. </div>
<div class='msg'><time>2024‑08‑08 10:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The PVM is designed to be linear complexity in terms of execution, not program size. </div>
<div class='msg'><time>2024‑08‑08 10:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * The PVM is designed to be linear complexity in terms of execution steps, not program size. </div>
<div class='msg'><time>2024‑08‑08 10:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; I think there&#x27;s a typo in 59. k_b should be `k_e`

Correct. </div>
<div class='msg'><time>2024‑08‑08 10:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; I think there&#x27;s a typo in 59. k_b should be `k_e`

* Correct. Will be in next round of corrections thanks</div>
<div class='msg'><time>2024‑08‑08 10:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; and maybe this is also a typo... `posterior m` can be &gt; than `Y` but then `|ya|` would not be = to `E`... what I think we want to make sure is that the *current* `m` is &gt; than `Y` so that we know the lottery &quot;time&quot; is over

Yeah that is prior m on the latest GP. </div>
<div class='msg'><time>2024‑08‑08 10:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; and maybe this is also a typo... `posterior m` can be &gt; than `Y` but then `|ya|` would not be = to `E`... what I think we want to make sure is that the *current* `m` is &gt; than `Y` so that we know the lottery &quot;time&quot; is over

 * Yeah that is already corrected to the prior m on the latest GP. </div>
<div class='msg'><time>2024‑08‑08 12:23</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@gav:polkadot.io&gt; Yeah that is already corrected to the prior m on the latest GP.

oops sorry. i must have missed one release</div>
<div class='msg'><time>2024‑08‑08 12:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@tomusdrw:matrix.org&gt; AFAICT the PVM program should run up until it reaches an invalid instruction. What&#x27;s the reason for that? Couldn&#x27;t programs with invalid instructions be cheaply rejected during some initial (linear) validation based on the instruction mask? We also have well-defined trap instruction to terminate the program, so no need for that to panic (like there was in EVM afair).
&gt; 
&gt; The only reasons I could think of is:
&gt; 1. Avoid the need of pre-validation completely (i.e. don&#x27;t assume there is anything like that in GP)
&gt; 2. Support some future extensions?
&gt; 
&gt; Is there anything I&#x27;m missing here? Perhaps the compilers generate a code with invalid instructions in case of panic?

(There are actually a number of exit conditions, an illegal instruction is only one of them and I wouldn&#x27;t expect it to happen in production.)</div>
<div class='msg'><time>2024‑08‑09 12:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: [v0.3.4](https://github.com/gavofyork/graypaper/releases/) is out with the latest corrections.</div>
<div class='msg'><time>2024‑08‑09 12:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * [v0.3.4](https://github.com/gavofyork/graypaper/releases/) is out with the latest corrections. Nothing particularly new in there.</div>
<div class='msg'><time>2024‑08‑09 14:09</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: </div>
<div class='msg'><time>2024‑08‑09 14:11</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: In the serialization definitions, there is the variable-size prefix 29-bit natural serialization function E4∗ \se_{4*}


But I don&#x27;t see it being used anywhere. I see only mentions to E4 (without the *) \se_4  

Should we use \se_{4*} by default when we see \se_4 ?</div>
<div class='msg reply'><time>2024‑08‑09 14:12</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Screenshot 2024-08-09 at 15.11.50.png</div>
<div class='msg reply'><time>2024‑08‑09 14:12</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Screenshot 2024-08-09 at 15.12.02.png</div>
<div class='msg'><time>2024‑08‑09 15:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; In the serialization definitions, there is the variable-size prefix 29-bit natural serialization function E4∗ \se_{4*}
&gt; 
&gt; 
&gt; But I don&#x27;t see it being used anywhere. I see only mentions to E4 (without the *) \se_4  
&gt; 
&gt; Should we use \se_{4*} by default when we see \se_4 ?

No. When you see \se_4, use \se_4. The variable-length encoding functions are not presently used. They might be used in the future but for now you obviously don’t need to implement them to build a conformant implementation. </div>
<div class='msg'><time>2024‑08‑09 21:12</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: </div>
<div class='msg'><time>2024‑08‑11 17:19</time>&ensp;<span class='u' style='color:#d43250'>finsig</span>: For integer encoding, eq275, there are values of x that satisfy 2^7*l &lt;= x &lt; 2^7(l+1) but do not correctly encode with length (l). For example, 2^14-1 satisfies the criteria for length 1, 2^7 &lt;= 2^14-1 &lt; 2^14, and encodes to bytes [255]. However, it requires length 2 bytes [255,63] = 2^14-1. Should the criteria instead be: 2^7*(l -1) &lt;= x &lt; 2^(7 * l) </div>
<div class='msg'><time>2024‑08‑11 17:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@finsig:matrix.org&gt; For integer encoding, eq275, there are values of x that satisfy 2^7*l &lt;= x &lt; 2^7(l+1) but do not correctly encode with length (l). For example, 2^14-1 satisfies the criteria for length 1, 2^7 &lt;= 2^14-1 &lt; 2^14, and encodes to bytes [255]. However, it requires length 2 bytes [255,63] = 2^14-1. Should the criteria instead be: 2^7*(l -1) &lt;= x &lt; 2^(7 * l) 

I’m not sure what you mean. It satisfies the criteria for l=1, which implies it needs two bytes: the discriminator and most-significant partial quantity in the first byte (192), together with least significant byte in the second (255), giving [192,255]</div>
<div class='msg'><time>2024‑08‑11 17:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@finsig:matrix.org&gt; For integer encoding, eq275, there are values of x that satisfy 2^7*l &lt;= x &lt; 2^7(l+1) but do not correctly encode with length (l). For example, 2^14-1 satisfies the criteria for length 1, 2^7 &lt;= 2^14-1 &lt; 2^14, and encodes to bytes [255]. However, it requires length 2 bytes [255,63] = 2^14-1. Should the criteria instead be: 2^7*(l -1) &lt;= x &lt; 2^(7 * l) 

* I’m not sure what you mean. It satisfies the criteria for l=1, which implies it needs two bytes: the discriminator summed with the most-significant bits in the first byte (128 + 64 = 192), together with least significant byte in the second (255), giving [192,255]</div>
<div class='msg'><time>2024‑08‑11 17:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@finsig:matrix.org&gt; For integer encoding, eq275, there are values of x that satisfy 2^7*l &lt;= x &lt; 2^7(l+1) but do not correctly encode with length (l). For example, 2^14-1 satisfies the criteria for length 1, 2^7 &lt;= 2^14-1 &lt; 2^14, and encodes to bytes [255]. However, it requires length 2 bytes [255,63] = 2^14-1. Should the criteria instead be: 2^7*(l -1) &lt;= x &lt; 2^(7 * l) 

* I’m not sure what you mean. It satisfies the criteria for l=1, which implies it needs two bytes: the discriminator summed with the most-significant bits in the first byte (128 + 32 = 160), together with least significant byte in the second (255), giving [160,255]</div>
<div class='msg'><time>2024‑08‑11 17:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@finsig:matrix.org&gt; For integer encoding, eq275, there are values of x that satisfy 2^7*l &lt;= x &lt; 2^7(l+1) but do not correctly encode with length (l). For example, 2^14-1 satisfies the criteria for length 1, 2^7 &lt;= 2^14-1 &lt; 2^14, and encodes to bytes [255]. However, it requires length 2 bytes [255,63] = 2^14-1. Should the criteria instead be: 2^7*(l -1) &lt;= x &lt; 2^(7 * l) 

* I’m not sure what you mean. It satisfies the criteria for l=1, which implies it needs two bytes: the discriminator summed with the most-significant bits in the first byte (128 + 63 = 191), together with least significant byte in the second (255), giving [191,255]</div>
<div class='msg'><time>2024‑08‑12 01:59</time>&ensp;<span class='u' style='color:#d43250'>finsig</span>: &gt; &lt;@gav:polkadot.io&gt; I’m not sure what you mean. It satisfies the criteria for l=1, which implies it needs two bytes: the discriminator summed with the most-significant bits in the first byte (128 + 63 = 191), together with least significant byte in the second (255), giving [191,255]

sorry, my mistake. I understand now.</div>
<div class='msg'><time>2024‑08‑12 10:04</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: Screenshot 2024-08-12 at 11.59.40.png</div>
<div class='msg'><time>2024‑08‑12 10:04</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: Screenshot 2024-08-12 at 12.00.37.png</div>
<div class='msg'><time>2024‑08‑12 10:04</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: The text in the guarantees extrinsic and the Block Serialization mention a core-index, but it looks like i was moved into the work-report. So just the text and encoding logic needs fixing?</div>
<div class='msg'><time>2024‑08‑12 11:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: yes</div>
<div class='msg'><time>2024‑08‑12 12:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Yes: https://github.com/gavofyork/graypaper/commit/27947d73ab593597dcf4f41c036bd1eb68fd6ffe</div>
<div class='msg'><time>2024‑08‑14 02:31</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: image.png</div>
<div class='msg'><time>2024‑08‑14 02:31</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: davxy: Do you have a snippet of code that represents the above computation?
</div>
<div class='msg reply'><time>2024‑08‑14 03:10</time>&ensp;<span class='u' style='color:#6ecf94'>qiwei</span>: I think it&#x27;s just https://github.com/davxy/bandersnatch-vrfs-spec/blob/57f89545b825b8f032180dff59cf9d360d43d0dd/example/src/main.rs#L116 

```
let mut buf = Vec::new();

verifier.commitment.serialize_compressed(&amp;mut buf).unwrap();
```</div>
<div class='msg reply'><time>2024‑08‑14 08:08</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: ^ this</div>
<div class='msg reply'><time>2024‑08‑14 09:02</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Excellent, we guessed right =)</div>
<div class='msg'><time>2024‑08‑14 02:33</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: image.png</div>
<div class='msg'><time>2024‑08‑14 02:35</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * davxy: Do you have a snippet of code that represents the above computation? (used in Safrole on a new epoch)</div>
<div class='msg'><time>2024‑08‑14 02:35</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * davxy: Do you have a snippet of code that represents the above computation?  This &quot;ring root&quot; is used in a new epoch as per:</div>
<div class='msg'><time>2024‑08‑14 03:07</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Is it possible to have a full run of a &quot;tiny&quot; chain (eg V=6, E=12, Y=8) with a full genesis config with predefine Alice/Bob/.. /Fergie keys like   https://substrate.stackexchange.com/questions/41/what-are-the-predefined-accounts-alice-bob-etc</div>
<div class='msg'><time>2024‑08‑14 03:07</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * davxy: Do you have a snippet of code that represents the above computation?  Would like to check our assumptions.  This &quot;ring root&quot; is used in a new epoch as per:</div>
<div class='msg'><time>2024‑08‑14 03:07</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Is it possible to have a full run  of say, 4 epochs of a &quot;tiny&quot; chain (eg V=6, E=12, Y=8) with a full genesis config with predefined Alice/Bob/.. /Fergie keys like   https://substrate.stackexchange.com/questions/41/what-are-the-predefined-accounts-alice-bob-etc</div>
<div class='msg'><time>2024‑08‑14 03:08</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Is it possible for you to provide a full run of blocks for 4 epochs of a &quot;tiny&quot; chain (eg V=6, E=12, Y=8) with a complete genesis config with predefined Alice/Bob/.. /Fergie keys like   https://substrate.stackexchange.com/questions/41/what-are-the-predefined-accounts-alice-bob-etc</div>
<div class='msg'><time>2024‑08‑14 22:56</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: </div>
<div class='msg'><time>2024‑08‑14 22:57</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: </div>
<div class='msg'><time>2024‑08‑14 22:57</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: </div>
<div class='msg'><time>2024‑08‑14 22:59</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * gav: Doesn&#x27;t host function `write` need a &quot;s&quot; register input like `read` has in `\omega_0`?</div>
<div class='msg'><time>2024‑08‑14 23:07</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * gav: Doesn&#x27;t host function `write` need a &quot;s&quot; register input like `read` has in `\omega_0`?   </div>
<div class='msg'><time>2024‑08‑14 23:12</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: For `import` GP says &quot;This process may in fact be lazy as the Refine function makes no usage of the data until the import hostcall is made.&quot; -- does this imply that  PVM interpreters should &quot;page fault&quot; when hitting an &quot;import&quot;?  Is this the only host function having a lazy / page fault or would there be others (say, export [though] I imagine it would be the last thing being done), in interacting with the DA systems?</div>
<div class='msg'><time>2024‑08‑14 23:13</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * For `import` GP says &quot;This process may in fact be lazy as the Refine function makes no usage of the data until the import hostcall is made.&quot; -- does this imply that  PVM interpreters should &quot;page fault&quot; when hitting an &quot;import&quot;?  Is this the only host function having a lazy / page fault or would there be others (say, `export` \[though I imagine it would be the last thing being done]), in interacting with the DA systems?</div>
<div class='msg'><time>2024‑08‑14 23:17</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: For Epoch Markers, at the start of Section 5.1 you have &quot;If not ∅, then the epoch marker specifies key and entropy relevant to the following epoch in case the ticket contest does not complete adequately (a very much unexpected eventuality)&quot; but then in equation (72) you have something that appears contradictory:
</div>
<div class='msg'><time>2024‑08‑14 23:17</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: image.png</div>
<div class='msg'><time>2024‑08‑14 23:19</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Does the epoch marker appear on rare occasions (only when the ticket contest does not complete adequately) or on every new epoch (what (72) implies)</div>
<div class='msg'><time>2024‑08‑15 00:19</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * For `import` GP says &quot;This process may in fact be lazy as the Refine function makes no usage of the data until the import hostcall is made.&quot; -- does this imply that  PVM interpreters should &quot;page fault&quot; when hitting an &quot;import&quot; instruction?  Is this the only host function having a lazy evaluation / page fault or would there be others (say, `export` \[though I imagine it would be the last thing being done\]), in interacting with the DA systems?</div>
<div class='msg'><time>2024‑08‑15 06:41</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: The epoch marker appears in the first block of every epoch</div>
<div class='msg'><time>2024‑08‑15 06:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; For `import` GP says &quot;This process may in fact be lazy as the Refine function makes no usage of the data until the import hostcall is made.&quot; -- does this imply that  PVM interpreters should &quot;page fault&quot; when hitting an &quot;import&quot; instruction?  Is this the only host function having a lazy evaluation / page fault or would there be others (say, `export` \[though I imagine it would be the last thing being done\]), in interacting with the DA systems?

It is merely noting that not all data may need to be imported ahead of time. </div>
<div class='msg'><time>2024‑08‑15 06:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; For `import` GP says &quot;This process may in fact be lazy as the Refine function makes no usage of the data until the import hostcall is made.&quot; -- does this imply that  PVM interpreters should &quot;page fault&quot; when hitting an &quot;import&quot;?  Is this the only host function having a lazy / page fault or would there be others (say, export [though] I imagine it would be the last thing being done), in interacting with the DA systems?

* It is merely noting that not all import data may need to be fetched ahead of the start of execution. </div>
<div class='msg'><time>2024‑08‑15 06:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It’s obvious, really, but I wanted to point it out as for M4 it will be necessary to parallelise execution with import segment fetching.</div>
<div class='msg'><time>2024‑08‑15 06:52</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; relevant to the following epoch in case the ticket contest does not complete adequately (a very much unexpected eventuality)&quot; 

It is rare that the ticket contest doesn&#x27;t complete successfully. If the contest is successful, then the previously announced epoch marker becomes irrelevant for the sake of slot assignments to validators.</div>
<div class='msg'><time>2024‑08‑15 11:35</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: To me it looks like the types of the sets in definition 101 are incompatible: `Lambda U Kappa` being a set of validator key tuples and `Psi-o` a set of Ed25519 keys:</div>
<div class='msg'><time>2024‑08‑15 11:36</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: gp.png</div>
<div class='msg'><time>2024‑08‑15 12:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@oliver.tale-yazdi:parity.io&gt; To me it looks like the types of the sets in definition 101 are incompatible: `Lambda U Kappa` being a set of validator key tuples and `Psi-o` a set of Ed25519 keys:

yeah - it should be the Ed25519 portions of lambda and kappa.</div>
<div class='msg'><time>2024‑08‑15 12:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Will be corrected in 0.3.5</div>
<div class='msg'><time>2024‑08‑15 12:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: i.e. `[k_e | k \in \lambda \cup \kappa]`</div>
<div class='msg'><time>2024‑08‑16 08:03</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: Screenshot 2024-08-16 at 10.02.44.png</div>
<div class='msg'><time>2024‑08‑16 08:03</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: Looking at the PVM&#x27;s standard program initialization. What is that `z`? I&#x27;ve identified all others and even read compiled pvm files successfully without mentioning it</div>
<div class='msg'><time>2024‑08‑16 09:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It’s the number of zeroed pages. </div>
<div class='msg'><time>2024‑08‑16 09:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: See right section of 4th row in initial memory layout. </div>
<div class='msg'><time>2024‑08‑16 09:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (246)</div>
<div class='msg'><time>2024‑08‑16 09:32</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: Thanks!</div>
<div class='msg'><time>2024‑08‑17 00:52</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: image.png</div>
<div class='msg'><time>2024‑08‑17 00:53</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: The H in &quot;H(a,t,h)&quot; should be a $\Lambda$ to match 92+94</div>
<div class='msg'><time>2024‑08‑17 00:54</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * For `historical_lookup` host function, the $H$ in $H({\bf a},t,h)$ should be a $\\Lambda$ to match 92+94 of Section 9.</div>
<div class='msg'><time>2024‑08‑17 00:55</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * For `historical_lookup` host function, the $H$ in $H({\\bf a},t,h)$ should be a $\\Lambda$ to match 92+94 of Section 9.

Any reason why you don&#x27;t just assign some opcodes to all the host functions?   Can just add 100 or 128 to the existing ones?</div>
<div class='msg'><time>2024‑08‑17 00:56</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * For `historical_lookup` host function, the $H$ in $H({\\bf a},t,h)$ should be a $\\Lambda$ to match 92+94 of Section 9.

Any reason why you don&#x27;t just assign some opcodes to all the host functions?   Can just add 100 or 128 to the existing ones, 13 becomes 113 or 141?</div>
<div class='msg'><time>2024‑08‑17 04:50</time>&ensp;<span class='u' style='color:#c77c36'>luke_f</span>: @davxy:matrix.org:  just to clarify, can we use the code in https://github.com/davxy/bandersnatch-vrfs-spec/tree/main/example ?</div>
<div class='msg'><time>2024‑08‑17 08:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; For `historical_lookup` host function, the $H$ in $H({\\bf a},t,h)$ should be a $\\Lambda$ to match 92+94 of Section 9.
&gt; 
&gt; Any reason why you don&#x27;t just assign some opcodes to all the host functions?   Can just add 100 or 128 to the existing ones, 13 becomes 113 or 141?

Then each of the contexts would need to be integrated and defined as part of the basic PVM, which is obviously a terrible idea. </div>
<div class='msg reply'><time>2024‑08‑17 12:21</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Understood.  We are using koute&#x27;s assembler to build  refine and accumulate toy cases (to do squaring [refine] and summing [accumulating]) to cover host function implementations by hand replacing &quot;17=0x11&quot; (fallthrough) with &quot;temporary opcodes&quot; in the 128 range since all host functions are instructions with no args (ie for historical_lookup, 141=0x8D).    

We can fork koute/polkavm and add our own little mapping for the 2 dozen host functions around here 
https://github.com/koute/polkavm/blob/41c74f966eea0b7670075082f1231c6eeef20fc2/crates/polkavm-common/src/program.rs#L1313
https://github.com/koute/polkavm/blob/41c74f966eea0b7670075082f1231c6eeef20fc2/crates/polkavm-common/src/assembler.rs#L308
Adding 128 is sufficient to avoid collisions, but seems clear that koute could surely follow the GP spec on these details?  
</div>
<div class='msg'><time>2024‑08‑17 08:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; For `historical_lookup` host function, the $H$ in $H({\\bf a},t,h)$ should be a $\\Lambda$ to match 92+94 of Section 9.
&gt; 
&gt; Any reason why you don&#x27;t just assign some opcodes to all the host functions?   Can just add 100 or 128 to the existing ones, 13 becomes 113 or 141?

On the first point, yes indeed - refactoring error and will be corrected in 0.3.5. </div>
<div class='msg'><time>2024‑08‑17 11:33</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@luke_f:matrix.org&gt; @davxy:matrix.org:  just to clarify, can we use the code in https://github.com/davxy/bandersnatch-vrfs-spec/tree/main/example ?

Yes. That example is compliant with what you need for JAM</div>
<div class='msg'><time>2024‑08‑17 13:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: On what details?</div>
<div class='msg'><time>2024‑08‑17 14:15</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I’m not really sure what you’re proposing, but if you mean to use opcodes which are not yet in use in place of host functions I would caution against it. Opcodes which are not in use should panic as an illegal instruction. If they do anything else then it will fail test vectors. </div>
<div class='msg'><time>2024‑08‑18 02:12</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: https://github.com/koute/polkavm/pull/156
has the idea.  Understand the caution, but not sure how else implementers can tackle host functions without something along these lines.    </div>
<div class='msg'><time>2024‑08‑18 02:13</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: https://github.com/koute/polkavm/blob/c2cd0e666c0bf68ecf457a4238ea072154e7bcff/tools/spectool/spec/src/hostfunctions/README.md</div>
<div class='msg'><time>2024‑08‑18 02:20</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * https://github.com/koute/polkavm/blob/32253a16f3f427fb829c2013615192e17324cbf3/tools/spectool/spec/src/hostfunctions/README.md</div>
<div class='msg'><time>2024‑08‑18 02:22</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * https://github.com/koute/polkavm/pull/156
has the idea.  Understand the caution, but not sure how else implementers can tackle implementing 23 host functions (8 or so critical to get the basics of DA/refine-accumulate: import, export, solicit, historical_lookup, read, write, lookup) without something along these lines.    </div>
<div class='msg'><time>2024‑08‑18 02:23</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * https://github.com/koute/polkavm/pull/156
has the idea.  Understand the caution, but not sure how else implementers can tackle implementing 23 host functions (8 or so critical to get the basics of DA+ a battery of refine-accumulate code for &quot;tiny&quot; JAM services: import, export, solicit, forget, historical\_lookup, read, write, lookup) without something along these lines. </div>
<div class='msg'><time>2024‑08‑18 07:13</time>&ensp;<span class='u' style='color:#c377dd'>mkchung</span>: In eq(93), the preimage appears to be of arbitrary size - which is then erasure encoded &amp; distributed in segments of size wc*ws to DA. But how does the E_p (lookup extrinsic) in section 12.1 (eq 155-158) able to know the length of the preimage? Without knowing the length, we probably cannot remove the padded zeros from the wc * ws segments. What am I missing?</div>
<div class='msg'><time>2024‑08‑18 10:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; https://github.com/koute/polkavm/pull/156
&gt; has the idea.  Understand the caution, but not sure how else implementers can tackle implementing 23 host functions (8 or so critical to get the basics of DA+ a battery of refine-accumulate code for &quot;tiny&quot; JAM services: import, export, solicit, forget, historical\_lookup, read, write, lookup) without something along these lines.

you&#x27;ll need to implement the host functions regardless. you&#x27;ll need to implement PVM too regardless.</div>
<div class='msg'><time>2024‑08‑18 10:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: so i don&#x27;t understand why you&#x27;re trying to use polkavm given that even for M1 you&#x27;ll need your own.</div>
<div class='msg reply'><time>2024‑08‑18 10:59</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: We are implementing our own PVM interpreter of course!  We have already done so for the Appendix A instruction set and covered the tests of https://github.com/w3f/jamtestvectors/pull/3.   We just need to have some similar byte code for Appendix B.  To do that, we have to assemble some byte code that has host functions, and so we only  use koute&#x27;s assembler to map some assembly code (the PR has 23 of them) into PVM byte code to test that assembler.

We are *not* FFIing into koute/polkavm.  We are only using it as an *assembler* to generate byte code to implement 23 host functions of Appendix B, following koute&#x27;s assemble/disassemble tool.

https://github.com/w3f/jamtestvectors/pull/3#issuecomment-2257688558
</div>
<div class='msg reply'><time>2024‑08‑18 11:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: ok that&#x27;s something.</div>
<div class='msg reply'><time>2024‑08‑18 11:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: but why not just use `ecalli`?</div>
<div class='msg reply'><time>2024‑08‑18 11:03</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: FYI there are some hostcall examples here if you just need something to test: https://github.com/JamBrains/polkavm-examples/blob/master/lang-cpp/main.cpp#L13  
the project also has an universal interpreter CLI to inject mocked host functions - all just for testing and using Jans code, but it  helped with debugging our interpreter</div>
<div class='msg reply'><time>2024‑08‑18 11:07</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: you can call this with the universal interpreter of that project with something like `pvme call test.pvm entry 42 69 --host-functions &quot;get_third_number:100&quot;` and then compare the result to your interpreter</div>
<div class='msg reply'><time>2024‑08‑18 11:11</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: &gt; &lt;@gav:polkadot.io&gt; but why not just use `ecalli` along with the relevant host call index?

AHA!  Is there some line in the GP that explains ecalli -- This is the missing bit of info.   </div>
<div class='msg reply'><time>2024‑08‑18 11:12</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: Screenshot 2024-08-18 at 13.12.34.png</div>
<div class='msg reply'><time>2024‑08‑18 11:12</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: it is what triggers a hostall</div>
<div class='msg reply'><time>2024‑08‑18 11:16</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Well, I missed this &quot;link&quot; between Appendix A and Appendix B -- where is it documented?  </div>
<div class='msg reply'><time>2024‑08‑18 11:17</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: image.png</div>
<div class='msg reply'><time>2024‑08‑18 11:17</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Together with each of the places where Ψ_H is used</div>
<div class='msg reply'><time>2024‑08‑18 11:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (248) and, by extension, (250) etc.</div>
<div class='msg reply'><time>2024‑08‑18 11:27</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Ok -- I got it, thank you! (Closed my PR for now, it no longer makes sense)  Any reason why `assign` and `new` don&#x27;t get a host index in GP?</div>
<div class='msg reply'><time>2024‑08‑18 11:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: https://github.com/gavofyork/graypaper/pull/62/commits/025e868628ef5fe9ae781546ebb3a89fe93c7b09</div>
<div class='msg reply'><time>2024‑08‑18 11:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Was fixed a week ago.</div>
<div class='msg reply'><time>2024‑08‑18 11:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I&#x27;ll release 0.3.5 soon</div>
<div class='msg'><time>2024‑08‑18 10:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: and in using it, rather than altering the code to introduce new instructions in order to empower `ArchVisitor`, you should obviously just invoke `ArchVisitor` using the `ecall`.</div>
<div class='msg'><time>2024‑08‑18 10:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * and in using it, rather than altering the code to introduce new non-standard instructions in order to empower `ArchVisitor`, you should obviously just invoke `ArchVisitor` using the `ecall`.</div>
<div class='msg'><time>2024‑08‑18 10:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * so i don&#x27;t understand why you&#x27;re trying to use polkavm given that even for M1 you&#x27;ll need to write your own.</div>
<div class='msg'><time>2024‑08‑18 10:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * i don&#x27;t understand why you&#x27;re trying to use polkavm given that even for M1 you&#x27;ll need to write your own.</div>
<div class='msg'><time>2024‑08‑18 10:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@mkchung:matrix.org&gt; In eq(93), the preimage appears to be of arbitrary size - which is then erasure encoded &amp; distributed in segments of size wc*ws to DA. But how does the E_p (lookup extrinsic) in section 12.1 (eq 155-158) able to know the length of the preimage? Without knowing the length, we probably cannot remove the padded zeros from the wc * ws segments. What am I missing?

93 describes account state storage.</div>
<div class='msg'><time>2024‑08‑18 10:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: this is not erasure-coded.</div>
<div class='msg'><time>2024‑08‑18 10:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * this is not erasure-coded. it is stored in state as a byte-sequence (with an implied length) in state directly.</div>
<div class='msg'><time>2024‑08‑18 10:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (157) shows exactly how the length can be verified: it is stored, along with the hash, as a key in δ[s]_l</div>
<div class='msg'><time>2024‑08‑18 11:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * but why not just use `ecalli` along with the relevant host call index?</div>
<div class='msg'><time>2024‑08‑18 11:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: [0.3.5](https://github.com/gavofyork/graypaper/releases/tag/v0.3.5) is released. Mostly trivial corrections, but there&#x27;s also some small alterations to the work bundle serialisation format.</div>
<div class='msg'><time>2024‑08‑19 09:14</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: I have a doubt about state encoding, more specifically: 

C(12) ↦ E4(χ)
C(13) ↦ E4(π)

How can we E4 here if χ and π are not actual integers? Would it be just E(χ) and E(π)?</div>
<div class='msg'><time>2024‑08‑19 14:59</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: I also have a Q about what `r` is in definition 111. It must be a work-report hash since it comes from  `V`, but `rho` does not contain work-report hashes but full work reports?  
Do we have to compute the hashes and then remove them?</div>
<div class='msg reply'><time>2024‑08‑20 06:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: https://github.com/gavofyork/graypaper/pull/65/commits/24488eb2c899bc211852d70784e3289b347b8b22</div>
<div class='msg'><time>2024‑08‑19 14:59</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: gp3.png</div>
<div class='msg'><time>2024‑08‑19 16:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; I have a doubt about state encoding, more specifically: 
&gt; 
&gt; C(12) ↦ E4(χ)
&gt; C(13) ↦ E4(π)
&gt; 
&gt; How can we E4 here if χ and π are not actual integers? Would it be just E(χ) and E(π)?

chi is just a tuple of numbers, so element should be encoded accordingly.  </div>
<div class='msg'><time>2024‑08‑19 16:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: pi is also just a sequence of sequences of numbers. </div>
<div class='msg'><time>2024‑08‑19 16:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Just encode each accordingly. </div>
<div class='msg'><time>2024‑08‑19 16:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: For tuples and sequences, E_4 is the same as E: totally transparent. </div>
<div class='msg'><time>2024‑08‑19 16:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@oliver.tale-yazdi:parity.io&gt; I also have a Q about what `r` is in definition 111. It must be a work-report hash since it comes from  `V`, but `rho` does not contain work-report hashes but full work reports?  
&gt; Do we have to compute the hashes and then remove them?

Yes - indeed this should have been placed in a hash function H(…)</div>
<div class='msg'><time>2024‑08‑19 16:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Will be fixed. </div>
<div class='msg'><time>2024‑08‑19 21:23</time>&ensp;<span class='u' style='color:#c377dd'>mkchung</span>: &gt; &lt;@gav:polkadot.io&gt; (157) shows exactly how the length can be verified: it is stored, along with the hash, as a key in δ[s]_l

Is E_P the only way to get preimage into the on-chain state δ? In other words, is it solely triggered by the solicit host func(Ωs) at the accumalate? Presumably block author would need to retrieve these preimage off chain from DAs in order to include it in the block as E_P?</div>
<div class='msg'><time>2024‑08‑19 21:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Correct. </div>
<div class='msg'><time>2024‑08‑19 21:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Validators are expected to receive and share these. </div>
<div class='msg'><time>2024‑08‑19 22:37</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: How does code deployed? 

As per 14.3, a Work Package has codehash $c$ (but not a length) – can the code $c$ and its length be inside ${\bf x}$ or *must* code deployment go through (i) `export` (ii) `solicit` in `accumulate` resulting in (iii) E_P-driven state trie updates, as stated by Eq (91).  

If the latter, how does a service&#x27;s FIRST code hash get deployed?  Its not happening  in host function `new`... so is there some privileged service that service creators have to use to get started that does (i)-(iii)?</div>
<div class='msg'><time>2024‑08‑19 22:40</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * How does code get deployed?

As per 14.3, a Work Package has codehash $c$ (but not a length) – can the code $c$ and its length be inside ${\\bf x}$ or _must_ code deployment go through (i) `export` (ii) `solicit` in `accumulate` resulting in (iii) E\_P-driven state trie updates, as stated by Eq (91).

If the latter, how does a service&#x27;s FIRST code hash get deployed?  Its not happening  in host function `new`... so is there some privileged service that service creators have to use to get started that does (i)-(iii)?</div>
<div class='msg'><time>2024‑08‑19 22:42</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * How does code get deployed?

As per 14.3, a Work Package has codehash $c$ (but not a length) –_must_ code deployment go through (i) `export` (ii) `solicit` in `accumulate` resulting in (iii) E\_P-driven state trie updates, as stated by Eq (91) or is there some other route?

More precisely how does a service&#x27;s FIRST code hash get deployed?  Its not happening  in host function `new`... so is there some privileged service that service creators have to use to get started that does (i)-(iii)?</div>
<div class='msg'><time>2024‑08‑19 23:05</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: In 14.3 right before 177 you have &quot;a sequence of hashed of blob hashes and lengths&quot; which I think should be ungarbled as something like &quot;a sequence of extrinsic hashes and lengths&quot; -- but shortly thereafter you have &quot;We make an assumption that the preimage to each extrinsic hash in each work-item is known by the guarantor.  In general this data will be passed to the guarantor alongside the work-package.&quot;   *These* preimages have nothing to do with the E_P, correct?  By &quot;will be  passed to the guarantor&quot; do you mean via JAMNP like what you have as `--&gt; Vec&lt;Extrinsic&gt; ++ Vec&lt;JustifiedImport&gt;&quot;` or something else? </div>
<div class='msg'><time>2024‑08‑19 23:09</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * In 14.3 right before Eq (177) you have &quot;a sequence of hashed of blob hashes and lengths&quot; which I think should be ungarbled as something like &quot;a sequence of extrinsic hashes and lengths&quot; -- but shortly thereafter you have &quot;We make an assumption that the preimage to each extrinsic hash in each work-item is known by the guarantor.  In general this data will be passed to the guarantor alongside the work-package.&quot;   _These_ preimages have nothing to do with the E\_P, correct?  By &quot;will be  passed to the guarantor&quot; do you mean via JAMNP like what you have as `--&gt; Vec&lt;Extrinsic&gt; ++ Vec&lt;JustifiedImport&gt;` or something else?</div>
<div class='msg'><time>2024‑08‑19 23:10</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * In 14.3 right before Eq (177) you have &quot;a sequence of hashed of blob hashes and lengths&quot; which I think should be ungarbled as something like &quot;a sequence of extrinsic hashes and lengths&quot; -- but shortly thereafter you have &quot;We make an assumption that the preimage to each extrinsic hash in each work-item is known by the guarantor.  In general this data will be passed to the guarantor alongside the work-package.&quot;   _These_ preimages have nothing to do with the E\_P, correct? 

By &quot;In general this data will be  passed to the guarantor&quot; by &quot;this data&quot; do you mean the `Extrinsic` preimage _via JAMNP_ like what you have as `--&gt; Vec&lt;Extrinsic&gt; ++ Vec&lt;JustifiedImport&gt;` or something else?</div>
<div class='msg'><time>2024‑08‑19 23:15</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * In 14.3 right before Eq (177) you have &quot;a sequence of hashed of blob hashes and lengths&quot; which I think should be ungarbled as something like &quot;a sequence of extrinsic hashes and lengths&quot; -- but shortly thereafter you have &quot;We make an assumption that the preimage to each extrinsic hash in each work-item is known by the guarantor.  In general this data will be passed to the guarantor alongside the work-package.&quot;   _These_ preimages have nothing to do with the E\_P-driven state trie updates from `solicit`, correct?

By &quot;In general this data will be  passed to the guarantor&quot; by &quot;this data&quot; do you mean the `Extrinsic` preimage _via JAMNP_ like what you have as `--&gt; Vec&lt;Extrinsic&gt; ++ Vec&lt;JustifiedImport&gt;` or something else?</div>
<div class='msg'><time>2024‑08‑20 00:45</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: In B.3 &quot;The Refine invocation also ... explicitly accepts the work payload, ${\bf y}$, ..., the import and extrinsic data blobs (both just concatenated segments) as dictated by the work-item, ${\bf i}$ and ${\bf x}$&quot; -- which  refers to 14.3&#x27;s (177) (carried through to (184) and then (253) but then *nowhere* in the refine-specific host functions of (254)), correct?

Assuming the above understanding is correct, I am expecting some opcodes or refine-specific host functions analogous to `import` (which gets at ${\bf i}$) that gets at the payload ${\bf y}$ and the extrinsic &quot;raw&quot; preimage data ${\bf x}$.  Which ones are these?  Is there some setup of ${\bf x}$ and ${\bf y}$ in memory that we missed?</div>
<div class='msg'><time>2024‑08‑20 00:58</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * In B.3 &quot;The Refine invocation also ... explicitly accepts the work payload, ${\\bf y}$, ..., the import and extrinsic data blobs (both just concatenated segments) as dictated by the work-item, ${\\bf i}$ and ${\\bf x}$&quot; -- which  refers to 14.3&#x27;s (177) (carried through to (184) and then (253) but then _nowhere_ in the refine-specific host functions of (254)), correct?

Assuming the above understanding is correct, I am expecting some refine-specific host functions *analogous* to `import` (which gets at ${\\bf i}$) that gets at the *payload* ${\\bf y}$ (which might be called `import_y` and the *extrinsic* &quot;raw&quot; preimage data ${\\bf x}$ (which might be called `import_x`).   But I don&#x27;t see anything -- so which host functions read ${\bf y}$ and ${\bf y}$?  Is there some setup of ${\\bf x}$ and ${\\bf y}$ in memory that we missed?  </div>
<div class='msg'><time>2024‑08‑20 01:32</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * In 14.3 right before Eq (177) you have &quot;a sequence of hashed of blob hashes and lengths&quot; which I think should be ungarbled as something like &quot;a sequence of extrinsic hashes and lengths&quot; -- but shortly thereafter you have &quot;We make an assumption that the preimage to each extrinsic hash in each work-item is known by the guarantor.  In general this data will be passed to the guarantor alongside the work-package.&quot;   _These_ preimages have nothing to do with the E\_P-driven state trie updates from `solicit`, correct?

By &quot;In general this data will be  passed to the guarantor&quot; by &quot;this data&quot; do you mean the `Extrinsic` preimage _via JAMNP_ like what you have as `--&gt; Vec&lt;Extrinsic&gt; ++ Vec&lt;JustifiedImport&gt;` or something else?

What does `JustifiedImport` refer to in GP?</div>
<div class='msg'><time>2024‑08‑20 05:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; How does code get deployed?
&gt; 
&gt; As per 14.3, a Work Package has codehash $c$ (but not a length) –_must_ code deployment go through (i) `export` (ii) `solicit` in `accumulate` resulting in (iii) E\_P-driven state trie updates, as stated by Eq (91) or is there some other route?
&gt; 
&gt; More precisely how does a service&#x27;s FIRST code hash get deployed?  Its not happening  in host function `new`... so is there some privileged service that service creators have to use to get started that does (i)-(iii)?

As you write.</div>
<div class='msg'><time>2024‑08‑20 05:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; How does code deployed? 
&gt; 
&gt; As per 14.3, a Work Package has codehash $c$ (but not a length) – can the code $c$ and its length be inside ${\bf x}$ or *must* code deployment go through (i) `export` (ii) `solicit` in `accumulate` resulting in (iii) E_P-driven state trie updates, as stated by Eq (91).  
&gt; 
&gt; If the latter, how does a service&#x27;s FIRST code hash get deployed?  Its not happening  in host function `new`... so is there some privileged service that service creators have to use to get started that does (i)-(iii)?

* As you postulate. The first service (which will appear in the Genesis block) will include functionality for creating new services. </div>
<div class='msg'><time>2024‑08‑20 05:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; How does code deployed? 
&gt; 
&gt; As per 14.3, a Work Package has codehash $c$ (but not a length) – can the code $c$ and its length be inside ${\bf x}$ or *must* code deployment go through (i) `export` (ii) `solicit` in `accumulate` resulting in (iii) E_P-driven state trie updates, as stated by Eq (91).  
&gt; 
&gt; If the latter, how does a service&#x27;s FIRST code hash get deployed?  Its not happening  in host function `new`... so is there some privileged service that service creators have to use to get started that does (i)-(iii)?

* As you postulate. The first service (which will appear in the Genesis block) will include functionality for creating new services permissible. </div>
<div class='msg'><time>2024‑08‑20 05:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; How does code deployed? 
&gt; 
&gt; As per 14.3, a Work Package has codehash $c$ (but not a length) – can the code $c$ and its length be inside ${\bf x}$ or *must* code deployment go through (i) `export` (ii) `solicit` in `accumulate` resulting in (iii) E_P-driven state trie updates, as stated by Eq (91).  
&gt; 
&gt; If the latter, how does a service&#x27;s FIRST code hash get deployed?  Its not happening  in host function `new`... so is there some privileged service that service creators have to use to get started that does (i)-(iii)?

* As you postulate. The first service (which will appear in the Genesis block) will include functionality for creating new services permissionlessly. </div>
<div class='msg'><time>2024‑08‑20 05:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; In 14.3 right before Eq (177) you have &quot;a sequence of hashed of blob hashes and lengths&quot; which I think should be ungarbled as something like &quot;a sequence of extrinsic hashes and lengths&quot; -- but shortly thereafter you have &quot;We make an assumption that the preimage to each extrinsic hash in each work-item is known by the guarantor.  In general this data will be passed to the guarantor alongside the work-package.&quot;   _These_ preimages have nothing to do with the E\_P-driven state trie updates from `solicit`, correct?
&gt; 
&gt; By &quot;In general this data will be  passed to the guarantor&quot; by &quot;this data&quot; do you mean the `Extrinsic` preimage _via JAMNP_ like what you have as `--&gt; Vec&lt;Extrinsic&gt; ++ Vec&lt;JustifiedImport&gt;` or something else?
&gt; 
&gt; What does `JustifiedImport` refer to in GP?

On the first two points, yes.</div>
<div class='msg'><time>2024‑08‑20 05:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; In B.3 &quot;The Refine invocation also ... explicitly accepts the work payload, ${\\bf y}$, ..., the import and extrinsic data blobs (both just concatenated segments) as dictated by the work-item, ${\\bf i}$ and ${\\bf x}$&quot; -- which  refers to 14.3&#x27;s (177) (carried through to (184) and then (253) but then _nowhere_ in the refine-specific host functions of (254)), correct?
&gt; 
&gt; Assuming the above understanding is correct, I am expecting some refine-specific host functions *analogous* to `import` (which gets at ${\\bf i}$) that gets at the *payload* ${\\bf y}$ (which might be called `import_y` and the *extrinsic* &quot;raw&quot; preimage data ${\\bf x}$ (which might be called `import_x`).   But I don&#x27;t see anything -- so which host functions read ${\bf y}$ and ${\bf y}$?  Is there some setup of ${\\bf x}$ and ${\\bf y}$ in memory that we missed?  

It should not read “both just contented segments”; only imports are segments. Extrinsic data are (arbitrary length) blobs. </div>
<div class='msg reply'><time>2024‑08‑20 06:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: https://github.com/gavofyork/graypaper/pull/65/commits/90868bc03582665ffb67aedc6afe19517d9e853d</div>
<div class='msg'><time>2024‑08‑20 05:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Extrinsic data are passed into the refine function directly. Imported segments are read through the import host call. </div>
<div class='msg'><time>2024‑08‑20 05:51</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Thank you for explaining -- which refine instructions / host functions can read/copy extrinsic data into RAM?  What about the payload ${\bf y}$?</div>
<div class='msg'><time>2024‑08‑20 05:53</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Thank you for explaining -- still unclear which refine instructions / host functions can read/copy extrinsic data ${\bf x}$ (I understand, passed into refine function directly) into RAM?  What about the payload ${\bf y}$?</div>
<div class='msg'><time>2024‑08‑20 05:53</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Thank you for explaining -- still unclear though -- which refine instructions / host functions can read/copy extrinsic data ${\\bf x}$ (I understand, passed into refine function directly) into RAM?  What about the payload ${\bf y}$?</div>
<div class='msg'><time>2024‑08‑20 06:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Thank you for explaining -- still unclear though -- which refine instructions / host functions can read/copy extrinsic data ${\\bf x}$ (I understand, passed into refine function directly) into RAM?  What about the payload ${\bf y}$?

&gt; Extrinsic data are passed into the refine function directly.

See (251)</div>
<div class='msg'><time>2024‑08‑20 06:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Arguments to Refine are encoded into a; this includes all extrinsic data.</div>
<div class='msg'><time>2024‑08‑20 06:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (NOTE: &quot;Extrinsic&quot; is used for two separate and very different concepts in the GP. That&#x27;s not ideal. I&#x27;ll likely change this use of &quot;extrinsic&quot; to &quot;argument&quot; in a later draft.</div>
<div class='msg'><time>2024‑08‑20 06:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * (NOTE: &quot;Extrinsic&quot; is used for two separate and very different concepts in the GP. That&#x27;s not ideal. I&#x27;ll likely change this use of &quot;extrinsic&quot; to &quot;argument&quot; in a later draft.)</div>
<div class='msg'><time>2024‑08‑20 10:32</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Understood -- I am postulating that  PVM programs there must be host functions in B.8 that copy 
(a) ${\bf x}$ extrinsic data encoded into the $a$ argument of Refine, call it `import_x` to copy $a_{\bf x}$ into RAM
(b) ${\bf y}$ payload data encoded into the $a$ argument of Refine, call it `import_y` to copy $a_{\bf y}$ into RAM
because I don&#x27;t see any such way within { `historical_lookup`, `import`, `export`, `machine`, `peek`, `poke`, `invoke`, `expunge` } to access elements of $a$.  It seems I am missing a concept or there needs to be 2 more host functions `import_x` and `import_y`.</div>
<div class='msg'><time>2024‑08‑20 10:33</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Understood -- I am postulating that  PVM programs  must have host functions in B.8 that copy
(a) ${\\bf x}$ extrinsic data encoded into the $a$ argument of Refine, call it `import_x` to copy $a\_{\\bf x}$ into RAM
and
(b) ${\\bf y}$ payload data encoded into the $a$ argument of Refine, call it `import_y` to copy $a\_{\\bf y}$ into RAM

I don&#x27;t see any such way within { `historical_lookup`, `import`, `export`, `machine`, `peek`, `poke`, `invoke`, `expunge` } to access elements of $a$.  

It seems I am missing a concept or there needs to be 2 more host functions `import_x` and `import_y`.</div>
<div class='msg'><time>2024‑08‑20 10:41</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: image.png</div>
<div class='msg'><time>2024‑08‑20 10:41</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: I think when you say 251 you mean the above 253</div>
<div class='msg'><time>2024‑08‑20 10:41</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: since 251 for me is</div>
<div class='msg'><time>2024‑08‑20 10:41</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: image.png</div>
<div class='msg'><time>2024‑08‑20 10:42</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: and we&#x27;re talking about this $a$ here: </div>
<div class='msg'><time>2024‑08‑20 10:42</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: image.png</div>
<div class='msg'><time>2024‑08‑20 10:50</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: The postulated `import_x` and `import_y` would be like `import` here:</div>
<div class='msg'><time>2024‑08‑20 10:50</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: image.png</div>
<div class='msg'><time>2024‑08‑20 10:53</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: except instead of copying ${\bf i}_{\omega_0}$ it would copy $a_{{\bf x}_{\omega_0}}$ or ${a_{\bf y}}$ into RAM (and no need for the min(\omega_2, W_C W_S).   What do you think?</div>
<div class='msg'><time>2024‑08‑20 14:52</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * except instead of copying ${\\bf i}_{\\omega\_0}$ it would copy $a_{{\\bf x}_{\\omega\_0}}$ or ${a_{\\bf y}}$ into RAM (and no need for the min(\\omega\_2, W\_C W\_S).   Perhaps names like `extrinsic` (?) and `payload` would be more appropriate -- What do you think?</div>
<div class='msg'><time>2024‑08‑20 14:59</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * except instead of copying ${\\bf i}_{\\omega\_0}$ it would copy $a_{{\\bf x}_{\\omega\_0}}$ or ${a_{\\bf y}}$ into RAM (and no need for the min(\\omega\_2, W\_C W\_S), no index $\omega_0$ for payload ${\bf y}$)   Perhaps names like `extrinsic` (?) and `payload` would be more appropriate -- What do you think?</div>
<div class='msg'><time>2024‑08‑20 15:00</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * except instead of copying ${\\bf i}_{\\omega\_0}$ it would copy $a_{{\\bf x}_{\\omega\_0}}$ or ${a_{\\bf y}}$ into RAM (and no need for the min(\\omega\_2, W\_C W\_S), no index $\\omega\_0$ for payload ${\\bf y}$)   Perhaps names like `extrinsic` (?) and `payload` would be more appropriate than `import_x` and `import_y` -- What do you think?</div>
<div class='msg'><time>2024‑08‑21 16:48</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Time as defined in the GP seems to be TAI-based. That is, it is defined simply as &quot;seconds passed since the beginning of the JAM Common Era&quot;. Practically speaking most systems are UTC-based. The difference is that UTC is adjusted by leap seconds, whereas TAI is not. Sticking with the current definition seems good, as it&#x27;s conceptually simple. It&#x27;s probably worth explicitly talking about this in the GP though, as just doing the natural thing (current UNIX timestamp minus epoch timestamp) will on most systems not be correct. Well, it might be, if there are no more leap seconds. AIUI they will be abolished by 2035 but there may be some before then. I&#x27;m not sure if there&#x27;s a &quot;standard&quot; way of dealing with this. I believe it is possible in Linux to make the system clock follow TAI, however I don&#x27;t know if this is a good idea or not.</div>
<div class='msg'><time>2024‑08‑22 11:17</time>&ensp;<span class='u' style='color:#d66f7e'>lucasvo</span>: I&#x27;ve been working through the paper and one thing I&#x27;m unsure about is how ordering of work packages defined and in practice how is it determined?</div>
<div class='msg'><time>2024‑08‑22 12:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It’s not defined except through the prerequisite field. </div>
<div class='msg'><time>2024‑08‑22 12:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * It’s not defined except through the prerequisite field. This currently doesn’t give a strong ordering for accumulation but from 0.4 onwards it will. </div>
<div class='msg'><time>2024‑08‑22 12:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * It’s not defined except through the prerequisite field. This currently doesn’t give a strong ordering for accumulation (as availability may complete out of order) but from 0.4 onwards it will. </div>
<div class='msg'><time>2024‑08‑22 20:35</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: &gt; &lt;@dave:parity.io&gt; Time as defined in the GP seems to be TAI-based. That is, it is defined simply as &quot;seconds passed since the beginning of the JAM Common Era&quot;. Practically speaking most systems are UTC-based. The difference is that UTC is adjusted by leap seconds, whereas TAI is not. Sticking with the current definition seems good, as it&#x27;s conceptually simple. It&#x27;s probably worth explicitly talking about this in the GP though, as just doing the natural thing (current UNIX timestamp minus epoch timestamp) will on most systems not be correct. Well, it might be, if there are no more leap seconds. AIUI they will be abolished by 2035 but there may be some before then. I&#x27;m not sure if there&#x27;s a &quot;standard&quot; way of dealing with this. I believe it is possible in Linux to make the system clock follow TAI, however I don&#x27;t know if this is a good idea or not.

TAI makes sense in a final ratification.  Since most will create some abstractions to get the &quot;JCE&quot;, it seems hardly problematic to address the leapseconds within that abstraction.  

Are you taking the lead on the next JAMNP writeup?  

We are wondering if there really  is no gossiping of Tickets, Blocks, etc. within JAMNP as it seems pretty wild for each validator to broadcast to all V-1 fellow validators.  Not only that, if each ticket is sent to V-1 validators, all the cool anonymity will be canceled by QUIC.  Is there some detail of how QUIC will be used for gossiping objects quickly in JAMNP </div>
<div class='msg'><time>2024‑08‑22 20:36</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: &gt; &lt;@dave:parity.io&gt; Time as defined in the GP seems to be TAI-based. That is, it is defined simply as &quot;seconds passed since the beginning of the JAM Common Era&quot;. Practically speaking most systems are UTC-based. The difference is that UTC is adjusted by leap seconds, whereas TAI is not. Sticking with the current definition seems good, as it&#x27;s conceptually simple. It&#x27;s probably worth explicitly talking about this in the GP though, as just doing the natural thing (current UNIX timestamp minus epoch timestamp) will on most systems not be correct. Well, it might be, if there are no more leap seconds. AIUI they will be abolished by 2035 but there may be some before then. I&#x27;m not sure if there&#x27;s a &quot;standard&quot; way of dealing with this. I believe it is possible in Linux to make the system clock follow TAI, however I don&#x27;t know if this is a good idea or not.

 * TAI makes sense in a final ratification.  Since most will create some abstractions to get the &quot;JCE&quot;, it seems hardly problematic to address the leapseconds within that abstraction.

Are you taking the lead on the next JAMNP writeup?

We are wondering if there really  is no gossiping of Tickets, Blocks, etc. within JAMNP as it seems pretty wild for each validator to broadcast to all V-1 fellow validators.  Not only that, if each ticket is sent to V-1 validators, all the cool anonymity will be canceled by QUIC.  Is there some detail of how QUIC will be used for gossiping objects quickly in JAMNP?  Or some expectation that JAMNP will support gossiping soon enough?</div>
<div class='msg'><time>2024‑08‑22 20:39</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Tickets are to be sent via a proxy; the proxy will know the sender&#x27;s identity obviously but is trusted to not reveal it. If you assume 2/3 honest validators then most of the tickets will be anonymous</div>
<div class='msg'><time>2024‑08‑22 20:40</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: The plan is for new block distribution to be done via the availability system</div>
<div class='msg'><time>2024‑08‑23 01:32</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-08-23 at 1.30.48 PM.png</div>
<div class='msg'><time>2024‑08‑23 01:32</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: is this missing a Hash?</div>
<div class='msg'><time>2024‑08‑23 01:58</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-08-23 at 1.58.30 PM.png</div>
<div class='msg'><time>2024‑08‑23 01:59</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: to my understanding, those are unordered set, in that case, what order should be used for serialization? or they are just FIFO?</div>
<div class='msg'><time>2024‑08‑23 01:59</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>:  * to my understanding, those are unordered set, in that case, what order should be used for serialization? or they are just FIFO array without duplications?</div>
<div class='msg'><time>2024‑08‑23 02:14</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-08-23 at 2.14.26 PM.png</div>
<div class='msg'><time>2024‑08‑23 02:14</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: what is `al` and `ai`?</div>
<div class='msg'><time>2024‑08‑23 02:15</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-08-23 at 2.15.01 PM.png</div>
<div class='msg'><time>2024‑08‑23 08:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dave:parity.io&gt; The plan is for new block distribution to be done via the availability system

Actually not via the “availability system” but through a separate distribution (and redistribution) of erasure coded block pieces). </div>
<div class='msg'><time>2024‑08‑23 08:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dave:parity.io&gt; The plan is for new block distribution to be done via the availability system

* Actually not via the “availability system” but through a separate distribution (and redistribution) of erasure coded block pieces. </div>
<div class='msg'><time>2024‑08‑23 08:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dave:parity.io&gt; The plan is for new block distribution to be done via the availability system

* Actually not via the “availability system” but through a separate distribution (and redistribution) of erasure coded block pieces. It’ll be its own distribution system but will reuse the erasure coding logic. </div>
<div class='msg'><time>2024‑08‑23 08:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; is this missing a Hash?

No: https://github.com/gavofyork/graypaper/pull/65/commits/92b824261feb67d12784a539232eb64da1b87b47</div>
<div class='msg'><time>2024‑08‑23 08:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; to my understanding, those are unordered set, in that case, what order should be used for serialization? or they are just FIFO array without duplications?

The wavey vertical line implies ordering (see the two paragraphs below (11))</div>
<div class='msg'><time>2024‑08‑23 08:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; what is `al` and `ai`?

See (94):</div>
<div class='msg'><time>2024‑08‑23 08:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: image.png</div>
<div class='msg'><time>2024‑08‑23 09:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: They&#x27;re values which can be derived from the maps (so not strictly needed in the DB) but they&#x27;re in there to facilitate implementations&#x27; tracking of the changes rather than rebuilding each block (or having a separate database to track them).</div>
<div class='msg'><time>2024‑08‑23 09:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * They&#x27;re values which can be derived from the maps (so not strictly needed in the DB/state) but determining the total size/number ofd items directly from the Merkle tree is non-trivial. So they&#x27;re in there to facilitate implementations&#x27; tracking of the changes rather than rebuilding each block (or having a separate database to track them).</div>
<div class='msg'><time>2024‑08‑23 09:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * They&#x27;re values which can be derived from the maps (so not strictly needed in the DB/state) but determining the total size/number ofd items directly from the Merkle tree is non-trivial. So they&#x27;re in there to facilitate implementations&#x27; tracking of the changes rather than rebuilding each block (or having a separate database to track them) both of which add a lot of implementation bloat and/or complexity .</div>
<div class='msg'><time>2024‑08‑23 09:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * They&#x27;re values which can be derived from the maps (so not strictly needed in the DB/state) but determining the total size/number ofd items directly from the Merkle tree is non-trivial. So they&#x27;re in there to facilitate implementations&#x27; tracking of the changes rather than rebuilding each block (or having a separate database to track them) both of which add a lot of implementation bloat and/or complexity.</div>
<div class='msg'><time>2024‑08‑23 09:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * They&#x27;re values which can be derived from the maps (so not strictly needed in the DB) but determining the total size/number ofd items directly from the Merkle tree is non-trivial. So they&#x27;re in there to facilitate implementations&#x27; tracking of the changes rather than rebuilding each block (or having a separate database to track them) both of which add a lot of implementation bloat and/or complexity.</div>
<div class='msg'><time>2024‑08‑23 09:03</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: &gt; &lt;@gav:polkadot.io&gt; Actually not via the “availability system” but through a separate distribution (and redistribution) of erasure coded block pieces. It’ll be its own distribution system but will reuse the erasure coding logic.

Makes sense for &quot;big&quot; `Block`, but wouldn&#x27;t tiny JAM objects (`Guarantee`, `Assurance`, `Dispute`, `PreimageLookup`) benefit from libp2p style gossiping in speed over erasure coding? </div>
<div class='msg'><time>2024‑08‑23 09:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It&#x27;s only for the block.</div>
<div class='msg'><time>2024‑08‑23 09:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The rest is indeed distributed directly on p2p connections.</div>
<div class='msg'><time>2024‑08‑23 09:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * They&#x27;re values which can be derived from the maps (so not strictly needed in the DB) but determining the total size/number of items directly from the Merkle tree is non-trivial. So they&#x27;re in there to facilitate implementations&#x27; tracking of the changes rather than rebuilding each block (or having a separate database to track them) both of which add a lot of implementation bloat and/or complexity.</div>
<div class='msg'><time>2024‑08‑23 09:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; to my understanding, those are unordered set, in that case, what order should be used for serialization? or they are just FIFO array without duplications?

 * The wavey vertical line implies ordering (see the two paragraphs below (11)): https://graypaper.fluffylabs.dev/#WyI0ODY2YjU5YmMwIiwiNSIsIlByZXZpb3VzIFdvcmsgYW5kIFByZXNlbnQgVHJlbmRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeDEzIGgyIHkyMDUgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4MTMgaDIgeTIwZiBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==</div>
<div class='msg'><time>2024‑08‑23 09:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; what is `al` and `ai`?

 * See [(94)](https://graypaper.fluffylabs.dev/#WyJjNTZkZmI4NzYzIiwiMTEiLCJTZXJ2aWNlIEFjY291bnRzIiwiQWNjb3VudCBGb290cHJpbnQgYW5kIFRocmVzaG9sZCBCYWxhbmNlIixbIjxkaXYgY2xhc3M9XCJ0IG0wIHgxMSBoZSB5N2JmIGZmZiBmczAgZmMwIHNjMCBsczAgd3MwXCI+IiwiPGRpdiBjbGFzcz1cInQgbTAgeDQ4IGhiIHk3Y2IgZmYxMiBmczAgZmMwIHNjMCBsczAgd3MwXCI+Il1d):</div>
<div class='msg'><time>2024‑08‑23 17:10</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: We require that the code hashes in the guarantees extrinsic match the current code hashes for the relevant services. This may not be the case by the time the WRs are accumulated though? Is the intention that accumulation code should protect itself against this if necessary, eg by including a version in the refine output?</div>
<div class='msg'><time>2024‑08‑23 21:00</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Screenshot 2024-08-23 at 22.00.47.png</div>
<div class='msg'><time>2024‑08‑23 21:02</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Why (h4:) is negated here? Is this correct? Why not simple h4: ?</div>
<div class='msg reply'><time>2024‑08‑23 21:46</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I don’t exactly know but I think it is to protect from hash collusion </div>
<div class='msg reply'><time>2024‑08‑24 16:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; I don’t exactly know but I think it is to protect from hash collusion 

Exactly. </div>
<div class='msg'><time>2024‑08‑23 22:56</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: gav: Some basic questions on Assurances.

1. From (185)+(186) *Availability Specifier* $s$ (with h, l, u, e) ALONE (included in a Work Report), will an assurer/validator be able to reconstruct the *auditable* work package after getting their chunk and a proof?

1&#x27;. If the answer to (1) is YES we need a test case of a work package ${\bf p}$ with this $s$ computed.  When can we get it?  This is essential for E_A Assuring.

2. Given the proof referenced in Section 16 &quot;Firstly, their erasure-coded chunk for this report. The validity of this chunk can be trivially proven through the work-report’s work-package erasure-root and a Merkle proof of inclusion in the correct location.  The proof should be included from the guarantor.&quot;  which QUIC message covers this proof _submission_ in JAMNP?  

3. In section 16 &quot;Availability Assurance&quot;, you refer to &quot;provided&quot; and &quot;required&quot; manifests, seemingly for the first time (?), which appear to be &quot;inside&quot; the availability specifier $s$.  Are these ${\bf b}^\club$ (package, imported items, extrinsics related) and ${\bf s}^\club$  (exported items)-- which one is &quot;provided&quot; and which one is &quot;required&quot;?  
</div>
<div class='msg'><time>2024‑08‑23 22:57</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * gav: Some basic questions on Assurances.

1. From (185)+(186) _Availability Specifier_ $s$ (with h, l, u, e) ALONE (included in a Work Report), will an assurer/validator be able to reconstruct the _auditable_ work package after getting their chunk and a proof?

2. If the answer to (1) is YES we need a test case of a work package ${\\bf p}$ with this $s$ computed.  When can we get it?  This is essential for E\_A Assuring.

3. Given the proof referenced in Section 16 &quot;Firstly, their erasure-coded chunk for this report. The validity of this chunk can be trivially proven through the work-report’s work-package erasure-root and a Merkle proof of inclusion in the correct location.  The proof should be included from the guarantor.&quot;  which QUIC message covers this proof _submission_ in JAMNP?

4. In section 16 &quot;Availability Assurance&quot;, you refer to &quot;provided&quot; and &quot;required&quot; manifests, seemingly for the first time (?), which appear to be &quot;inside&quot; the availability specifier $s$.  Are these ${\\bf b}^\\club$ (package, imported items, extrinsics related) and ${\\bf s}^\\club$  (exported items)-- which one is &quot;provided&quot; and which one is &quot;required&quot;?</div>
<div class='msg'><time>2024‑08‑23 23:05</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * gav: Some basic questions on Assurances.

1. From (185)+(186) _Availability Specifier_ $s$ (with h, l, u, e) ALONE (included in a Work Report), will an assurer/validator be able to reconstruct the _auditable_ work package after getting their chunk and a proof of inclusion using $s$ ALONE?
2. If the answer to (1) is YES we need a test case of a work package ${\\bf p}$ with this $s$ computed.  When can we get it?  This is essential for E\_A Assuring.
3. Given the proof referenced in Section 16 &quot;Firstly, their erasure-coded chunk for this report. The validity of this chunk can be trivially proven through the work-report’s work-package erasure-root and a Merkle proof of inclusion in the correct location.  The proof should be included from the guarantor.&quot;  which QUIC message covers this proof _submission_ in JAMNP?
4. In section 16 &quot;Availability Assurance&quot;, you refer to &quot;provided&quot; and &quot;required&quot; manifests, seemingly for the first time (?), which appear to be &quot;inside&quot; the availability specifier $s$.  Are these ${\\bf b}^\\club$ (package, imported items, extrinsics related) and ${\\bf s}^\\club$  (exported items)-- which one is &quot;provided&quot; and which one is &quot;required&quot;?</div>
<div class='msg'><time>2024‑08‑23 23:06</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * gav: Some basic questions on Assurances.

1. From (185)+(186) _Availability Specifier_ $s$ (with h, l, u, e) ALONE (included in a Work Report), will an assurer/validator be able to reconstruct the _auditable_ work package after getting their chunk and a proof of inclusion using $s$ ALONE?
2. If the answer to (1) is YES we need a test case of a work package ${\\bf p}$ and some pretend exported items with this &quot;Auditable work package&quot; $s$ computed.  When can we get it?  This is essential for implementers to have proper $E_G$ work report generation and to get through a $E\_A$ Assuring implementation.
3. Given the proof referenced in Section 16 &quot;Firstly, their erasure-coded chunk for this report. The validity of this chunk can be trivially proven through the work-report’s work-package erasure-root and a Merkle proof of inclusion in the correct location.  The proof should be included from the guarantor.&quot;  which QUIC message covers this proof _submission_ in JAMNP?
4. In section 16 &quot;Availability Assurance&quot;, you refer to &quot;provided&quot; and &quot;required&quot; manifests, seemingly for the first time (?), which appear to be &quot;inside&quot; the availability specifier $s$.  Are these ${\\bf b}^\\club$ (package, imported items, extrinsics related) and ${\\bf s}^\\club$  (exported items)-- which one is &quot;provided&quot; and which one is &quot;required&quot;?</div>
<div class='msg'><time>2024‑08‑23 23:09</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: 5. What is $n$ in 185 -- is it the index into one of up to I=4 imported segment items?  </div>
<div class='msg'><time>2024‑08‑23 23:44</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * gav: Some basic questions on Assurances.

1. From (185)+(186) _Availability Specifier_ $s$ (with h, l, u, e) ALONE (included in a Work Report), will an assurer/validator be able to reconstruct the _auditable_ work package after getting their chunk and a proof of inclusion using $s$ ALONE?
2. If the answer to (1) is YES we need a test case of a work package ${\\bf p}$ and some pretend exported items with this &quot;Auditable work package&quot; $s$ computed.  When can we get it?  This is essential for implementers to have proper $E\_G$ work report generation and to get through a $E\_A$ Assuring implementation.
3. Given the proof referenced in Section 16 &quot;Firstly, their erasure-coded chunk for this report. The validity of this chunk can be trivially proven through the work-report’s work-package erasure-root and a Merkle proof of inclusion in the correct location.  The proof should be included from the guarantor.&quot;  which QUIC message covers this proof _submission_ in JAMNP?
4. In section 16 &quot;Availability Assurance&quot;, you refer to &quot;provided&quot; and &quot;required&quot; manifests, seemingly for the first time (?), which appear to be &quot;inside&quot; the availability specifier $s$.  Are these ${\\bf b}^\\club$ (package, imported items, extrinsics related) and ${\\bf s}^\\club$  (exported items)-- which one is &quot;provided&quot; and which one is &quot;required&quot;?</div>
<div class='msg'><time>2024‑08‑23 23:47</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * gav: Some basic questions on Assurances.

1. From (185)+(186) _Availability Specifier_ $s$ (with h, l, u, e) ALONE (included in a Work Report), will an assurer/validator be able to reconstruct the _auditable_ work package after getting their chunk and a proof of inclusion using $s$ ALONE?
2. If the answer to (1) is YES we need a test case of a work package ${\\bf p}$ and some pretend exported items with this &quot;Availability Specifier&quot; $s$ computed (which is equivalent to a Auditable Work package and sufficient for assuring, if we understand correctly).  When can we get a $s$ test case?  Having this will be essential for JAM implementers to have proper $E\_G$ verifiable work report generation and to get through a full $E\_A$ Assurance generation.
3. Given the proof referenced in Section 16 &quot;Firstly, their erasure-coded chunk for this report. The validity of this chunk can be trivially proven through the work-report’s work-package erasure-root and a Merkle proof of inclusion in the correct location.  The proof should be included from the guarantor.&quot;  which QUIC message covers this proof _submission_ in JAMNP?
4. In section 16 &quot;Availability Assurance&quot;, you refer to &quot;provided&quot; and &quot;required&quot; manifests, seemingly for the first time (?), which appear to be &quot;inside&quot; the availability specifier $s$.  Are these ${\\bf b}^\\club$ (package, imported items, extrinsics related) and ${\\bf s}^\\club$  (exported items)-- which one is &quot;provided&quot; and which one is &quot;required&quot;?</div>
<div class='msg'><time>2024‑08‑24 00:13</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * gav: Some basic questions on Assurances.

1. From (185)+(186) _Availability Specifier_ $s$ (with h, l, u, e) ALONE (included in a Work Report), will an assurer/validator be able to reconstruct the _auditable_ work package after getting their chunk and a proof of inclusion using $s$ ALONE?  If not, what else does a [non-guarantor] assurer need other than $s$?  
2. If the answer to (1) is YES we need a test case of a work package ${\\bf p}$ and some pretend exported items with this &quot;Availability Specifier&quot; $s$ computed (which is equivalent to a Auditable Work package and sufficient for assuring, if we understand correctly).  When can we get a $s$ test case?  Having this will be essential for JAM implementers to have proper $E\_G$ verifiable work report generation and to get through a full $E\_A$ Assurance generation.
3. Given the proof referenced in Section 16 &quot;Firstly, their erasure-coded chunk for this report. The validity of this chunk can be trivially proven through the work-report’s work-package erasure-root and a Merkle proof of inclusion in the correct location.  The proof should be included from the guarantor.&quot;  which QUIC message covers this proof _submission_ in JAMNP?
4. In section 16 &quot;Availability Assurance&quot;, you refer to &quot;provided&quot; and &quot;required&quot; manifests, seemingly for the first time (?), which appear to be &quot;inside&quot; the availability specifier $s$.  Are these ${\\bf b}^\\club$ (package, imported items, extrinsics related) and ${\\bf s}^\\club$  (exported items)-- which one is &quot;provided&quot; and which one is &quot;required&quot;?</div>
<div class='msg'><time>2024‑08‑24 06:44</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * gav: Some basic questions on Assurances.

1. From (185)+(186) _Availability Specifier_ $s$ (with h, l, u, e) ALONE (included in a Work Report), will an assurer/validator be able to reconstruct the _auditable_ work package (by querying fellow validators) after getting their chunk and a proof of inclusion using $s$ ALONE?  If not, what else does a \[non-guarantor\] assurer need other than $s$ from a `Guarantee` to reconstruct the _auditable_ work package (by querying fellow validators)?
2. If the answer to (1) is &quot;YES, s alone is sufficient for work package reconstruction (by querying fellow validators)&quot;, we need a *test case* of a work package ${\\bf p}$ and some pretend exported items with this &quot;Availability Specifier&quot; $s$ computed (which is equivalent to a Auditable Work package and sufficient for assuring, if we understand correctly).  When can we get a ${\bf}, s$ test case?  Having this will be essential for JAM implementers to have proper $E\_G$ verifiable work report generation and to get through a full $E\_A$ Assurance generation.
3. Given the proof referenced in Section 16 &quot;... Firstly, their erasure-coded chunk for this report. The validity of this chunk can be trivially proven through the work-report’s work-package erasure-root and a Merkle proof of inclusion in the correct location.  The proof should be included from the guarantor.&quot;  which QUIC message covers this proof _submission_ in JAMNP?
4. In section 16 &quot;Availability Assurance&quot;, you refer to &quot;provided&quot; and &quot;required&quot; manifests, seemingly for the first time (?), which appear to be &quot;inside&quot; the availability specifier $s$.  Are these ${\\bf b}^\\club$ (package, imported items, extrinsics related) and ${\\bf s}^\\club$  (exported items)-- which one is &quot;provided&quot; and which one is &quot;required&quot;?</div>
<div class='msg'><time>2024‑08‑24 07:02</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * gav: Some basic questions on Assurances.

1. From (185)+(186) _Availability Specifier_ $s$ (with h, l, u, e) ALONE (included in a Work Report), will an assurer/validator be able to reconstruct the _auditable_ work package (by querying fellow validators) after getting their chunk and a proof of inclusion using $s$ ALONE?  If not, what else does a \[non-guarantor\] assurer need other than $s$ from a `Guarantee` to reconstruct the _auditable_ work package (by querying fellow validators)?
2. If the answer to (1) is &quot;YES, s alone is sufficient for work package reconstruction (by querying fellow validators)&quot;, we need a _test case_ of a work package ${\\bf p}$ and some pretend exported items with this &quot;Availability Specifier&quot; $s$ computed (which is equivalent to a Auditable Work package and sufficient for assuring, if we understand correctly).  When can we get a ${\\bf}, s$ test case?  Having this will be essential for JAM implementers to have proper $E\_G$ verifiable work report generation and to get through a full $E\_A$ Assurance generation.
3. Given the proof referenced in Section 16 &quot;... Firstly, their erasure-coded chunk for this report. The validity of this chunk can be trivially proven through the work-report’s work-package erasure-root and a Merkle proof of inclusion in the correct location.  The proof should be included from the guarantor.&quot;  which QUIC message covers this proof _submission_ in JAMNP?
4. In section 16 &quot;Availability Assurance&quot;, you refer to &quot;provided&quot; and &quot;required&quot; manifests, seemingly for the first time, which appear to be &quot;inside&quot; the availability specifier $s$.  Are these ${\\bf b}^\\club$ (package, imported items, extrinsics related) and ${\\bf s}^\\club$  (exported items)-- which one is &quot;provided&quot; and which one is &quot;required&quot;?     (The 14.3 paragraph &quot;Guarantors are required to erasure-code and distribute two data sets:... &quot; which is similar enough to cause us to believe section 16 could be folded into 14.3?)</div>
<div class='msg'><time>2024‑08‑24 07:27</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * 5. What is $n$ in 185?</div>
<div class='msg'><time>2024‑08‑24 14:43</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * gav: Some basic questions on Assurances.

1. From (185)+(186) _Availability Specifier_ $s$ (with h, l, u, e) ALONE (included in a Work Report), will an assurer/validator be able to reconstruct the _auditable_ work package (by querying fellow validators) after getting their chunk and a proof of inclusion using $s$ ALONE?  If not, what else does a \[non-guarantor\] assurer need other than $s$ from a `Guarantee` to reconstruct the _auditable_ work package (by querying fellow validators)?
2. If the answer to (1) is &quot;YES, s alone is sufficient for work package reconstruction (by querying fellow validators)&quot;, we need a _test case_ of a work package ${\\bf p}$ and some pretend exported items with this &quot;Availability Specifier&quot; $s$ computed (which is equivalent to a Auditable Work package and sufficient for assuring, if we understand correctly).  When can we get a ${\\bf p}, {\bf e}, s$ test case?  Having this will be essential for JAM implementers to have proper $E\_G$ verifiable work report generation and to get through a full $E\_A$ Assurance generation.
3. Given the proof referenced in Section 16 &quot;... Firstly, their erasure-coded chunk for this report. The validity of this chunk can be trivially proven through the work-report’s work-package erasure-root and a Merkle proof of inclusion in the correct location.  The proof should be included from the guarantor.&quot;  ... which QUIC message covers this proof _submission_ by guarantors to all other validators in JAMNP?
4. In section 16 &quot;Availability Assurance&quot;, you refer to &quot;provided&quot; and &quot;required&quot; manifests, seemingly for the first time, which appear to be &quot;inside&quot; the availability specifier $s$.  Are these ${\\bf b}^\\club$ (package, imported items, extrinsics related) and ${\\bf s}^\\club$  (exported items)-- which one is &quot;provided&quot; and which one is &quot;required&quot;?     (The 14.3 paragraph &quot;Guarantors are required to erasure-code and distribute two data sets:... &quot; which is similar enough to cause us to believe section 16 could be folded into 14.3?)</div>
<div class='msg'><time>2024‑08‑24 14:52</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * 5. What is ${\bf s}$ vs $n$ within ${\bf s}[n]$ in 185?  The meaning of ${\bf s}$ flips between imported and exported items in this section so we&#x27;d like to confirm.  </div>
<div class='msg'><time>2024‑08‑24 16:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dave:parity.io&gt; We require that the code hashes in the guarantees extrinsic match the current code hashes for the relevant services. This may not be the case by the time the WRs are accumulated though? Is the intention that accumulation code should protect itself against this if necessary, eg by including a version in the refine output?

For the few blocks where a service is undergoing an upgrade then you’d probably want to avoid sending reports to it since it’s fundamentally impossible to predict which code is current come Accumulation. </div>
<div class='msg'><time>2024‑08‑24 16:57</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: </div>
<div class='msg'><time>2024‑08‑24 16:59</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; gav: Some basic questions on Assurances.
&gt; 
&gt; 1. From (185)+(186) _Availability Specifier_ $s$ (with h, l, u, e) ALONE (included in a Work Report), will an assurer/validator be able to reconstruct the _auditable_ work package (by querying fellow validators) after getting their chunk and a proof of inclusion using $s$ ALONE?  If not, what else does a \[non-guarantor\] assurer need other than $s$ from a `Guarantee` to reconstruct the _auditable_ work package (by querying fellow validators)?
&gt; 2. If the answer to (1) is &quot;YES, s alone is sufficient for work package reconstruction (by querying fellow validators)&quot;, we need a _test case_ of a work package ${\\bf p}$ and some pretend exported items with this &quot;Availability Specifier&quot; $s$ computed (which is equivalent to a Auditable Work package and sufficient for assuring, if we understand correctly).  When can we get a ${\\bf p}, {\bf e}, s$ test case?  Having this will be essential for JAM implementers to have proper $E\_G$ verifiable work report generation and to get through a full $E\_A$ Assurance generation.
&gt; 3. Given the proof referenced in Section 16 &quot;... Firstly, their erasure-coded chunk for this report. The validity of this chunk can be trivially proven through the work-report’s work-package erasure-root and a Merkle proof of inclusion in the correct location.  The proof should be included from the guarantor.&quot;  ... which QUIC message covers this proof _submission_ by guarantors to all other validators in JAMNP?
&gt; 4. In section 16 &quot;Availability Assurance&quot;, you refer to &quot;provided&quot; and &quot;required&quot; manifests, seemingly for the first time, which appear to be &quot;inside&quot; the availability specifier $s$.  Are these ${\\bf b}^\\club$ (package, imported items, extrinsics related) and ${\\bf s}^\\club$  (exported items)-- which one is &quot;provided&quot; and which one is &quot;required&quot;?     (The 14.3 paragraph &quot;Guarantors are required to erasure-code and distribute two data sets:... &quot; which is similar enough to cause us to believe section 16 could be folded into 14.3?)

1. I don’t understand the question. 
2. As I’ve said before, test cases will be provided once they are ready. I won’t repeat myself further. 
</div>
<div class='msg'><time>2024‑08‑24 17:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 3. I don’t know what you mean by “proof of submission”.</div>
<div class='msg'><time>2024‑08‑24 17:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Provided and required are old terminology. They’ll be removed in the next GP release. </div>
<div class='msg'><time>2024‑08‑24 17:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * 4. Provided and required are old terminology. They’ll be removed in the next GP release. </div>
<div class='msg'><time>2024‑08‑24 17:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 4. Provided and required are old terminology. They’ll be removed in the next GP release. Corrected here: https://github.com/gavofyork/graypaper/pull/65/commits/cc7e2bc87959bf851bcf34208312df9c28283cb2</div>
<div class='msg'><time>2024‑08‑24 17:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 3. I don’t know what you mean by “proof of submission”. In any case JAMSNP doesn&#x27;t presently include any message/stream type for providing DA chunks. It will be included in due course.</div>
<div class='msg'><time>2024‑08‑24 17:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; 5. What is ${\bf s}$ vs $n$ within ${\bf s}[n]$ in 185?  The meaning of ${\bf s}$ flips between imported and exported items in this section so we&#x27;d like to confirm.

I presume you mean:</div>
<div class='msg'><time>2024‑08‑24 17:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: image.png</div>
<div class='msg'><time>2024‑08‑24 17:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (Best to use the [Reader](https://graypaper.fluffylabs.dev/#WyJjNTZkZmI4NzYzIiwiMTEiLCJTZXJ2aWNlIEFjY291bnRzIiwiQWNjb3VudCBGb290cHJpbnQgYW5kIFRocmVzaG9sZCBCYWxhbmNlIixbIjxkaXYgY2xhc3M9XCJ0IG0wIHgxMSBoZSB5N2JmIGZmZiBmczAgZmMwIHNjMCBsczAgd3MwXCI+IiwiPGRpdiBjbGFzcz1cInQgbTAgeDQ4IGhiIHk3Y2IgZmYxMiBmczAgZmMwIHNjMCBsczAgd3MwXCI+Il1d) for referencing bits of the GP)</div>
<div class='msg'><time>2024‑08‑24 17:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Here, n is the index of a exported segment and M(s) is the segment root of the exporting work-report.</div>
<div class='msg'><time>2024‑08‑24 17:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: s is therefore the sequence of exported segments.</div>
<div class='msg'><time>2024‑08‑24 17:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 1. They&#x27;ll be able to ensure that the chunks they get from each validator is correct and that the bundle/work-package itself is correct. The bundle is all that is needed to audit.
2. As I’ve said before, test cases will be provided once they are ready. I won’t repeat myself further.</div>
<div class='msg'><time>2024‑08‑24 17:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 1. They&#x27;ll be able to ensure that the chunks they get from each validator is correct and that the bundle/work-package itself is correct. The bundle is all that is needed for a validator to audit.
2. As I’ve said before, test cases will be provided once they are ready. I won’t repeat myself further.</div>
<div class='msg'><time>2024‑08‑24 18:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: [0.3.6](https://github.com/gavofyork/graypaper/releases/tag/v0.3.6) is tagged and released.</div>
<div class='msg'><time>2024‑08‑24 18:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Here, n is the index of an exported segment and M(s) is the segment root of the exporting work-report.</div>
<div class='msg'><time>2024‑08‑24 18:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Here, M(s) is the segment root of the exporting work-report and n is the index of a segment exported by it.</div>
<div class='msg'><time>2024‑08‑24 18:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * s is therefore the sequence of exported segments from said exporting work-package.</div>
<div class='msg'><time>2024‑08‑24 18:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Here, M(s) is the segment root of the exporting work-package and n is the index of a segment exported by it.</div>
<div class='msg'><time>2024‑08‑24 18:25</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: &gt; &lt;@gav:polkadot.io&gt; 3. I don’t know what you mean by “proof of submission”. In any case JAMSNP doesn&#x27;t presently include any message/stream type for providing DA chunks. It will be included in due course.

By proof submission, I mean the &quot;The proof should be included from the guarantor.&quot;  I believe you stubbed as `JustifiedImport` in as `--&gt; Vec&lt;Extrinsic&gt; ++ Vec&lt;JustifiedImport&gt;` in https://hackmd.io/@polkadot/jamsnp , so we&#x27;ll run with that for now.</div>
<div class='msg'><time>2024‑08‑24 18:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; By proof submission, I mean the &quot;The proof should be included from the guarantor.&quot;  I believe you stubbed as `JustifiedImport` in as `--&gt; Vec&lt;Extrinsic&gt; ++ Vec&lt;JustifiedImport&gt;` in https://hackmd.io/@polkadot/jamsnp , so we&#x27;ll run with that for now.

That&#x27;s only for sharing of Work Packages between guarantors on the same core.</div>
<div class='msg'><time>2024‑08‑24 18:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There is not yet an instruction for sharing DA chunks.</div>
<div class='msg'><time>2024‑08‑24 18:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * There is not yet an instruction for sharing (justified) DA chunks.</div>
<div class='msg'><time>2024‑08‑24 18:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It&#x27;ll likely just be `Blob ++ Vec&lt;Hash&gt; ++ Vec&lt;SegmentChunk&gt; ++ Vec&lt;Hash&gt;`.</div>
<div class='msg'><time>2024‑08‑24 18:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * It&#x27;ll likely just be `Vec&lt;Hash&gt; ++ Blob ++ Vec&lt;Hash&gt; ++ Vec&lt;SegmentChunk&gt; ++ Vec&lt;Hash&gt;`.</div>
<div class='msg'><time>2024‑08‑24 18:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The `Vec&lt;Hash&gt;` will just be complementary Merkle-node-hashes from leaf to root. The first will contain hashes for the blob-subtree, the second for the segments subtree and the third for the super-tree.</div>
<div class='msg'><time>2024‑08‑24 20:23</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: &gt; &lt;@gav:polkadot.io&gt; 3. I don’t know what you mean by “proof of submission”. In any case JAMSNP doesn&#x27;t presently include any message/stream type for providing DA chunks. It will be included in due course.

 * By proof submission, I mean the &quot;The proof should be included from the guarantor.&quot;  I believe you stubbed  `JustifiedImport` in as `--&gt; Vec&lt;Extrinsic&gt; ++ Vec&lt;JustifiedImport&gt;` in https://hackmd.io/@polkadot/jamsnp , so we&#x27;ll run with that for now.</div>
<div class='msg'><time>2024‑08‑26 18:47</time>&ensp;<span class='u' style='color:#c65e4e'>noahjoeris</span>: image.png</div>
<div class='msg'><time>2024‑08‑26 18:47</time>&ensp;<span class='u' style='color:#c65e4e'>noahjoeris</span>: Heya. Isn&#x27;t the posterior authorizer pool also dependent on the header?</div>
<div class='msg reply'><time>2024‑09‑09 07:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Will be fixed in 0.3.7</div>
<div class='msg'><time>2024‑08‑26 18:48</time>&ensp;<span class='u' style='color:#c65e4e'>noahjoeris</span>: Because we use it here:</div>
<div class='msg'><time>2024‑08‑26 18:48</time>&ensp;<span class='u' style='color:#c65e4e'>noahjoeris</span>: image.png</div>
<div class='msg'><time>2024‑08‑26 18:50</time>&ensp;<span class='u' style='color:#c65e4e'>noahjoeris</span>:  * Because we use the header timeslot here:</div>
<div class='msg'><time>2024‑08‑26 23:58</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-08-27 at 11.57.19 AM.png</div>
<div class='msg'><time>2024‑08‑26 23:58</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: The return type for the merkle justification generation function is wrong</div>
<div class='msg reply'><time>2024‑09‑09 07:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Will be fixed in 0.3.7</div>
<div class='msg'><time>2024‑08‑27 01:23</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-08-27 at 1.22.50 PM.png</div>
<div class='msg'><time>2024‑08‑27 01:23</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: this need a special case to handle the case |v| is zero</div>
<div class='msg reply'><time>2024‑09‑09 07:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Will be fixed in 0.3.7</div>
<div class='msg'><time>2024‑08‑27 01:25</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-08-27 at 1.25.42 PM.png</div>
<div class='msg'><time>2024‑08‑27 01:26</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: this also using log2(|v|) which will be undefined when v is empty</div>
<div class='msg'><time>2024‑08‑27 01:27</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: and I am really confused about the `...max` part</div>
<div class='msg'><time>2024‑08‑27 01:28</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: it requires the length of v to be no more than `2^x` so `log2(|v|) - x`  is always &lt;= 0?</div>
<div class='msg'><time>2024‑08‑27 13:45</time>&ensp;<span class='u' style='color:#30c84d'>clw0908</span>: </div>
<div class='msg'><time>2024‑08‑27 14:00</time>&ensp;<span class='u' style='color:#30c84d'>clw0908</span>: Hello everyone,

When storing storage or preimage, we will specify the service identifier and the storage or preimage key at the same time, but we do not additionally store the mapping between the service identifier and the storage or preimage key.</div>
<div class='msg reply'><time>2024‑08‑28 02:37</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: my understand is that this is used to construct state root but it doesn&#x27;t means you also have to store the state into db with exactly this format</div>
<div class='msg reply'><time>2024‑08‑28 02:38</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: so you can/should store the keys in whatever format you want</div>
<div class='msg'><time>2024‑08‑27 14:00</time>&ensp;<span class='u' style='color:#30c84d'>clw0908</span>: 1.png</div>
<div class='msg'><time>2024‑08‑27 14:00</time>&ensp;<span class='u' style='color:#30c84d'>clw0908</span>: So assuming we have a service account identifier (s), how do we retrieve all of (s)&#x27;s storage(bold s) keys or preimage(bold p) keys?</div>
<div class='msg'><time>2024‑08‑27 14:00</time>&ensp;<span class='u' style='color:#30c84d'>clw0908</span>: 2.png</div>
<div class='msg'><time>2024‑08‑28 01:39</time>&ensp;<span class='u' style='color:#c377dd'>mkchung</span>: Screenshot 2024-08-27 at 6.29.11 PM.png</div>
<div class='msg'><time>2024‑08‑28 01:40</time>&ensp;<span class='u' style='color:#c377dd'>mkchung</span>: In host function new=9, what is the x_i used for creating the service account?

Additionally, for l∶{(c, l)↦[]} portion, are we writing this a_l on-chain, similar to the (h,z)=[] in the solicit=13 case? This should also trigger E_P, correct?</div>
<div class='msg'><time>2024‑08‑28 06:28</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Basic questions on Is-Authorized.
1. Why is the authorizer not a 4th entry point alongside refine/accumulate/on_transfer?
2. In (182) you use blob-hood of ${\bf o}$ (being an element of Y) to determine if work is authorized, but how does the PVM code actually return and &quot;set&quot; ${\bf o}$ -- not clear from (248) how Is-Authorized can return a blob. 
3. In 8.2 GP lecture you mention validating signatures, e.g. validating ${\bf j}$ right at the start of the work package.   Shall we add ECRECOVER/... signature verification host functions for this purpose?  
4. Why did you not support access to `historical_lookup` in Is-Authorization, to get at service-specific state?
</div>
<div class='msg reply'><time>2024‑08‑29 13:35</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Re (1) AIUI authorisation is for usage of a core, this usage is not tied to a particular service</div>
<div class='msg reply'><time>2024‑09‑09 08:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (2) Should be obvious from the PVM definition. If you panic then the result will not be in Y.</div>
<div class='msg reply'><time>2024‑09‑09 08:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (3) No.</div>
<div class='msg reply'><time>2024‑09‑09 08:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (4). IsAuthorized is intended to be as lightweight as possible to minimize the possibility of validator-griefing. This could potentially change in the future once we start actually writing code on JAM prototypes and understand the kinds of use-cases better.</div>
<div class='msg reply'><time>2024‑09‑09 08:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (5) See the answer to (3).</div>
<div class='msg'><time>2024‑08‑28 07:40</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: image.png</div>
<div class='msg'><time>2024‑08‑28 07:40</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: it looks to me that appendix F (304) is wrong. `4` should be added and  i&#x27; mont sure about the underlined red text. look like it does not make muc sense</div>
<div class='msg reply'><time>2024‑09‑09 08:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Will be fixed in 0.3.7</div>
<div class='msg'><time>2024‑08‑28 08:53</time>&ensp;<span class='u' style='color:#c77c36'>luke_f</span>: 6230937201131240805.jpg</div>
<div class='msg'><time>2024‑08‑28 08:54</time>&ensp;<span class='u' style='color:#c77c36'>luke_f</span>: Hello
I&#x27;m having a hard time understand Equation  141 

Specifically R is a constant as far as i can tell, but used as a function here?
</div>
<div class='msg reply'><time>2024‑08‑28 09:01</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: I also had the same question but I assumed in the end that it meant &quot;multiply&quot; R by (floor(tau/R) - 1)</div>
<div class='msg reply'><time>2024‑08‑28 09:07</time>&ensp;<span class='u' style='color:#c77c36'>luke_f</span>: oh i see that does make sense
Thank you</div>
<div class='msg'><time>2024‑08‑28 08:54</time>&ensp;<span class='u' style='color:#c77c36'>luke_f</span>:  * Hello
I&#x27;m having a hard time understanding Equation  141 

Specifically R is a constant as far as i can tell, but used as a function here?
</div>
<div class='msg'><time>2024‑08‑28 08:56</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: How is it that the PVM argument invocation can return a blob? [Here](https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMjgiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGMgaGIgeTE1YzEgZmZmIGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4MWE1IGhiIHkxNWMxIGZmZiBmczAgZmMwIHNjMCBsczAgd3MwXCI+Il1d) the return type is `( () )`</div>
<div class='msg reply'><time>2024‑08‑28 14:51</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Ok, we&#x27;ll run with your interpretation for now 😃, returning a &quot;panic&quot; being &quot;authorization failed&quot;, makes sense.</div>
<div class='msg reply'><time>2024‑08‑30 01:21</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: We realized (again) that passing in \omega_10 + \omega_11 is to be the way to send in &quot;a=arguments&quot; (refine: authorization hash, accumulate: wrangled results, transfer: transfer memos) and ALSO return a blob.</div>
<div class='msg'><time>2024‑08‑28 08:57</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>:  * How is it that the PVM argument invocation can return a blob? [Here](https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMjgiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGMgaGIgeTE1YzEgZmZmIGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4MWE1IGhiIHkxNWMxIGZmZiBmczAgZmMwIHNjMCBsczAgd3MwXCI+Il1d) the return type is `( (N_G, Y) U {panic, oom}, X )` but I don&#x27;t see that from the result of R</div>
<div class='msg'><time>2024‑08‑28 08:58</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>:  * How is it that the PVM argument invocation can return a blob? [Here](https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMjgiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGMgaGIgeTE1YzEgZmZmIGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4MWE1IGhiIHkxNWMxIGZmZiBmczAgZmMwIHNjMCBsczAgd3MwXCI+Il1d) the return type is `( (N_G, Y) U {panic, oom}, X )` but the inner function `R` seems to return `(status U N_G, X U Y)`</div>
<div class='msg'><time>2024‑08‑28 08:58</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>:  * How is it that the PVM argument invocation can return a blob? [Here](https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMjgiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGMgaGIgeTE1YzEgZmZmIGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4MWE1IGhiIHkxNWMxIGZmZiBmczAgZmMwIHNjMCBsczAgd3MwXCI+Il1d) the return type is `( (N_G, Y) U {panic, oom}, X )` but the inner function `R` seems to return `({panic, oom} U N_G, X U Y)`</div>
<div class='msg'><time>2024‑08‑28 09:03</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>:  * How is it that the PVM argument invocation can return a blob? I guess the memory addresses are the blob. [Here](https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMjgiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGMgaGIgeTE1YzEgZmZmIGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4MWE1IGhiIHkxNWMxIGZmZiBmczAgZmMwIHNjMCBsczAgd3MwXCI+Il1d) the return type is `( (N_G, Y) U {panic, oom}, X )` but the inner function `R` seems to return `({panic, oom} U N_G, X U Y)`</div>
<div class='msg'><time>2024‑08‑28 09:03</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>:  * How is it that the PVM argument invocation can return a blob? I guess the memory contents on a success are the blob. [Here](https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMjgiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGMgaGIgeTE1YzEgZmZmIGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4MWE1IGhiIHkxNWMxIGZmZiBmczAgZmMwIHNjMCBsczAgd3MwXCI+Il1d) the return type is `( (N_G, Y) U {panic, oom}, X )` but the inner function `R` seems to return `({panic, oom} U N_G, X U Y)`</div>
<div class='msg'><time>2024‑08‑28 11:10</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Basic questions on Is-Authorized.

1. Why is the authorizer not a 4th entry point alongside refine/accumulate/on\_transfer?
2. In (182) you use blob-hood of ${\\bf o}$ (being an element of Y) to determine if work is authorized, but how does the PVM code actually return and &quot;set&quot; ${\\bf o}$ -- not clear from (248) how Is-Authorized can return a blob.
3. In 8.2 GP lecture you mention validating signatures, e.g. validating ${\\bf j}$ right at the start of the work package.   Shall we add ECRECOVER/... signature verification host functions for this purpose?  
4. Why did you not support access to `historical_lookup` in Is-Authorization, to get at service-specific state?
5. It seems clear we will want &quot;opinionated&quot; inclusion of cryptographic primitives in ecalli host functions (BLS, hash functions, Bandersnatch, Edwards, etc) due to the usual &quot;interpreted code is Nx slower than compiled, we need this!&quot; concerns, right?</div>
<div class='msg'><time>2024‑08‑28 11:20</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Basic questions on Is-Authorized.

1. Why is the authorizer not a 4th entry point alongside refine/accumulate/on\_transfer?
2. In (182) you use blob-hood of ${\\bf o}$ (being an element of Y) to determine if work is authorized, but how does the PVM code actually return and &quot;set&quot; ${\\bf o}$ -- not clear from (248) how Is-Authorized can return a blob.
3. In 8.2 GP lecture you mention validating signatures, e.g. validating ${\\bf j}$ right at the start of the work package.   Shall we add ECRECOVER/... signature verification host functions for this purpose?
4. Why did you not support access to `historical_lookup` in Is-Authorized, to get at service-specific state?
5. It seems clear we will want &quot;opinionated&quot; inclusion of cryptographic primitives in ecalli host functions (BLS, Keccak/Blake2b/xx hash functions, Bandersnatch, Edwards, etc) due to the usual &quot;interpreted code is Nx slower than compiled, we must have this primitive!&quot; concerns.  How is this problem NOT going to immediately reveal itself on the first big JAM service (parachain validation) which uses all these must have primitives?</div>
<div class='msg'><time>2024‑08‑28 15:09</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Ok, we&#x27;ll run with your interpretation for now 😃, returning a &quot;panic&quot; being &quot;authorization failed&quot; if a new host function that we added to verify a signature against a hardcoded public key (or read via `historical_lookup`) doesn&#x27;t pass verification.  </div>
<div class='msg'><time>2024‑08‑28 23:52</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: General JAM question: Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a_p$ preimage writes through $E_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- *except* via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.   Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` them?  </div>
<div class='msg reply'><time>2024‑08‑29 13:48</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Re (4), AIUI the blessed services are always accumulated every block even if there are no work reports for them</div>
<div class='msg reply'><time>2024‑08‑29 15:38</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Yipes, I read (28) + Sect 11 &quot;After enough assurances the work-report is considered available, and the work outputs transform the state of their associated ser- vice by virtue of accumulation, covered in section 12. The report may also be timed-out, implying it may be replaced by another report without accumulation.&quot; + (162) input of refine results M(s) as all implying that accumulation REQUIRES refine.</div>
<div class='msg reply'><time>2024‑08‑29 15:50</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: For most services that is true -- accumulate will not be called unless some work reports have become available, the 3 blessed services are an exception to this. See (159)</div>
<div class='msg reply'><time>2024‑08‑29 15:58</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Ah blessed=privileged =)</div>
<div class='msg reply'><time>2024‑08‑29 15:59</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Ah yeah sorry, not sure where I got that term from</div>
<div class='msg reply'><time>2024‑09‑09 08:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 1. There is no jump table - only an entry point. These are now set to 0 (isAuthorized), 5 (Refine), 10 (Accumulate) and 15 (OnTransfer).</div>
<div class='msg reply'><time>2024‑09‑09 08:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: PVM code blobs use these to disambiguate usage.</div>
<div class='msg reply'><time>2024‑09‑09 08:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 2. Dumb Question.</div>
<div class='msg reply'><time>2024‑09‑09 08:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 3. Dumb Question.</div>
<div class='msg reply'><time>2024‑09‑09 08:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: sourabhniyogi: This is not a forum to request your (IMO totally unachievable) product dreams. If you have a serious suggestion to improve the JAM protocol, make a PR to the GP repo. Be ready to defend its implications against some of the best minds of the industry. Beware that designing and writing a high-performance secure decentralized protocol is nontrivial and you can&#x27;t just wish features to exist.</div>
<div class='msg reply'><time>2024‑09‑09 08:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 4. With the particular exception of the privileged services, a service cannot be accumulated without at least one refine result.</div>
<div class='msg reply'><time>2024‑09‑09 08:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 5. Any kind of panic works.</div>
<div class='msg reply'><time>2024‑09‑09 08:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 6. Your assertion is incorrect: there is no ordering. This is precisely the reason for [this paragraph](https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMTYiLCJBY2N1bXVsYXRpb24iLCJJbnZvY2F0aW9uIixbIjxkaXYgY2xhc3M9XCJ0IG0wIHgxMyBoNiB5YjkwIGZmNyBmczAgZmMwIHNjMCBsczAgd3MwXCI+IiwiPGRpdiBjbGFzcz1cInQgbTAgeDEwIGg2IHliOTYgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iXV0=).</div>
<div class='msg reply'><time>2024‑09‑09 08:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 7. Again your assertion is incorrect.</div>
<div class='msg reply'><time>2024‑09‑09 09:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 8. There is indeed a missing argument for Refine&#x27;s `lookup` case. This will be fixed in the next release. Read and info properly supply this parameter.</div>
<div class='msg reply'><time>2024‑09‑09 09:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 9. They are quite heavy-weight facilities and it is far from clear that they can be used effectively in the &lt;10ms of gas which Accumulate is given. This is something which might change as we begin writing prototype services.</div>
<div class='msg reply'><time>2024‑09‑09 09:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 10. It is fully defined [already](https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMTkiLCJXb3JrIFBhY2thZ2VzIGFuZCBXb3JrIFJlcG9ydHMiLCJDb21wdXRhdGlvbiBvZiBXb3JrIFJlc3VsdHMiLFsiPGRpdiBjbGFzcz1cInQgbTAgeGUgaGIgeWRhYyBmZmYgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiIsIjxkaXYgY2xhc3M9XCJ0IG0wIHgxNDUgaGIgeWRhYyBmZjFjIGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iXV0=)</div>
<div class='msg reply'><time>2024‑09‑10 09:07</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: &gt; &lt;@gav:polkadot.io&gt; 2. Regarding JAM, Refine -&gt; Accumulate is a one-way street and as such sensibly designed services must be able to perform Refine with some degree of asynchroneity to Accumulate. This is why I write that JAM is &quot;mostly coherent&quot;. Getting any state-changes resulting from Accumulation as inputs to a later Refine would imply making a state proof, which introduces synchroneity and as such a degree of latency.
&gt; 
&gt; Re: &quot;Why can&#x27;t...&quot;: Lazy and Dumb Question. If you think you can add such a feature without blowing up the protocol&#x27;s complexity, submit your PR to the GP repo.

You already have service users submitting a refinement context within the work package, which includes an anchor block&#x27;s state root but not an accumulate state root.  With Safrole, assuming very high liveness, you also won mostly forkless state roots.  

So my lazy dumb strawman is that you can win `historical_read` parallel to `historical_lookup` in `refine` by modifying the &quot;anchor block&quot; centric refinement context included in work packages to be have state roots
(a) relative to a anchor block
but instead
(b) whatever the work package submitter has observed to be a recent [potentially unfinalized] state root 
The user already have to submit their work packages relative to (a), so what is lost with (b)?  

I am not making a request for product dreams here 😅, I am asking why an observed unfinalized state root from the user is an insufficient state proof.  

If 2 or 3 Guarantors refine a work package according to some unfinalized state root but it doesn&#x27;t get finalized, then the work report doesn&#x27;t get assured, it doesn&#x27;t get audited, and so it just times out.   

The claim is that if this timeout is quite rare in practice, the experience for users improves tremendously with `historical_read` and a streamlined &quot;accumulate=&gt;refine&quot; .  I understand this is in the &quot;better to implement JAM to crawl before JAM walks/runs&quot; region here.  But you claim running with (b)&#x27;s aggressive refinement context is unachievable because ... what?
</div>
<div class='msg reply'><time>2024‑09‑10 09:09</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Typo: (252) should have &quot;historical_lookup&quot; instead of &quot;lookup&quot;</div>
<div class='msg reply'><time>2024‑09‑10 20:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; You already have service users submitting a refinement context within the work package, which includes an anchor block&#x27;s state root but not an unfinalized accumulate state root.  With Safrole, assuming very high liveness, you also won mostly forkless state roots.
&gt; 
&gt; So my lazy dumb strawman is that you can win `historical_read` parallel to `historical_lookup` in `refine` by modifying the &quot;anchor block&quot; centric refinement context included in work packages to be have state roots not
&gt; (a) relative to an anchor block
&gt; but instead
&gt; (b) whatever the work package submitter has observed to be a recent \[potentially unfinalized\] state root
&gt; The user already have to submit their work packages relative to (a), so what is lost with (b)?
&gt; 
&gt; I am not making a request for product dreams here 😅, I am asking why an observed unfinalized state root from the user is an insufficient state proof.
&gt; 
&gt; If 2 or 3 Guarantors refine a work package according to some unfinalized state root but it doesn&#x27;t get finalized, then the work report doesn&#x27;t get assured, it doesn&#x27;t get audited, and so it just times out.
&gt; 
&gt; The claim is that if this timeout is quite rare in practice, the experience for users improves tremendously with `historical_read` and a streamlined &quot;accumulate=&gt;refine&quot; .
&gt; 
&gt; The lazy/dumb GP modification would be extend what what you have in 9.2 &quot;By retaining historical information on its availability,
&gt; we become confident that any validator with a recently finalized view of the chain is able to determine whether any
&gt; given preimage was available at any time within the period
&gt; where auditing may occur.&quot; from preimages alone to what is done with `write` operations.  Still asynchronous post-write here, but with less latency than (a).
&gt; 
&gt; The new requirement is that any services aggressive work results (with aggressive (b)) would only be able to affect `accumulate` if the refinement context&#x27;s state root in conception (b) was finalized.   
&gt; 
&gt; I understand this is in the &quot;better to implement JAM to safely crawl before JAM walks/runs&quot; region here.  But you claim running with (b)&#x27;s aggressive refinement context is unachievable because ... what?

JAM (and Polkadot before it) is secure only because of Elves. Elves requires that all validators are able to audit all Work Reports *regardless of whether they’re synced to the right fork or not*. Historical lookup works only because we know, at any block up to 24 hours later, whether a preimage was known at the time and if so what it was. We manage this only with specialised data structures and limiting the rate at which a preimage may be supplied, removed and supplied again to avoid state blowup.</div>
<div class='msg reply'><time>2024‑09‑12 14:00</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Thank you very much for this explanation.  We will properly understand ELVES=&gt;JAM constraints to see if there is any way we could improve the JAM service developer/user experience.  </div>
<div class='msg'><time>2024‑08‑28 23:52</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM question: Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.   Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?</div>
<div class='msg'><time>2024‑08‑29 00:13</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM questions: 
1. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.   Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?

2. How there be a `refine` less Work Package / Service, not needing Assurances, that is purely `accumulate` based?

</div>
<div class='msg'><time>2024‑08‑29 00:33</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM questions:

1. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.   Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?  Or why can&#x27;t `refine` have access `read` host function written to by `accumulate` `write host function calls?  
2. How there be a `refine` less Work Package / Service, not needing Assurances, that is purely `accumulate` based?</div>
<div class='msg'><time>2024‑08‑29 00:34</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM questions:

1. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.   Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?  Or
2. Why can&#x27;t `refine` have access `read` host function written to by `accumulate` \`write host function calls?
3. How there be a `refine`-less Work Package / Service, *not* needing Assurances to trigger an `accumulate`, that is purely `accumulate` based?</div>
<div class='msg'><time>2024‑08‑29 00:37</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM questions:

1. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.     Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?  
2. Why can&#x27;t `refine` have access `read` host function written to by `accumulate` \`write host function calls?
3. How there be a `refine`-less Work Package / Service, _not_ needing Assurances to trigger an `accumulate`, that is purely `accumulate` based?</div>
<div class='msg'><time>2024‑08‑29 09:35</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM questions:
1. How are the `refine`, `accumulate` and `on_transfer` entry points (described after (90)) specified in the jump table ${\bf j}$ of Eq (213)?  We are currently just using `pub @refine:`, `pub @accumulate:` and `pub @on_transfer` in koute&#x27;s assembler, but this appears underspecified in GP. 
2. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.     Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?
3. Why can&#x27;t `refine` have access `read` host function written to by `accumulate` \`write host function calls?
4. How there be a `refine`-less Work Package / Service, _not_ needing Assurances to trigger an `accumulate`, that is purely `accumulate` based?
5. Is there an idiomatic way via a specific instruction to &quot;panic&quot; for authorization code to indicate &quot;Not Authorized&quot;?  We are doing `ecalli 42`.</div>
<div class='msg'><time>2024‑08‑29 09:59</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM questions:

1. How are the `refine`, `accumulate` and `on_transfer` entry points (described after (90)) specified in the jump table ${\\bf j}$ of Eq (213)?  We are currently just using `pub @refine:`, `pub @accumulate:` and `pub @on_transfer` in koute&#x27;s assembler, but this appears underspecified in GP.
2. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.     Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?
3. Why can&#x27;t `refine` have access `read` host function written to by `accumulate` \`write host function calls?
4. How there be a `refine`-less Work Package / Service, _not_ needing Assurances to trigger an `accumulate`, that is purely `accumulate` based?
5. Is there an idiomatic way via a specific instruction to &quot;panic&quot; for authorization code to indicate &quot;Not Authorized&quot;?  We are doing `ecalli 42` as a hack right now on failed authorizations.</div>
<div class='msg'><time>2024‑08‑29 10:00</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM Service Invocation/Interaction-related questions:

1. How are the `refine`, `accumulate` and `on_transfer` entry points (described after (90)) specified in the jump table ${\\bf j}$ of Eq (213)?  We are currently just using `pub @refine:`, `pub @accumulate:` and `pub @on_transfer` in koute&#x27;s assembler, but this appears underspecified in GP.
2. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.     Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?
3. Why can&#x27;t `refine` have access `read` host function written to by `accumulate` \`write host function calls?
4. How there be a `refine`-less Work Package / Service, _not_ needing Assurances to trigger an `accumulate`, that is purely `accumulate` based?
5. What is the idiomatic way (via a specific instruction) to &quot;panic&quot; for authorization code to return &quot;Not Authorized&quot;?  We are doing `ecalli 42` as a hack right now on failed authorizations.</div>
<div class='msg'><time>2024‑08‑29 10:01</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM Service Invocation/Interaction-related questions:

1. How are the `refine`, `accumulate` and `on_transfer` entry points (described after (90)) specified in the jump table ${\\bf j}$ of Eq (213)?  We are currently just using `pub @refine:`, `pub @accumulate:` and `pub @on_transfer` in koute&#x27;s assembler, but this appears underspecified in GP.
2. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.     Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?
3. Why can&#x27;t `refine` have access `read` host function written to by `accumulate` \`write host function calls?
4. How there be a `refine`-less Work Package / Service, _not_ needing Assurances to trigger an `accumulate`, that is purely `accumulate` based?
5. What is the *idiomatic* way (via a specific instruction) to &quot;panic&quot; for authorization code to return &quot;Not Authorized&quot;?  We are doing `ecalli 42` as a hack right now on failed authorizations.</div>
<div class='msg'><time>2024‑08‑29 11:37</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: </div>
<div class='msg'><time>2024‑08‑29 11:40</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * In Section B.4 &quot;Concretely, we create the identifier from the Blake2 hash of the identifier of the creating service, the current random accumulator η0 and the block’s timeslot.&quot; demands a matching equation or adjustment to Eq (259).

Also (252) should use `historical_lookup` instead of `lookup`</div>
<div class='msg'><time>2024‑08‑29 11:42</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM Service Invocation/Interaction-related questions:

1. How are the `refine`, `accumulate` and `on_transfer` entry points (described after (90)) specified in the jump table ${\\bf j}$ of Eq (213)?  We are currently just using `pub @refine:`, `pub @accumulate:` and `pub @on_transfer` in koute&#x27;s assembler, but this appears underspecified in GP.
2. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.     Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?
3. Why can&#x27;t `refine` have access `read` host function written to by `accumulate` \`write host function calls?
4. How can there be a `refine`-less Work Package / Service, _not_ needing Assurances to trigger an `accumulate`, that is purely `accumulate` based?
5. What is the _idiomatic_ way (via a specific instruction) to &quot;panic&quot; for authorization code to return &quot;Not Authorized&quot;?  We are doing `ecalli 42` as a hack right now on failed authorizations.</div>
<div class='msg'><time>2024‑08‑29 11:44</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM Service Invocation/Interaction-related questions:

1. How are the `refine`, `accumulate` and `on_transfer` entry points (described after (90)) specified in the jump table ${\\bf j}$ of Eq (213)?  We are currently just using `pub @refine:`, `pub @accumulate:` and `pub @on_transfer` in koute&#x27;s assembler, but this appears underspecified in GP.
2. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.     Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?
3. Why can&#x27;t `refine` have access to `read` host function to get at state written to by `accumulate`&#x27;s `write` host function calls?
4. How can there be a `refine`-less Work Package / Service, _not_ needing Assurances to trigger an `accumulate`, that is purely `accumulate` based?
5. What is the _idiomatic_ way (via a specific instruction) to &quot;panic&quot; for authorization code to return &quot;Not Authorized&quot;?  We are doing `ecalli 42` as a hack right now on failed authorizations.</div>
<div class='msg'><time>2024‑08‑29 18:07</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM Service Invocation/Interaction-related questions:

1. How are the `refine`, `accumulate` and `on_transfer` entry points (described after (90)) specified in the jump table ${\\bf j}$ of Eq (213)?  We are currently just using `pub @refine:`, `pub @accumulate:` and `pub @on_transfer` in koute&#x27;s assembler, but this appears underspecified in GP.
2. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.     Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?
3. Why can&#x27;t `refine` have access to `read` host function to get at state written to by `accumulate`&#x27;s `write` host function calls?  I imagine it would be `historical_read`, analogous to `historical_lambda`. 
4. How can there be a `refine`-less Work Package / Service, _not_ needing Assurances to trigger an `accumulate`, that is purely `accumulate` based?
5. What is the _idiomatic_ way (via a specific instruction) to &quot;panic&quot; for authorization code to return &quot;Not Authorized&quot;?  We are doing `ecalli 42` as a hack right now on failed authorizations.</div>
<div class='msg'><time>2024‑08‑29 18:07</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM Service Invocation/Interaction-related questions:

1. How are the `refine`, `accumulate` and `on_transfer` entry points (described after (90)) specified in the jump table ${\\bf j}$ of Eq (213)?  We are currently just using `pub @refine:`, `pub @accumulate:` and `pub @on_transfer` in koute&#x27;s assembler, but this appears underspecified in GP.
2. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.     Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?
3. Why can&#x27;t `refine` have access to `read` host function to get at state written to by `accumulate`&#x27;s `write` host function calls?  I imagine it would be `historical_read`, analogous to `historical_lookup`.
4. How can there be a `refine`-less Work Package / Service, _not_ needing Assurances to trigger an `accumulate`, that is purely `accumulate` based?
5. What is the _idiomatic_ way (via a specific instruction) to &quot;panic&quot; for authorization code to return &quot;Not Authorized&quot;?  We are doing `ecalli 42` as a hack right now on failed authorizations.</div>
<div class='msg'><time>2024‑08‑29 23:08</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * (160) should have $l: ${\bf r}_l$ to match 11.1.4&#x27;s eq (121) for the hash of the payload.
(252) should use `historical_lookup` instead of `lookup`</div>
<div class='msg'><time>2024‑08‑29 23:29</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * (160) should have $l: {\\bf r}\_l$ to match 11.1.4&#x27;s eq (121) for the hash of the payload.
(252) should use `historical_lookup` instead of `lookup`</div>
<div class='msg'><time>2024‑08‑29 23:40</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: </div>
<div class='msg'><time>2024‑08‑29 23:40</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: </div>
<div class='msg'><time>2024‑08‑30 01:18</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Basic questions on Is-Authorized.

1. Why is the authorizer not a 4th entry point alongside refine/accumulate/on\_transfer?
2. In (182) you use blob-hood of ${\\bf o}$ (being an element of Y) to determine if work is authorized, but how does the PVM code actually return and &quot;set&quot; ${\\bf o}$ -- not clear from (248) how Is-Authorized can return a blob, e.g. a public key or recovered address.  Is it through \omega_10 + \omega_11 pointing to where the blob is returned in memory?   If so what is the &quot;not authorized&quot; return mechanism?
3. In 8.2 GP lecture you mention validating signatures, e.g. validating ${\\bf j}$ right at the start of the work package.   Shall we add ECRECOVER/... signature verification host functions for this purpose?
4. Why did you not support access to `historical_lookup` in Is-Authorized, to get at service-specific state?
5. It seems clear we will want &quot;opinionated&quot; inclusion of cryptographic primitives in ecalli host functions (BLS, Keccak/Blake2b/xx hash functions, Bandersnatch, Edwards, etc) due to the usual &quot;interpreted code is Nx slower than compiled, we must have this primitive!&quot; concerns.  How is this problem NOT going to immediately reveal itself on the first big JAM service (parachain validation) which uses all these must have primitives?</div>
<div class='msg'><time>2024‑08‑31 03:58</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM Service Invocation/Interaction-related questions:

1. How are the `refine`, `accumulate` and `on_transfer` entry points (described after (90)) specified in the jump table ${\\bf j}$ of Eq (213)?  We are currently just using `pub @refine:`, `pub @accumulate:` and `pub @on_transfer` in koute&#x27;s assembler, but this appears underspecified in GP.
2. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.     Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?
3. Why can&#x27;t `refine` have access to `read` host function to get at state written to by `accumulate`&#x27;s `write` host function calls?  I imagine it would be `historical_read`, analogous to `historical_lookup`.
4. How can there be a `refine`-less Work Package / Service, _not_ needing Assurances to trigger an `accumulate`, that is purely `accumulate` based?
5. What is the _idiomatic_ way (via a specific instruction) to &quot;panic&quot; for authorization code to return &quot;Not Authorized&quot;?  We are doing `ecalli 42` as a hack right now on failed authorizations.
6. For multiple services going through `accumulate` what is the ordering of ${\bf S}$ in 157?  Assuming serial execution (which is sort of implied by `new` [building up ${\bf x}_n$] and `transfer` [building up ${\bf x}_{\bf s}$]), is the context ${\bf x}$ (of Eq 253) carried over from one services `accumulate` to the next?  
7. From `upgrade` It appears to us that the invocation context ${\bf x}$ in ${\bf X}$ needs its ${\bf s}$ to be a dictionary like ${\bf x}_{\bf n}$, but right now its just ${\bf s}$ of ${\cal A}?$.

</div>
<div class='msg'><time>2024‑08‑31 04:12</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM Service Invocation/Interaction-related questions:

1. How are the `refine`, `accumulate` and `on_transfer` entry points (described after (90)) specified in the jump table ${\\bf j}$ of Eq (213)?  We are currently just using `pub @refine:`, `pub @accumulate:` and `pub @on_transfer` in koute&#x27;s assembler, but this appears underspecified in GP.
2. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.     Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?
3. Why can&#x27;t `refine` have access to `read` host function to get at state written to by `accumulate`&#x27;s `write` host function calls?  I imagine it would be `historical_read`, analogous to `historical_lookup`.
4. How can there be a `refine`-less Work Package / Service, _not_ needing Assurances to trigger an `accumulate`, that is purely `accumulate` based?
5. What is the _idiomatic_ way (via a specific instruction) to &quot;panic&quot; for authorization code to return &quot;Not Authorized&quot;?  We are doing `ecalli 42` as a hack right now on failed authorizations.
6. For multiple services going through `accumulate` what is the ordering of ${\\bf S}$ in 157?  Assuming serial execution (which is sort of implied by `new` \[building up ${\\bf x}_n$\] and `transfer` \[building up ${\\bf x}_{\\bf s}$\]), is the context ${\\bf x}$ (of Eq 253) carried over from one services `accumulate` to the next?
7. From `upgrade` It appears to us that the invocation context ${\\bf x}$ in ${\\bf X}$ needs its ${\\bf s}$ to be a dictionary like ${\\bf x}\_{\\bf n}$, but right now its just ${\\bf s}$ of ${\\cal A}?$.
8. Host function service account lookup ${\bf d}$  needs an explanation before B.5 On-transfer.  It is used in `lookup`, `read`, `info` but we&#x27;re not sure whether its in ${\bf x}$ and how its initialized.</div>
<div class='msg'><time>2024‑08‑31 09:25</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM Service Invocation/Interaction-related questions:

1. How are the `refine`, `accumulate` and `on_transfer` entry points (described after (90)) specified in the jump table ${\\bf j}$ of Eq (213)?  We are currently just using `pub @refine:`, `pub @accumulate:` and `pub @on_transfer` in koute&#x27;s assembler, but this appears underspecified in GP.
2. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.     Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?
3. Why can&#x27;t `refine` have access to `read` host function to get at state written to by `accumulate`&#x27;s `write` host function calls?  I imagine it would be `historical_read`, analogous to `historical_lookup`.
4. How can there be a `refine`-less Work Package / Service, _not_ needing Assurances to trigger an `accumulate`, that is purely `accumulate` based?
5. What is the _idiomatic_ way (via a specific instruction) to &quot;panic&quot; for authorization code to return &quot;Not Authorized&quot;?  We are doing `ecalli 42` as a hack right now on failed authorizations.
6. For multiple services going through `accumulate` what is the ordering of ${\\bf S}$ in 157?  Assuming serial execution (which is sort of implied by `new` \[building up ${\\bf x}_n$\] and `transfer` \[building up ${\\bf x}_{\\bf s}$\]), is the context ${\\bf x}$ (of Eq 253) carried over from one services `accumulate` to the next?
7. From `upgrade` It appears to us that the invocation context ${\\bf x}$ in ${\\bf X}$ needs its ${\\bf s}$ to be a dictionary like ${\\bf x}\_{\\bf n}$, but right now its just ${\\bf s}$ of ${\\cal A}?$.
8. Host function service account lookup ${\\bf d}$  needs an explanation before B.5 On-transfer.  It is used in `lookup`, `read`, `info` but we&#x27;re not sure whether its in ${\\bf x}$ and how its initialized.
9. Why did you keep machine/invoke/peek/poke/expunge solely for `refine` and not also `accumulate`?</div>
<div class='msg'><time>2024‑09‑01 13:06</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM Service Invocation/Interaction-related questions:

1. How are the `refine`, `accumulate` and `on_transfer` entry points (described after (90)) specified in the jump table ${\\bf j}$ of Eq (213)?  We are currently just using `pub @refine:`, `pub @accumulate:` and `pub @on_transfer` in koute&#x27;s assembler, but this appears underspecified in GP.
2. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.     Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?
3. Why can&#x27;t `refine` have access to `read` host function to get at state written to by `accumulate`&#x27;s `write` host function calls?  I imagine it would be `historical_read`, analogous to `historical_lookup`.
4. How can there be a `refine`-less Work Package / Service, _not_ needing Assurances to trigger an `accumulate`, that is purely `accumulate` based?
5. What is the _idiomatic_ way (via a specific instruction) to &quot;panic&quot; for authorization code to return &quot;Not Authorized&quot;?  We are doing `ecalli 42` as a hack right now on failed authorizations.
6. For multiple services going through `accumulate` what is the ordering of ${\\bf S}$ in 157?  Assuming serial execution (which is sort of implied by `new` \[building up ${\\bf x}_n$\] and `transfer` \[building up ${\\bf x}_{\\bf s}$\]), is the context ${\\bf x}$ (of Eq 253) carried over from one services `accumulate` to the next?
7. From `upgrade` It appears to us that the invocation context ${\\bf x}$ in ${\\bf X}$ needs its ${\\bf s}$ to be a dictionary like ${\\bf x}\_{\\bf n}$, but right now its just ${\\bf s}$ of ${\\cal A}?$.
8. Host function service account lookup ${\\bf d}$  needs an explanation before B.5 On-transfer.  It is used in `lookup`, `read`, `info` but we&#x27;re not sure whether its in ${\\bf x}$ and how its initialized.
9. Why did you keep machine/invoke/peek/poke/expunge solely for `refine` and not also `accumulate`?
10. $\bar{x}$, the full extrinsic data (not hash-len combo) given to the guarantors alongside the work package, needs to be put into Audit DA, since re-execution of `refine` by auditors require it.  This step is not described, but is of course necessary, correct?</div>
<div class='msg'><time>2024‑09‑04 03:11</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * General JAM Service Invocation/Interaction-related questions:

1. How are the `refine`, `accumulate` and `on_transfer` entry points (described after (90)) specified in the jump table ${\\bf j}$ of Eq (213)?  We are currently just using `pub @refine:`, `pub @accumulate:` and `pub @on_transfer` in koute&#x27;s assembler, but this appears underspecified in GP except for some 0/1/2 entry points 
2. Given that `refine` can ONLY access on-chain state from `historical_lookup` host function calls (through `accumulate`&#x27;s `solicit` host function calls that result in $a\_p$ preimage writes through $E\_P$ extrinsics) ... I am struggling to see how `accumulate` can drive `refine` inputs -- _except_ via some observer who &quot;sees&quot; the finalized post-accumulate state and submits a new work package based on that state in the form of extrinsics and payloads.     Why can&#x27;t `accumulate` also have access to the `export` host function such that `refine` can `import` segments exported by `accumulate`?
3. Why can&#x27;t `refine` have access to `read` host function to get at state written to by `accumulate`&#x27;s `write` host function calls?  I imagine it would be `historical_read`, analogous to `historical_lookup`.
4. How can there be a `refine`-less Work Package / Service, _not_ needing Assurances to trigger an `accumulate`, that is purely `accumulate` based?
5. What is the _idiomatic_ way (via a specific instruction) to &quot;panic&quot; for authorization code to return &quot;Not Authorized&quot;?  We are doing `ecalli 42` as a hack right now on failed authorizations.
6. For multiple services going through `accumulate` what is the ordering of ${\\bf S}$ in 157?  Assuming serial execution (which is sort of implied by `new` \[building up ${\\bf x}_n$\] and `transfer` \[building up ${\\bf x}_{\\bf s}$\]), is the context ${\\bf x}$ (of Eq 253) carried over from one services `accumulate` to the next?
7. From `upgrade` It appears to us that the invocation context ${\\bf x}$ in ${\\bf X}$ needs its ${\\bf s}$ to be a dictionary like ${\\bf x}\_{\\bf n}$, but right now its just ${\\bf s}$ of ${\\cal A}?$.
8. Host function service account lookup ${\\bf d}$  needs an explanation before B.5 On-transfer.  It is used in `lookup`, `read`, `info` but we&#x27;re not sure whether its in ${\\bf x}$ and how its initialized.
9. Why did you keep machine/invoke/peek/poke/expunge solely for `refine` and not also `accumulate`?
10. $\\bar{x}$, the full extrinsic data (not hash-len combo) given to the guarantors alongside the work package, needs to be put into Audit DA, since re-execution of `refine` by auditors require it.  This step is not described, but is of course necessary, correct?</div>
<div class='msg'><time>2024‑09‑04 03:33</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: some questions about dispute and audit:

1. Since H_V has been removed in this version, how will s_0 and s_n be affected in the audit?
2. Will disputes enter a special voting phase if someone casts a false judgement during each tranche settlement? I would like to know the details of how E_D is formed.</div>
<div class='msg reply'><time>2024‑09‑04 09:28</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: AIUI H_V, like the other markers, was (intentionally) redundant. It simply provided verdict information for those downloading only headers, not block extrinsics. All validators need to download full blocks, so its removal makes no difference to them (other than not having to generate it etc obviously)</div>
<div class='msg reply'><time>2024‑09‑04 09:32</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: Sorry, I might not have been clear. H_V still exists in the generation of s, so is it simply being removed from the function?</div>
<div class='msg reply'><time>2024‑09‑04 09:34</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMWIiLCJBdWRpdGluZyBhbmQgSnVkZ2luZyIsIlNlbGVjdGlvbiBvZiBSZXBvcnRzIixbIjxkaXYgY2xhc3M9XCJ0IG0wIHhiZCBoMiB5ZTZjIGZmMWMgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiIsIjxkaXYgY2xhc3M9XCJ0IG0wIHgxMjQgaGQgeWU2YiBmZjE4IGZzNSBmYzAgc2MwIGxzMCB3czBcIj4iXV0=</div>
<div class='msg reply'><time>2024‑09‑04 09:35</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Ah sorry think there is some confusion. H_j is what was removed</div>
<div class='msg reply'><time>2024‑09‑04 09:36</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: H_v still exists</div>
<div class='msg reply'><time>2024‑09‑04 09:36</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: The above applies to H_j</div>
<div class='msg reply'><time>2024‑09‑04 09:36</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: There may be changes I&#x27;m not aware of though</div>
<div class='msg reply'><time>2024‑09‑04 09:41</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: my bad, that H_j is header verdict XD

Regarding dispute voting, what are your thoughts?
</div>
<div class='msg reply'><time>2024‑09‑04 09:45</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Re (2) if a node sees a negative judgement for a report, then it should start auditing it if it hasn&#x27;t already. I&#x27;m not sure if it&#x27;s supposed to send out an announcement in this case; I would guess this is not necessary, but probably also harmless.</div>
<div class='msg reply'><time>2024‑09‑04 09:49</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: got it, so next is to convert the judgments into Verdict and move on to the logic in Chapter 10. Thank you!</div>
<div class='msg reply'><time>2024‑09‑04 09:52</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: &gt; &lt;@dave:parity.io&gt; Re (2) if a node sees a negative judgement for a report, then it should start auditing it if it hasn&#x27;t already. I&#x27;m not sure if it&#x27;s supposed to send out an announcement in this case; I would guess this is not necessary, but probably also harmless.

In the case that there is a negative judgement, it is thus expected that all validators will produce a judgement. If a block author has seen enough judgements to build a verdict then they will do this.</div>
<div class='msg reply'><time>2024‑09‑04 10:06</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: I see. You’re so nice! Tks</div>
<div class='msg'><time>2024‑09‑04 09:42</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>:  * some questions about dispute and audit:

 Will disputes enter a special voting phase if someone casts a false judgement during each tranche settlement? I would like to know the details of how E\_D is formed.</div>
<div class='msg'><time>2024‑09‑04 20:07</time>&ensp;<span class='u' style='color:#cc572f'>mateuszsikora</span>: Hey, correct me if I am wrong but there is no specification in GP how to handle out of memory in PVM. We have 2 cases:
1. A generic program without memory segmentation. In this case we start from empty memory and we can call `sbrk` until the memory exceed 2 ** 32. what should happen then? 
2. A &quot;standard program initialization&quot; program. In this case we have heap between 2Z_Q + Q(|o|)  and 2**32 - 2Z_Q - Z_I - P(s) (beginning of stack segment). what should happen when the memory that we allocated exceeds the heap segment?

I guess in both cases it should be a page fault but what should be the address then? we don&#x27;t pass any address to `sbrk` so there is no any strict point where this fault could happen</div>
<div class='msg reply'><time>2024‑09‑05 17:38</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Memory allocation/deallocation handling is still a work-in-progress, and it&#x27;s possible the `sbrk` instruction will get modified and/or removed. I&#x27;d suggest you temporarily skip it and focus on other parts of JAM and/or PVM.

----------------------

If you&#x27;re interested in some history as to why `sbrk` is there then let me give you some background.

Historically I designed PolkaVM (on which PVM in the GP is based on) to be a VM which is as &quot;powerful&quot; as WASM VMs (so it can completely replace our current WASM-based executor in Polkadot 1.0 and our WASM-based smart contracts VM) while being as simple as possible to implement, and without sacrificing any performance.
So this is where the idea for the `sbrk` came from (which is similar to what WASM has): the VM maintains a heap pointer, and the guest program can use `sbrk` to query that pointer and/or to bump it up. And every time it crosses a page boundary the VM allocates new memory for the program.

So this design has numerous benefits. First, it&#x27;s very simple to use as a guest program (pseudo code):

```
    // Get a pointer to the new allocation.
    let pointer = sbrk(0);
    // Actually allocate it.
    if sbrk(size) != 0 {
        // Allocation succeeded.
        // Now `pointer` points to `size` bytes you can use.
    }
```

This is also great for use cases like e.g. tiny smart contracts which can use this as directly as an allocator without having to bring a heavyweight allocator of their own (which would consume a lot of space).

Secondly, it&#x27;s simple to implement in the VM, something like that (pseudo code again):

```
fn sbrk(size) -&gt; Pointer {
    if size == 0 {
        // The guest wants to know the current heap pointer.
        return current_heap_pointer;
    }

    // The guest wants to allocate.
    let new_heap_pointer = current_heap_pointer + size;
    if new_heap_pointer &gt; max_heap_pointer {
        // Allocation failed.
        return 0;
    }


    let next_page_boundary = align_to_page_size(current_heap_pointer);
    if new_heap_pointer &gt; next_page_boundary {
        allocate_new_pages(next_page_boundary..align_to_page_size(new_heap_pointer));
    }

    current_heap_pointer += size;
    return current_heap_pointer;
```

And this (along with the memory map I came up with, which is what we now call &quot;standard program initialization&quot;) also makes in very easy to write an interpreter for this, because when handling loads/stores from memory you only have to do something like this:

```
fn load_value32(address) -&gt; value {
    if address &gt;= stack_address &amp;&amp; address + 4 &lt;= stack_address_end {
        return stack[address - stack_address];
    } else if address &gt;= rw_data_address &amp;&amp; address + 4 &lt;= align_to_page_size(current_heap_pointer) {
        return rw_data[address - stack_address];
    } else if address &gt;= ro_data_address &amp;&amp; address + 4 &lt;= ro_data_address_end {
        return ro_data[address - stack_address];
    } else {
        // Address is inaccessible.
        return Err;
    }
}
```

It&#x27;s cheap, fast, and doesn&#x27;t require any crazy data structures and doesn&#x27;t require any handling of corner cases (for example, accesses which could read both from the stack and from RW data don&#x27;t have to be handled, because they&#x27;re impossible by definition; the interpreter can just keep them in separate arrays, and call it a day).

So that&#x27;s how (any why) it **was* originally designed, but then came JAM and changed things. (: (Again, remember, I started working on this **before** JAM, and some things were just grandfathered into JAM.)

What JAM introduces is a concept of inner VMs (see `machine`, `peek`, `poke`, `invoke` and `expunge` host functions in section B.8 of the GP) where one VM can spawn another VM, and as it is currently designed those inner VMs are extremely flexible and have completely free-form memories and are dynamically paged.
What this essentially means is that all of those nice properties of `sbrk` that I&#x27;ve listed - simple and easy to implement, fast, doesn&#x27;t require fancy data structures - they all now go out of the window!

So we will probably be replacing `sbrk` with something else that&#x27;s more appropriate for the more flexible inner VM model. And unfortunately also most likely orders of magnitude harder to implement (at least if you want to reach at least the half-speed milestone), but it is what it is. I&#x27;m still finishing some other stuff up, but I&#x27;ll most likely be working on this soon-ish. (If any of you have any good and/or crazy ideas feel free to message me!)
</div>
<div class='msg reply'><time>2024‑09‑09 06:54</time>&ensp;<span class='u' style='color:#cc572f'>mateuszsikora</span>: Thank you Jan Bujak, that clarifies a lot. It would be nice to include a note in the GP that `sbrk` might be modified or removed, and it is advisable not to implement it yet</div>
<div class='msg'><time>2024‑09‑05 17:39</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>:  * Memory allocation/deallocation handling is still a work-in-progress, and it&#x27;s possible the `sbrk` instruction will get modified and/or removed. I&#x27;d suggest you temporarily skip it and focus on other parts of JAM and/or PVM.

---

If you&#x27;re interested in some history as to why `sbrk` is there then let me give you some background.

Historically I designed PolkaVM (on which PVM in the GP is based on) to be a VM which is as &quot;powerful&quot; as WASM VMs (so it can completely replace our current WASM-based executor in Polkadot 1.0 and our WASM-based smart contracts VM) while being as simple as possible to implement, and without sacrificing any performance.
So this is where the idea for the `sbrk` came from (which is similar to what WASM has): the VM maintains a heap pointer, and the guest program can use `sbrk` to query that pointer and/or to bump it up. And every time it crosses a page boundary the VM allocates new memory for the program.

So this design has numerous benefits. First, it&#x27;s very simple to use as a guest program (pseudo code):

```
    // Get a pointer to the new allocation.
    let pointer = sbrk(0);
    // Actually allocate it.
    if sbrk(size) != 0 {
        // Allocation succeeded.
        // Now `pointer` points to `size` bytes you can use.
    }
```

This is also great for use cases like e.g. tiny smart contracts which can use this as directly as an allocator without having to bring a heavyweight allocator of their own (which would consume a lot of space).

Secondly, it&#x27;s simple to implement in the VM, something like that (pseudo code again):

```
fn sbrk(size) -&gt; Pointer {
    if size == 0 {
        // The guest wants to know the current heap pointer.
        return current_heap_pointer;
    }

    // The guest wants to allocate.
    let new_heap_pointer = current_heap_pointer + size;
    if new_heap_pointer &gt; max_heap_pointer {
        // Allocation failed.
        return 0;
    }


    let next_page_boundary = align_to_page_size(current_heap_pointer);
    if new_heap_pointer &gt; next_page_boundary {
        allocate_new_pages(next_page_boundary..align_to_page_size(new_heap_pointer));
    }

    current_heap_pointer += size;
    return current_heap_pointer;
```

And this (along with the memory map I came up with, which is what we now call &quot;standard program initialization&quot;) also makes in very easy to write an interpreter for this, because when handling loads/stores from memory you only have to do something like this:

```
fn load_value32(address) -&gt; value {
    if address &gt;= stack_address &amp;&amp; address + 4 &lt;= stack_address_end {
        return stack[address - stack_address];
    } else if address &gt;= rw_data_address &amp;&amp; address + 4 &lt;= align_to_page_size(current_heap_pointer) {
        return rw_data[address - stack_address];
    } else if address &gt;= ro_data_address &amp;&amp; address + 4 &lt;= ro_data_address_end {
        return ro_data[address - stack_address];
    } else {
        // Address is inaccessible.
        return Err;
    }
}
```

It&#x27;s cheap, fast, and doesn&#x27;t require any crazy data structures and doesn&#x27;t require any handling of corner cases (for example, accesses which could read both from the stack and from RW data don&#x27;t have to be handled, because they&#x27;re impossible by definition; the interpreter can just keep them in separate arrays, and call it a day).

So that&#x27;s how (any why) it __was__ originally designed, but then came JAM and changed things. (: (Again, remember, I started working on this **before** JAM, and some things were just grandfathered into JAM.)

What JAM introduces is a concept of inner VMs (see `machine`, `peek`, `poke`, `invoke` and `expunge` host functions in section B.8 of the GP) where one VM can spawn another VM, and as it is currently designed those inner VMs are extremely flexible and have completely free-form memories and are dynamically paged.
What this essentially means is that all of those nice properties of `sbrk` that I&#x27;ve listed - simple and easy to implement, fast, doesn&#x27;t require fancy data structures - they all now go out of the window!

So we will probably be replacing `sbrk` with something else that&#x27;s more appropriate for the more flexible inner VM model. And unfortunately also most likely orders of magnitude harder to implement (at least if you want to reach at least the half-speed milestone), but it is what it is. I&#x27;m still finishing some other stuff up, but I&#x27;ll most likely be working on this soon-ish. (If any of you have any good and/or crazy ideas feel free to message me!)</div>
<div class='msg'><time>2024‑09‑06 00:49</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-09-06 at 12.49.05 PM.png</div>
<div class='msg'><time>2024‑09‑06 00:49</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: This appears to be the original version described in wikipedia, not the modern version?</div>
<div class='msg reply'><time>2024‑09‑06 08:53</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Looks like it ! Modern version looks a bit simpler to implement as well</div>
<div class='msg reply'><time>2024‑09‑06 08:53</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Modern version requires random variables j in [0, i] in the loop, and function Q_l (equation 306) is said to be constrained to [0, l]. So it should be possible to use the modern version.

PS: I don&#x27;t see why Q_l result is contained in [0, l] but in the meantime I assume this hypothesis (I don&#x27;t understand the 4i modulo 32 to be honest).</div>
<div class='msg reply'><time>2024‑09‑09 09:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Will be fixed in 0.3.7.</div>
<div class='msg'><time>2024‑09‑06 00:49</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: thus much less efficient</div>
<div class='msg'><time>2024‑09‑06 03:22</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-09-06 at 3.22.21 PM.png</div>
<div class='msg'><time>2024‑09‑06 03:22</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I am trying to understand this, which doesn&#x27;t make much sense to me</div>
<div class='msg'><time>2024‑09‑06 03:23</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: the R is used as a function but isn&#x27;t it a constant? </div>
<div class='msg reply'><time>2024‑09‑06 08:34</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: I think R here refers to the rotation period 10 (appendix I.4.4) and it mean multiply \* R by (floor(tau&#x27;/R) -1)</div>
<div class='msg reply'><time>2024‑09‑06 08:35</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: oh that make sense. thanks </div>
<div class='msg'><time>2024‑09‑06 03:23</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-09-06 at 3.23.38 PM.png</div>
<div class='msg'><time>2024‑09‑06 03:24</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: if it is referring to this R (in that case the font isn&#x27;t right), it takes two arguments</div>
<div class='msg'><time>2024‑09‑06 03:26</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: and the last part just isn&#x27;t making sense to me. the only logical interoperation I can come up with is that it is a typo that suppose to limit some t passing to the function R as the second argument?</div>
<div class='msg'><time>2024‑09‑06 08:34</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: </div>
<div class='msg'><time>2024‑09‑06 08:34</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>:  * I think R here refers to the rotation period 10 (appendix I.4.4) and it means multiply \* R by (floor(tau&#x27;/R) -1)</div>
<div class='msg'><time>2024‑09‑06 20:16</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Screenshot 2024-09-06 at 21.16.52.png</div>
<div class='msg'><time>2024‑09‑06 20:17</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Hi. I have a doubt about the definition of erasure-coding function. Is it a recursive function? If so, what is the base case? 

</div>
<div class='msg'><time>2024‑09‑06 20:17</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: What is the difference between Ck and C?</div>
<div class='msg'><time>2024‑09‑06 20:26</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: The only place I see C defined is here:</div>
<div class='msg'><time>2024‑09‑06 20:26</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Screenshot 2024-09-06 at 21.26.30.png</div>
<div class='msg'><time>2024‑09‑09 06:59</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: Hi, I would like to inquire about the explanation for this function. Last week, others were discussing it as well, but it seems that no one knows the reason for this subscript.

https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMzUiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeDE4OCBoYiB5MjBkMCBmZjE2IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4MTM5IGhiIHkyMGQwIGZmMTYgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==</div>
<div class='msg'><time>2024‑09‑09 07:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; it requires the length of v to be no more than `2^x` so `log2(|v|) - x`  is always &lt;= 0?

The outcome is that it skips the final $x$ items of the proof.</div>
<div class='msg'><time>2024‑09‑09 07:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The `ceil(log_2(|v|))` just gives the (generally maximum, but here constant) number of nodes from root to leaf. Substracting x would result in a negative number in the case that there are fewer than 2^x leaves. So we clamp it to zero and take only the first such proof items.</div>
<div class='msg'><time>2024‑09‑09 07:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: This is useful since we know we&#x27;ll get a well-aligned subtree of 2**x data items and thus need only proof data to get it from the root to the sub-tree root.</div>
<div class='msg'><time>2024‑09‑09 07:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * This is useful since we know we&#x27;ll get a well-aligned subtree of 2\*\*x data items (the &quot;page&quot;) and thus need only proof data to get it from the root to the sub-tree root.</div>
<div class='msg'><time>2024‑09‑09 07:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Consequently, if there are no more items in total than the items on our page, our proof can be empty (i.e. the subtree root is equal to the root)</div>
<div class='msg'><time>2024‑09‑09 07:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Consequently, if there are no more items in total than the items on our page, our proof can be empty (i.e. the subtree root is equal to the root). This where the `max(0, ...)` comes from.</div>
<div class='msg'><time>2024‑09‑09 07:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@clw0908:matrix.org&gt; So assuming we have a service account identifier (s), how do we retrieve all of (s)&#x27;s storage(bold s) keys or preimage(bold p) keys?

It is never required to enumerate storage or preimage. </div>
<div class='msg'><time>2024‑09‑09 07:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@clw0908:matrix.org&gt; So assuming we have a service account identifier (s), how do we retrieve all of (s)&#x27;s storage(bold s) keys or preimage(bold p) keys?

 * It is never required to enumerate a service&#x27;s storage keys or preimages.</div>
<div class='msg'><time>2024‑09‑09 08:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@mkchung:matrix.org&gt; In host function new=9, what is the x_i used for creating the service account?
&gt; 
&gt; Additionally, for l∶{(c, l)↦[]} portion, are we writing this a_l on-chain, similar to the (h,z)=[] in the solicit=13 case? This should also trigger E_P, correct?

x is the context, x_i is initially defined here https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMjkiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeDE2IGhiIHkxNzk5IGZmZiBmczAgZmMwIHNjMCBsczAgd3MwXCI+IiwiPGRpdiBjbGFzcz1cInQgbTAgeGQ2IGhiIHkxNzk5IGZmMTYgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ== though it is mutated with every `new`.</div>
<div class='msg'><time>2024‑09‑09 08:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * (3) No, PVM is fast enough. This isn&#x27;t Ethereum.</div>
<div class='msg'><time>2024‑09‑09 08:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * (3) PVM should really be fast enough. This isn&#x27;t Ethereum.</div>
<div class='msg'><time>2024‑09‑09 08:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: </div>
<div class='msg'><time>2024‑09‑09 08:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@cisco:parity.io&gt; How is it that the PVM argument invocation can return a blob? I guess the memory contents on a success are the blob. [Here](https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMjgiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGMgaGIgeTE1YzEgZmZmIGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4MWE1IGhiIHkxNWMxIGZmZiBmczAgZmMwIHNjMCBsczAgd3MwXCI+Il1d) the return type is `( (N_G, Y) U {panic, oom}, X )` but the inner function `R` seems to return `({panic, oom} U N_G, X U Y)`

Fixed in https://github.com/gavofyork/graypaper/pull/72/commits/38de2e265096cb1cbcaa31e9ce445a4e7e771b91</div>
<div class='msg'><time>2024‑09‑09 08:25</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: &gt; &lt;@gav:polkadot.io&gt; Fixed in https://github.com/gavofyork/graypaper/pull/72/commits/38de2e265096cb1cbcaa31e9ce445a4e7e771b91

Everything&#x27;s clear now, thanks!</div>
<div class='msg'><time>2024‑09‑09 08:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 1. There is no explicit jump table - only an entry point. These are now set to 0 (isAuthorized), 5 (Refine), 10 (Accumulate) and 15 (OnTransfer).</div>
<div class='msg'><time>2024‑09‑09 08:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 2. Lazy and Dumb Question.</div>
<div class='msg'><time>2024‑09‑09 08:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 3. Lazy and Dumb Question.</div>
<div class='msg'><time>2024‑09‑09 08:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 4. With the particular exception of the privileged services, a service cannot be accumulated without at least one refine result. So in short, there cannot.</div>
<div class='msg'><time>2024‑09‑09 08:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 4. With the particular exception of the privileged services, a service cannot be accumulated without at least one refine result. So in short, there generally cannot.</div>
<div class='msg'><time>2024‑09‑09 08:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 4. With the particular exception of the privileged services, a service cannot be accumulated without at least one refine result. So in short, there generally cannot. I&#x27;ve covered this many, many times in basically every talk I&#x27;ve given. Please familiarise yourself with this content. I&#x27;m not here to be your personal oracle, spoon-feeding you with material at your own pace.</div>
<div class='msg'><time>2024‑09‑09 08:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 4. With the particular exception of the privileged services, a service cannot be accumulated without at least one refine result. So in short, there generally cannot.
I&#x27;ve covered this many, many times in basically every talk I&#x27;ve given. Please familiarise yourself with this content. I&#x27;m not here to be your personal oracle, spoon-feeding you with material at your own pace.</div>
<div class='msg'><time>2024‑09‑09 08:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 5. Any kind of panic works, but if you want a convention, I&#x27;d used `trap`.</div>
<div class='msg'><time>2024‑09‑09 08:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 5. Any kind of panic works, but if you want a convention, I&#x27;d use `trap`.</div>
<div class='msg'><time>2024‑09‑09 08:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 2. Regarding JAM, Refine -&gt; Accumulate is a one-way street and as such sensibly designed services must be able to perform Refine with some degree of asynchroneity to Accumulate. This is why I write that JAM is &quot;mostly coherent&quot;. Getting any state-changes resulting from Accumulation as inputs to a later Refine would imply making a state proof, which introduces synchroneity and as such a degree of latency.

Re: &quot;Why can&#x27;t...&quot;: Lazy and Dumb Question.</div>
<div class='msg'><time>2024‑09‑09 08:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 3. Lazy and Dumb Question. If you think you can add such a feature without blowing up the protocol&#x27;s complexity, submit your PR to the GP repo.</div>
<div class='msg'><time>2024‑09‑09 08:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 2. Regarding JAM, Refine -&gt; Accumulate is a one-way street and as such sensibly designed services must be able to perform Refine with some degree of asynchroneity to Accumulate. This is why I write that JAM is &quot;mostly coherent&quot;. Getting any state-changes resulting from Accumulation as inputs to a later Refine would imply making a state proof, which introduces synchroneity and as such a degree of latency.

Re: &quot;Why can&#x27;t...&quot;: Lazy and Dumb Question. If you think you can add such a feature without blowing up the protocol&#x27;s complexity, submit your PR to the GP repo.</div>
<div class='msg'><time>2024‑09‑09 09:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 8. There is indeed a missing argument for Refine&#x27;s `lookup` case. This will be fixed in the next release. Refine&#x27;s `read` and `info` cases properly supply this parameter.</div>
<div class='msg'><time>2024‑09‑09 09:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: </div>
<div class='msg'><time>2024‑09‑09 09:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; Hi. I have a doubt about the definition of erasure-coding function. Is it a recursive function? If so, what is the base case?

It is not.</div>
<div class='msg'><time>2024‑09‑09 09:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; The only place I see C defined is here:

C_k is the &quot;true&quot; definition, and it assumes an input of data in multiples of 684 bytes, and this multiple is the number of &quot;chunks&quot;, k. The k subscript may generally be elided since the number of chunks is implied by the input, but sometimes I put it in regardless to make things clearer. </div>
<div class='msg'><time>2024‑09‑09 09:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@shwchg:matrix.org&gt; Hi, I would like to inquire about the explanation for this function. Last week, others were discussing it as well, but it seems that no one knows the reason for this subscript.
&gt; 
&gt; https://graypaper.fluffylabs.dev/#WyJlMjA2ZTI2NjNjIiwiMzUiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeDE4OCBoYiB5MjBkMCBmZjE2IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4MTM5IGhiIHkyMGQwIGZmMTYgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==

We use a 256-bit hash-sequence to create a 32-bit integer sequence. It would be wasteful to use all 256 bits of entropy for just 32 bits of entropy (and a secure hash does have some compute cost). So we hash only every 8th item and otherwise simply the hashes into 8 x 32 bit (4 byte) pieces and use each individually.</div>
<div class='msg'><time>2024‑09‑09 09:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * We use a 256-bit hash-sequence to create a 32-bit integer sequence. It would be wasteful to full 256-bit hash for just 32 bits of entropy. So we do a hash only every 8th item and otherwise take the 256-bits of the hash and split it into 8 32-bit integers.</div>
<div class='msg'><time>2024‑09‑09 19:36</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Screenshot 2024-09-09 at 20.36.35.png</div>
<div class='msg'><time>2024‑09‑09 19:37</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: this formula is a little bit confusing because pc has two meanings here and the letters &quot;c&quot; are almost identical </div>
<div class='msg'><time>2024‑09‑09 19:38</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>:  * this formula is a little bit confusing because pc has two meanings here and the letters &quot;c&quot; are almost identical. </div>
<div class='msg'><time>2024‑09‑10 01:47</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-09-10 at 1.47.36 PM.png</div>
<div class='msg'><time>2024‑09‑10 01:47</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-09-10 at 1.47.53 PM.png</div>
<div class='msg'><time>2024‑09‑10 01:48</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: the arguments order appears to be swapped for g &amp; o</div>
<div class='msg reply'><time>2024‑09‑10 06:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Will be fixed in 0.3.7</div>
<div class='msg'><time>2024‑09‑10 05:13</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-09-10 at 5.13.41 PM.png</div>
<div class='msg'><time>2024‑09‑10 05:15</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I don&#x27;t fully get this part. Firstly I think the code hash of a service can never be null. And when o is empty, it returns what? The same service account? But what about other fields in the return context?</div>
<div class='msg'><time>2024‑09‑10 05:16</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: and it is not invoking PVM when o is empty array, which I am not sure is correct. the only case this can be triggered are for privilege services and it should still invoke PVM when there is no work result to accumulate?</div>
<div class='msg'><time>2024‑09‑10 05:34</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-09-10 at 5.34.29 PM.png</div>
<div class='msg'><time>2024‑09‑10 05:35</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I also need some clarification about this regards to privileged services without work report</div>
<div class='msg'><time>2024‑09‑10 05:36</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: when there are two work result for a service, does it receive 2 minimal accumulation gas + (gas ratio * remain gas)? or 1 minimal gas?</div>
<div class='msg'><time>2024‑09‑10 05:36</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: how about privileged services without work result? they should still receive the minimal accumulation gas right?</div>
<div class='msg'><time>2024‑09‑10 06:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; this formula is a little bit confusing because pc has two meanings here and the letters &quot;c&quot; are almost identical.

It only has one meaning; the two lines are complementary. One defines the set it belongs to (i.e. its &quot;type&quot;) and the other defines the value within this set.</div>
<div class='msg'><time>2024‑09‑10 06:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; sent an image.

The two uses of c are related, but I&#x27;ll change the codehash to u in https://github.com/gavofyork/graypaper/pull/72</div>
<div class='msg'><time>2024‑09‑10 07:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; and it is not invoking PVM when o is empty array, which I am not sure is correct. the only case this can be triggered are for privilege services and it should still invoke PVM when there is no work result to accumulate?

Yes on both counts. Should be addressed by https://github.com/gavofyork/graypaper/pull/72/commits/f8ba4adcbb5982403cf35061a149d38826a3379e.</div>
<div class='msg'><time>2024‑09‑10 07:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; I don&#x27;t fully get this part. Firstly I think the code hash of a service can never be null. And when o is empty, it returns what? The same service account? But what about other fields in the return context?

This is not comparing the hash but the code itself, which can be null in the case that the service doesn&#x27;t currently host the preimage of its code hash.</div>
<div class='msg'><time>2024‑09‑10 07:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; when there are two work result for a service, does it receive 2 minimal accumulation gas + (gas ratio * remain gas)? or 1 minimal gas?

Yes, the function implies this.</div>
<div class='msg'><time>2024‑09‑10 07:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; when there are two work result for a service, does it receive 2 minimal accumulation gas + (gas ratio * remain gas)? or 1 minimal gas?

 * Yes, the function implies this, since it is taking the sum over all work results attributable to the given service.</div>
<div class='msg'><time>2024‑09‑10 07:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Yes, the function implies this, since it is taking the sum over all work results attributable to the given service, and each element of that sum includes the minimum accumulation gas together with its share of the remainder of the core.</div>
<div class='msg'><time>2024‑09‑10 07:15</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: how about the minimum accumulation gas from privileged services if they don&#x27;t have any work results?</div>
<div class='msg'><time>2024‑09‑10 07:16</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: the remaining gas should also subtract those?</div>
<div class='msg'><time>2024‑09‑10 07:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: </div>
<div class='msg'><time>2024‑09‑10 07:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * At present, that&#x27;s zero according to the formula.</div>
<div class='msg'><time>2024‑09‑10 07:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; how about the minimum accumulation gas from privileged services if they don&#x27;t have any work results?

At present, that&#x27;s zero according to the formula.</div>
<div class='msg'><time>2024‑09‑10 07:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; the remaining gas should also subtract those?

?</div>
<div class='msg'><time>2024‑09‑10 07:20</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: so if the gas is zero for privileged services without work results, then why include them in S? invoke those with zero gas surely wouldn’t yield anything other than OOG?</div>
<div class='msg'><time>2024‑09‑10 07:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yeah, it&#x27;s not final, I&#x27;m just describing correct behaviour at present.</div>
<div class='msg'><time>2024‑09‑10 08:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; so if the gas is zero for privileged services without work results, then why include them in S? invoke those with zero gas surely wouldn’t yield anything other than OOG?

https://github.com/gavofyork/graypaper/pull/75</div>
<div class='msg'><time>2024‑09‑10 09:18</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * You already have service users submitting a refinement context within the work package, which includes an anchor block&#x27;s state root but not an accumulate state root.  With Safrole, assuming very high liveness, you also won mostly forkless state roots.

So my lazy dumb strawman is that you can win `historical_read` parallel to `historical_lookup` in `refine` by modifying the &quot;anchor block&quot; centric refinement context included in work packages to be have state roots
(a) relative to a anchor block
but instead
(b) whatever the work package submitter has observed to be a recent \[potentially unfinalized\] state root
The user already have to submit their work packages relative to (a), so what is lost with (b)?

I am not making a request for product dreams here 😅, I am asking why an observed unfinalized state root from the user is an insufficient state proof.

If 2 or 3 Guarantors refine a work package according to some unfinalized state root but it doesn&#x27;t get finalized, then the work report doesn&#x27;t get assured, it doesn&#x27;t get audited, and so it just times out.

The claim is that if this timeout is quite rare in practice, the experience for users improves tremendously with `historical_read` and a streamlined &quot;accumulate=&gt;refine&quot; .   

The lazy/dumb GP modification would be extend what what you have in 9.2 &quot;By retaining historical information on its availability,
we become confident that any validator with a recently finalized view of the chain is able to determine whether any
given preimage was available at any time within the period
where auditing may occur.&quot; from preimages alone to what is done with `write` operations.  

I understand this is in the &quot;better to implement JAM to crawl before JAM walks/runs&quot; region here.  But you claim running with (b)&#x27;s aggressive refinement context is unachievable because ... what?</div>
<div class='msg'><time>2024‑09‑10 09:20</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * You already have service users submitting a refinement context within the work package, which includes an anchor block&#x27;s state root but not an accumulate state root.  With Safrole, assuming very high liveness, you also won mostly forkless state roots.

So my lazy dumb strawman is that you can win `historical_read` parallel to `historical_lookup` in `refine` by modifying the &quot;anchor block&quot; centric refinement context included in work packages to be have state roots
(a) relative to a anchor block
but instead
(b) whatever the work package submitter has observed to be a recent \[potentially unfinalized\] state root
The user already have to submit their work packages relative to (a), so what is lost with (b)?

I am not making a request for product dreams here 😅, I am asking why an observed unfinalized state root from the user is an insufficient state proof.

If 2 or 3 Guarantors refine a work package according to some unfinalized state root but it doesn&#x27;t get finalized, then the work report doesn&#x27;t get assured, it doesn&#x27;t get audited, and so it just times out.

The claim is that if this timeout is quite rare in practice, the experience for users improves tremendously with `historical_read` and a streamlined &quot;accumulate=&gt;refine&quot; .

The lazy/dumb GP modification would be extend what what you have in 9.2 &quot;By retaining historical information on its availability,
we become confident that any validator with a recently finalized view of the chain is able to determine whether any
given preimage was available at any time within the period
where auditing may occur.&quot; from preimages alone to what is done with `write` operations.  Still asynchronous post-write here, but with less latency than (a).  

Ok... you&#x27;re right, having `refine` get at the services on-chain state that&#x27;s the dream.  I understand this is in the &quot;better to implement JAM to crawl before JAM walks/runs&quot; region here.  But you claim running with (b)&#x27;s aggressive refinement context is unachievable because ... what?</div>
<div class='msg'><time>2024‑09‑10 09:23</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * You already have service users submitting a refinement context within the work package, which includes an anchor block&#x27;s state root but not an unfinalized accumulate state root.  With Safrole, assuming very high liveness, you also won mostly forkless state roots.

So my lazy dumb strawman is that you can win `historical_read` parallel to `historical_lookup` in `refine` by modifying the &quot;anchor block&quot; centric refinement context included in work packages to be have state roots not
(a) relative to an anchor block
but instead
(b) whatever the work package submitter has observed to be a recent \[potentially unfinalized\] state root
The user already have to submit their work packages relative to (a), so what is lost with (b)?

I am not making a request for product dreams here 😅, I am asking why an observed unfinalized state root from the user is an insufficient state proof.

If 2 or 3 Guarantors refine a work package according to some unfinalized state root but it doesn&#x27;t get finalized, then the work report doesn&#x27;t get assured, it doesn&#x27;t get audited, and so it just times out.

The claim is that if this timeout is quite rare in practice, the experience for users improves tremendously with `historical_read` and a streamlined &quot;accumulate=&gt;refine&quot; .

The lazy/dumb GP modification would be extend what what you have in 9.2 &quot;By retaining historical information on its availability,
we become confident that any validator with a recently finalized view of the chain is able to determine whether any
given preimage was available at any time within the period
where auditing may occur.&quot; from preimages alone to what is done with `write` operations.  Still asynchronous post-write here, but with less latency than (a).

Ok... you&#x27;re right, having `refine` get at the services on-chain state that&#x27;s the dream.  I understand this is in the &quot;better to implement JAM to crawl before JAM walks/runs&quot; region here.  But you claim running with (b)&#x27;s aggressive refinement context is unachievable because ... what?</div>
<div class='msg'><time>2024‑09‑10 09:24</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * You already have service users submitting a refinement context within the work package, which includes an anchor block&#x27;s state root but not an unfinalized accumulate state root.  With Safrole, assuming very high liveness, you also won mostly forkless state roots.

So my lazy dumb strawman is that you can win `historical_read` parallel to `historical_lookup` in `refine` by modifying the &quot;anchor block&quot; centric refinement context included in work packages to be have state roots not
(a) relative to an anchor block
but instead
(b) whatever the work package submitter has observed to be a recent \[potentially unfinalized\] state root
The user already have to submit their work packages relative to (a), so what is lost with (b)?

I am not making a request for product dreams here 😅, I am asking why an observed unfinalized state root from the user is an insufficient state proof.

If 2 or 3 Guarantors refine a work package according to some unfinalized state root but it doesn&#x27;t get finalized, then the work report doesn&#x27;t get assured, it doesn&#x27;t get audited, and so it just times out.

The claim is that if this timeout is quite rare in practice, the experience for users improves tremendously with `historical_read` and a streamlined &quot;accumulate=&gt;refine&quot; .

The lazy/dumb GP modification would be extend what what you have in 9.2 &quot;By retaining historical information on its availability,
we become confident that any validator with a recently finalized view of the chain is able to determine whether any
given preimage was available at any time within the period
where auditing may occur.&quot; from preimages alone to what is done with `write` operations.  Still asynchronous post-write here, but with less latency than (a).

Ok... you&#x27;re right, having `refine` get at the services on-chain state would be the dream.  I understand this is in the &quot;better to implement JAM to crawl before JAM walks/runs&quot; region here.  But you claim running with (b)&#x27;s aggressive refinement context is unachievable because ... what?</div>
<div class='msg'><time>2024‑09‑10 09:34</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * You already have service users submitting a refinement context within the work package, which includes an anchor block&#x27;s state root but not an unfinalized accumulate state root.  With Safrole, assuming very high liveness, you also won mostly forkless state roots.

So my lazy dumb strawman is that you can win `historical_read` parallel to `historical_lookup` in `refine` by modifying the &quot;anchor block&quot; centric refinement context included in work packages to be have state roots not
(a) relative to an anchor block
but instead
(b) whatever the work package submitter has observed to be a recent \[potentially unfinalized\] state root
The user already have to submit their work packages relative to (a), so what is lost with (b)?

I am not making a request for product dreams here 😅, I am asking why an observed unfinalized state root from the user is an insufficient state proof.

If 2 or 3 Guarantors refine a work package according to some unfinalized state root but it doesn&#x27;t get finalized, then the work report doesn&#x27;t get assured, it doesn&#x27;t get audited, and so it just times out.

The claim is that if this timeout is quite rare in practice, the experience for users improves tremendously with `historical_read` and a streamlined &quot;accumulate=&gt;refine&quot; .

The lazy/dumb GP modification would be extend what what you have in 9.2 &quot;By retaining historical information on its availability,
we become confident that any validator with a recently finalized view of the chain is able to determine whether any
given preimage was available at any time within the period
where auditing may occur.&quot; from preimages alone to what is done with `write` operations.  Still asynchronous post-write here, but with less latency than (a).  

The new requirement is that aggressive work results would only be able to affect `accumulate` if the refinement context&#x27;s state root in conception (b) was finalized.   I understand this is in the &quot;better to implement JAM to safely crawl before JAM walks/runs&quot; region here.  But you claim running with (b)&#x27;s aggressive refinement context is unachievable because ... what?</div>
<div class='msg'><time>2024‑09‑10 09:37</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * You already have service users submitting a refinement context within the work package, which includes an anchor block&#x27;s state root but not an unfinalized accumulate state root.  With Safrole, assuming very high liveness, you also won mostly forkless state roots.

So my lazy dumb strawman is that you can win `historical_read` parallel to `historical_lookup` in `refine` by modifying the &quot;anchor block&quot; centric refinement context included in work packages to be have state roots not
(a) relative to an anchor block
but instead
(b) whatever the work package submitter has observed to be a recent \[potentially unfinalized\] state root
The user already have to submit their work packages relative to (a), so what is lost with (b)?

I am not making a request for product dreams here 😅, I am asking why an observed unfinalized state root from the user is an insufficient state proof.

If 2 or 3 Guarantors refine a work package according to some unfinalized state root but it doesn&#x27;t get finalized, then the work report doesn&#x27;t get assured, it doesn&#x27;t get audited, and so it just times out.

The claim is that if this timeout is quite rare in practice, the experience for users improves tremendously with `historical_read` and a streamlined &quot;accumulate=&gt;refine&quot; .

The lazy/dumb GP modification would be extend what what you have in 9.2 &quot;By retaining historical information on its availability,
we become confident that any validator with a recently finalized view of the chain is able to determine whether any
given preimage was available at any time within the period
where auditing may occur.&quot; from preimages alone to what is done with `write` operations.  Still asynchronous post-write here, but with less latency than (a).

The new requirement is that any services aggressive work results (with aggressive (b)) would only be able to affect `accumulate` if the refinement context&#x27;s state root in conception (b) was finalized.   

I understand this is in the &quot;better to implement JAM to safely crawl before JAM walks/runs&quot; region here.  But you claim running with (b)&#x27;s aggressive refinement context is unachievable because ... what?</div>
<div class='msg'><time>2024‑09‑10 20:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * JAM (and Polkadot before it) is secure only because of Elves. Elves requires that all validators are able to audit all Work Reports *regardless of whether they’re synced to the right fork or not*. All host functions available to Refine must return exactly the same result for any node on any fork. Since we cannot assume any particular state is known (even the lookup anchor block’s state) then our host functions must be pretty much stateless. Historical lookup works only because we know, at any block up to 24 hours later, whether a preimage was known at the time and if so what it was. We manage this only with specialised data structures (in accounts) and limiting the rate at which a preimage may be supplied, removed and supplied again to avoid state blowup. This can all be discovered by a thorough read of the GP.</div>
<div class='msg'><time>2024‑09‑10 20:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * JAM (and Polkadot before it) is secure only because of Elves. Elves requires that all validators are able to audit all Work Reports *regardless of whether they’re synced to the same fork or not*. All host functions available to Refine must return exactly the same result for any node on any fork. Since we cannot assume any particular state is known (even the lookup anchor block’s state) then our host functions must be pretty much stateless. Historical lookup works only because we know, at any block up to 24 hours later, whether a preimage was known at the time and if so what it was. We manage this only with specialised data structures (in accounts) and limiting the rate at which a preimage may be supplied, removed and supplied again to avoid state blowup. This can all be discovered by a thorough read of the GP.</div>
<div class='msg'><time>2024‑09‑10 20:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * JAM (and Polkadot before it) is secure only because of Elves. Elves requires that all validators are able to audit all Work Reports *regardless of whether they’re synced to the same fork or not*. All host functions available to Refine must return exactly the same result for any node on any fork beyond the lookup-anchor. Since we cannot assume any particular state is known (even the lookup anchor block’s state) then our host functions must be pretty much stateless. Historical lookup works only because we know, at any block up to 24 hours later, whether a preimage was known at the time and if so what it was. We manage this only with specialised data structures (in accounts) and limiting the rate at which a preimage may be supplied, removed and supplied again to avoid state blowup. This can all be discovered by a thorough read of the GP.</div>
<div class='msg'><time>2024‑09‑10 20:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * JAM (and Polkadot before it) is secure only because of Elves. Elves requires that all validators are able to audit all Work Reports *regardless of whether they’re synced to the same fork or not*. All host functions available to Refine must return exactly the same result for any node on any fork beyond the lookup-anchor. Since we cannot assume any particular state is known (even the lookup anchor block’s state, which could be very old and is likely pruned) then our host functions must be pretty much stateless. Historical lookup works only because we know, at any block up to 24 hours later, whether a preimage was known at the time and if so what it was. We manage this only with specialised data structures (in accounts) and limiting the rate at which a preimage may be supplied, removed and supplied again to avoid state blowup. This can all be discovered by a thorough read of the GP.</div>
<div class='msg'><time>2024‑09‑10 20:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * JAM (and Polkadot before it) is secure only because of Elves. Elves requires that all validators are able to audit all Work Reports *regardless of whether they’re synced to the same fork or not*. All host functions available to Refine must return exactly the same result for any node on any fork beyond the lookup-anchor. Since we cannot assume any particular state is known (even the lookup anchor block’s state, which could be very old and is likely pruned) then our host functions must be pretty much stateless. Historical lookup works only because we know, at any block up to 24 hours later, whether a preimage was known at the time and if so what it was. We manage this only with specialised data structures (in accounts) and limiting the rate at which a preimage may be supplied, removed and supplied again to avoid state blowup. This can all be discovered by a thorough read of the GP. The design would not cleanly apply to more arbitrary and general state changes such as service storage. </div>
<div class='msg'><time>2024‑09‑11 04:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 0.3.7 is released: https://github.com/gavofyork/graypaper/releases/tag/v0.3.7

In addition to the usual corrections/clarifications, this contains a couple of modest but important changes:
- Erasure-coding is now validator-major not chunk-major: this optimizes the happy case (where you have the first 342 validator&#x27;s shares) and doesn&#x27;t really affect the general case.
- There&#x27;s a new item in chi (privileged services) for managing always-accumulate services and how much gas they get. The three privileged services *no longer always-accumulate implicitly*.</div>
<div class='msg'><time>2024‑09‑11 07:34</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: I&#x27;ve found a possible discrepancy in single-step state transition of PVM:

In 214 psi_1 receives (c,k,j) + pvm_state, while in 218 psi_1 receives (c,j) + pvm_state</div>
<div class='msg'><time>2024‑09‑11 07:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dakkk:matrix.org&gt; I&#x27;ve found a possible discrepancy in single-step state transition of PVM:
&gt; 
&gt; In 214 psi_1 receives (c,k,j) + pvm_state, while in 218 psi_1 receives (c,j) + pvm_state

https://github.com/gavofyork/graypaper/pull/77 - will be fixed in next release.</div>
<div class='msg'><time>2024‑09‑11 15:14</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: Question regarding BitSequence codec:
Am I getting this right, that in case of a variable-length bit sequence encoding, one should [prefix it with length](https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMzEiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGYgaDYgeTFlNjMgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4ZiBoNiB5MWU2MyBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==) of the bit sequence itself, not with length of it&#x27;s packed representation?</div>
<div class='msg reply'><time>2024‑09‑11 20:20</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: it has to be the bit length otherwise how do you figure out that? but I don’t think variable length bit sequence is used atm so no need to implement it</div>
<div class='msg'><time>2024‑09‑11 15:17</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: Also IMHO it would be good to only have one canonical representation of some encoding, so GP should strictly define that:
1. The remaining bits (i.e. the remaining `bitLength % 8`)  should be set to 0 (and decoding should fail in other case)
2. The boolean discriminator can be only `0` or `1`, so any other number should fail the decoding.</div>
<div class='msg'><time>2024‑09‑11 15:20</time>&ensp;<span class='u' style='color:#7664c9'>emielvanderhoek</span>: </div>
<div class='msg'><time>2024‑09‑11 15:22</time>&ensp;<span class='u' style='color:#7664c9'>emielvanderhoek</span>: </div>
<div class='msg'><time>2024‑09‑11 15:24</time>&ensp;<span class='u' style='color:#7664c9'>emielvanderhoek</span>: </div>
<div class='msg'><time>2024‑09‑11 15:25</time>&ensp;<span class='u' style='color:#7664c9'>emielvanderhoek</span>: * Bitsequence with length 3 for Octet: 253 and octet: 1 both decode as [True,False,False]. With encoding the bits outside of the sequence matter to get the right octet back. </div>
<div class='msg'><time>2024‑09‑11 15:58</time>&ensp;<span class='u' style='color:#7664c9'>emielvanderhoek</span>: </div>
<div class='msg'><time>2024‑09‑11 16:09</time>&ensp;<span class='u' style='color:#7664c9'>emielvanderhoek</span>: </div>
<div class='msg'><time>2024‑09‑12 00:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@tomusdrw:matrix.org&gt; Also IMHO it would be good to only have one canonical representation of some encoding, so GP should strictly define that:
&gt; 1. The remaining bits (i.e. the remaining `bitLength % 8`)  should be set to 0 (and decoding should fail in other case)
&gt; 2. The boolean discriminator can be only `0` or `1`, so any other number should fail the decoding.

What do you mean by “Boolean discriminator”?</div>
<div class='msg'><time>2024‑09‑12 03:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 1. This is already the implication. (We define only the encoding function, which implies that the remaining bits are set to zero. Decoding is just the inverse of the encoding function and so would naturally be invalid in if these bits happened to be set, since there would be no valid operand to the encoder function which could produce that output.)
2. What do you mean by “Boolean discriminator”?</div>
<div class='msg'><time>2024‑09‑12 06:27</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: &gt; &lt;@gav:polkadot.io&gt; 1. This is already the implication. (We define only the encoding function, which implies that the remaining bits are set to zero. Decoding is just the inverse of the encoding function and so would naturally be invalid in if these bits happened to be set, since there would be no valid operand to the encoder function which could produce that output.)
&gt; 2. What do you mean by “Boolean discriminator”?

1. Okay fair point, I didn&#x27;t think about implication like that. What I had in mind is to change the `sum</div>
<div class='msg'><time>2024‑09‑12 06:28</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>:  * 1. Okay fair point, I didn&#x27;t think about implication like that. What I had in mind about being more explicit with bits is to change the sum limits to be full `0..8` and then define `b_i * 2^i if i &lt; |b|, 0 otherwise`</div>
<div class='msg'><time>2024‑09‑12 06:30</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: &gt; &lt;@gav:polkadot.io&gt; 1. This is already the implication. (We define only the encoding function, which implies that the remaining bits are set to zero. Decoding is just the inverse of the encoding function and so would naturally be invalid in if these bits happened to be set, since there would be no valid operand to the encoder function which could produce that output.)
&gt; 2. What do you mean by “Boolean discriminator”?

2. Sorry, should have been more precise: I&#x27;ve meant the [discriminator for set in union with empty set](https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMzEiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeDEyIGg2IHkxZTU2IGZmNyBmczAgZmMwIHNjMCBsczAgd3MwXCI+IiwiPGRpdiBjbGFzcz1cInQgbTAgeGYgaGMgeTFlNTcgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iXV0=). But given your other explanation about just providing the canonical encoding it&#x27;s pretty clear that any number other than `0` and `1` should be rejected.</div>
<div class='msg'><time>2024‑09‑12 06:41</time>&ensp;<span class='u' style='color:#7664c9'>emielvanderhoek</span>: &gt; &lt;@gav:polkadot.io&gt; 1. This is already the implication. (We define only the encoding function, which implies that the remaining bits are set to zero. Decoding is just the inverse of the encoding function and so would naturally be invalid in if these bits happened to be set, since there would be no valid operand to the encoder function which could produce that output.)
&gt; 2. What do you mean by “Boolean discriminator”?

When looking at PVM testvectors, I assume k is a fixed length bitsequence (length defined by |c|=|k|). I believe the the remaining bits are all filled with 1s rather than 0s. Example is the first ADD instruction. IMO if we are strict about decoding these vectors should be fixed. </div>
<div class='msg'><time>2024‑09‑12 07:04</time>&ensp;<span class='u' style='color:#7664c9'>emielvanderhoek</span>: &gt; &lt;@gav:polkadot.io&gt; 1. This is already the implication. (We define only the encoding function, which implies that the remaining bits are set to zero. Decoding is just the inverse of the encoding function and so would naturally be invalid in if these bits happened to be set, since there would be no valid operand to the encoder function which could produce that output.)
&gt; 2. What do you mean by “Boolean discriminator”?

 * When looking at PVM testvectors, I assume k is a fixed length bitsequence (length defined by |c|=|k|). I believe the the remaining bits are all filled with 1s rather than 0s. 

Example is the first ADD instruction. https://github.com/w3f/jamtestvectors/blob/a2b18702aac7d15b9f51cd1ffcf0be95f987b2f7/pvm/programs/inst_add.json#L29

Value [T,F,F] is currently 249 or 0xF9 (1-filled) and should be 1 or 0x01 (0-filled). 

IMO if we are strict about decoding these vectors should be fixed. </div>
<div class='msg'><time>2024‑09‑12 07:06</time>&ensp;<span class='u' style='color:#7664c9'>emielvanderhoek</span>: This also implies that the only PVM testvectors that are currently valid are the ones where |c| is accidentally a multiple of 8. </div>
<div class='msg'><time>2024‑09‑12 07:08</time>&ensp;<span class='u' style='color:#7664c9'>emielvanderhoek</span>: We can work around this for now by not having a ‘strict’ decoding of a bitsequence. I.e. simply ignoring the bits outside of the bitmask. </div>
<div class='msg'><time>2024‑09‑12 07:11</time>&ensp;<span class='u' style='color:#7664c9'>emielvanderhoek</span>: Correct me if I am wrong. 🙏🏻 </div>
<div class='msg'><time>2024‑09‑12 07:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@emielvanderhoek:matrix.org&gt; When looking at PVM testvectors, I assume k is a fixed length bitsequence (length defined by |c|=|k|). I believe the the remaining bits are all filled with 1s rather than 0s. 
&gt; 
&gt; Example is the first ADD instruction. https://github.com/w3f/jamtestvectors/blob/a2b18702aac7d15b9f51cd1ffcf0be95f987b2f7/pvm/programs/inst_add.json#L29
&gt; 
&gt; Value [T,F,F] is currently 249 or 0xF9 (1-filled) and should be 1 or 0x01 (0-filled). 
&gt; 
&gt; IMO if we are strict about decoding these vectors should be fixed. 

We are strict and if this is the case then they should indeed be fixed (@jan care to comment?)</div>
<div class='msg'><time>2024‑09‑12 07:26</time>&ensp;<span class='u' style='color:#7664c9'>emielvanderhoek</span>: https://github.com/w3f/jamtestvectors/issues/13</div>
<div class='msg'><time>2024‑09‑12 07:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@tomusdrw:matrix.org&gt; 1. Okay fair point, I didn&#x27;t think about implication like that. What I had in mind about being more explicit with bits is to change the sum limits to be full `0..8` and then define `b_i * 2^i if i &lt; |b|, 0 otherwise`

I think this would only confuse matters. It’s pretty clear currently using a summation to define each octet and totally ignoring the fact that the final octet sequence can be expressed in bits. </div>
<div class='msg'><time>2024‑09‑12 07:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@tomusdrw:matrix.org&gt; 1. Okay fair point, I didn&#x27;t think about implication like that. What I had in mind is to change the `sum

* I think this would only confuse matters. It’s pretty clear currently using a summation to define each octet and totally ignoring the fact that the octets in the resultant sequence could hypothetically be expressed in bits some some of which may have no correspondence with bits in the bit sequence. </div>
<div class='msg'><time>2024‑09‑12 07:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It is bits in, octets (values between 0 and 255 inclusive) out. There’s absolutely no need to bring “unused bits” into it. </div>
<div class='msg reply'><time>2024‑09‑12 09:14</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: Omg, sorry I&#x27;m so dumb. Only now I&#x27;ve realized it&#x27;s an actual sum, so obviously the other bits don&#x27;t need any special treatment</div>
<div class='msg'><time>2024‑09‑12 07:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * It is bits in, octets (values between 0 and 255 inclusive) out. There’s absolutely no need to bring “unused bits” into it. Concerns specific to particular low-level implementations are not generally going to be made explicit in the GP.</div>
<div class='msg'><time>2024‑09‑12 07:47</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: </div>
<div class='msg'><time>2024‑09‑12 07:48</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * Im appending all c instruction data with 25 zeroes https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMjEiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGYgaGIgeTExMGQgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4ZiBoNiB5MTEwZSBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==, so in the case of first ADD instruction data I have 3 + 25 octets. Bitmask is 249 (11111001), |b| = 3 and I consider the remaining 5 ones as suffix. So then I have to suffix 20 ones more to the bitmask in order to have |c| + suffix = |b| + suffix</div>
<div class='msg'><time>2024‑09‑12 07:49</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * Im append all c instruction data with 25 zeros https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMjEiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGYgaGIgeTExMGQgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4ZiBoNiB5MTEwZSBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==, so in the case of the first ADD instruction data I have 3 + 25 octets. The Bitmask is 249 (11111001), |b| = 3 and I consider the remaining 5 ones as suffix. So then I have to suffix 20 more ones to the bitmask in order to have |c| + suffix = |b| + suffix</div>
<div class='msg'><time>2024‑09‑12 07:50</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * I append all c instruction data with 25 zeros https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMjEiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGYgaGIgeTExMGQgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4ZiBoNiB5MTEwZSBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==, so in the case of the first ADD instruction data I have 3 + 25 octets. The Bitmask is 249 (11111001), |b| = 3 and I consider the remaining 5 ones as suffix. So then I have to suffix 20 more ones to the bitmask in order to have |c| + suffix = |b| + suffix</div>
<div class='msg'><time>2024‑09‑12 07:53</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * I append all c instruction data with 25 zeros https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMjEiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGYgaGIgeTExMGQgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4ZiBoNiB5MTEwZSBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==, so in the case of the first ADD instruction data I have 3 + 25 octets. The Bitmask is 249 (11111001), |b| = 3 and I consider the remaining 5 ones as suffix. So then I have to suffix 20 more ones to the bitmask in order to have instruction data length = bitmask length</div>
<div class='msg'><time>2024‑09‑12 07:54</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * I append all c instruction data with 25 zeros https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMjEiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGYgaGIgeTExMGQgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4ZiBoNiB5MTEwZSBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==, so in the case of the first ADD instruction data I have 3 + 25 octets. The Bitmask is 249 (11111001), |b| = 3 and I consider the remaining 5 ones as suffix. So then I have to suffix 20 more ones to the bitmask in order to have |instruction_data| = |bitmask|</div>
<div class='msg'><time>2024‑09‑12 07:56</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * I append all c instruction data with 25 zeros (24 is de max value returned by skip function, I add one more for security) https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMjEiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGYgaGIgeTExMGQgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4ZiBoNiB5MTEwZSBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==, so in the case of the first ADD instruction data I have 3 + 25 octets. The Bitmask is 249 (11111001), |b| = 3 and I consider the remaining 5 ones as suffix. So then I have to suffix 20 more ones to the bitmask in order to have |instruction\_data| = |bitmask|</div>
<div class='msg'><time>2024‑09‑12 08:02</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * I append instruction data with 25 zeros (24 is de max value returned by skip function, I add one more for security) https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMjEiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGYgaGIgeTExMGQgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4ZiBoNiB5MTEwZSBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==, so in the case of the first ADD instruction data I have 3 + 25 octets. The Bitmask is 249 (11111001), |b| = 3 and I consider the remaining 5 ones as suffix. So then I have to suffix 20 more ones to the bitmask in order to have |instruction\_data| = |bitmask|</div>
<div class='msg'><time>2024‑09‑12 08:11</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: &gt; &lt;@emielvanderhoek:matrix.org&gt; This also implies that the only PVM testvectors that are currently valid are the ones where |c| is accidentally a multiple of 8.

I append instruction data with 25 zeros (24 is de max value returned by skip function, I add one more for security) https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMjEiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGYgaGIgeTExMGQgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4ZiBoNiB5MTEwZSBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==, so in the case of the first ADD instruction data I have 3 + 25 octets. The Bitmask is 249 (11111001), |b| = 3 and I consider the remaining 5 ones as suffix. So then I have to suffix 20 more ones to the bitmask in order to have |instruction_data| = |bitmask|</div>
<div class='msg'><time>2024‑09‑12 08:24</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: The remaining bits in the PVM code blob&#x27;s bitmask (in case the size of the instructions&#x27; slice is not divisible by 8) don&#x27;t really matter and will produce the same result (as all out of bounds instructions are assumed to be traps, and regardless of what skip they have they will decode all the same), *except* the very first &quot;extra&quot; out of bounds bit which nominally should be `1`, because that bit determines the skip of the last instruction. So just assuming they&#x27;re all zeros would screw up decoding of the last instruction in case the instructions&#x27; slice is divisible by 8.

But you&#x27;re right that there&#x27;s discrepancy here between the GP and the test vectors. It essentially boils down to this: what should we do if the number of instructions is not divisible by 8? Naively reading the GP the `|c| = |k|` would suggest to me that the number of bits in the bit mask should be always equal to the number of instruction bytes, but that indeed is not the case for our current test vectors.

So how do we fix this discrepancy? First, even if the number of instruction bytes is divisible by 8 we need to assume that out of bounds bits are `1` (only the very first one needs to be, but it&#x27;s simpler to assume all of them are), otherwise the decoding of the last instruction will be broken (alternatively skip can be defined to be &quot;the number of `0`s until the next `1`s, or until the end of the bitmask&quot;, then conceptually the out of bounds bits can be `0`).

Second, decide what to do when the number of instruction bytes is not divisible by 8:
a) change the `|c| = |k|` to say that the `|c|` should be rounded up to the nearest 8 (so, essentially, &quot;round_up_to_nearest(8, instruction_bytes) == bits_in_bitmask&quot;); essentially, allow the number of instructions and the number of bits in the bitmask not match, but enforce that the bitmask can have at most an &quot;extra&quot; 7 bits of padding (of which, as I&#x27;ve previously explained, only the first bit matters)
b) delete the `|c| = |k|` (since AFAIK we always know the length of the whole **p** anyway, so the only purpose this equation serves is to add an additional constraint); essentially, allow the number of instructions and the number of bits in the bitmask not match, and not enforce anything about the bitmask&#x27;s length
c) force the instruction bytes to be always divisible by 8, in which case we could change the encoding of the **p** code blob to something like `p = E(|j|) ⌢ E_1(z) ⌢ E_z (j) ⌢ E(c) ⌢ E(k)` (basically remove `E(|c|)`, since, again, the lengths here can be implicitly calculated from the length of **p**)

So I think (b) is probably not a great idea. (a) is what I currently have implemented in PolkaVM, and I don&#x27;t dislike the (c) option (It can waste up to 6 bytes, but it doesn&#x27;t need any extra validation of the sizes. so one less place for the implementations to diverge I guess). gav </div>
<div class='msg'><time>2024‑09‑12 08:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Firstly I don’t understand the problem of instructions not being divisible by 8. Bit strings need not be divisible by 8 either. </div>
<div class='msg'><time>2024‑09‑12 08:36</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: &gt; &lt;@gav:polkadot.io&gt; Firstly I don’t understand the problem of instructions not being divisible by 8. Bit strings need not be divisible by 8 either.

We have a bit in the bit mask for every instruction, right? But we can&#x27;t just encode singular bits; we need to *physically* encode them as bytes. So if we have, say, an instructions blob which only takes 2 bytes of space, then sure, theoretically we only need 2 bits in the bit mask, but practically we must encode full 8 bits because 8 bits is the lowest granularity we can store. So this is what I mean by &quot;instructions not being divisible by 8&quot;.</div>
<div class='msg'><time>2024‑09‑12 09:03</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: The implicit &quot;remaining bits of the bitmask encoded as bytes must be zero&quot; of GP&#x27;s bit string encoding has two issues here as far as I can see:
1) this being an implicit requirement can be confusing for the implementers (as we&#x27;ve seen from the questions here; it might not be entirely obvious to everyone that those should be zeros, nor whether this should be validated), so it could be worthwhile to add a clarifying footnote or something explicitly saying this so that there&#x27;s no room for confusion,
and 2) for the PVM code blob specifically this breaks the decoding of the very last instruction&#x27;s skip value, *unless* we say that the the skip calculation goes only as far as the end of the bitmask (so effectively implicitly the bitmask would have a `1` in there because it would behave as if there actually was a `1` encoded there, even though we&#x27;d physically require encoding `0`s there!)</div>
<div class='msg'><time>2024‑09‑12 09:04</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>:  * The implicit &quot;remaining bits of the bitmask encoded as bytes must be zero&quot; of GP&#x27;s bit string encoding has two issues here as far as I can see:

1. this being an implicit requirement can be confusing for the implementers (as we&#x27;ve seen from the questions here; it might not be entirely obvious to everyone that those should be zeros, nor whether this should be validated), so it could be worthwhile to add a clarifying footnote or something explicitly saying this so that there&#x27;s no room for confusion,
2. for the PVM code blob specifically this breaks the decoding of the very last instruction&#x27;s skip value, _unless_ we say that the the skip calculation goes only as far as the end of the bitmask (so effectively implicitly the bitmask would have a `1` in there because it would behave as if there actually was a `1` encoded there, even though we&#x27;d physically require encoding `0`s there!)</div>
<div class='msg'><time>2024‑09‑12 09:05</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Hmm, but okay, *another* way of dealing with this could maybe be inverting the mask so that operands get a `1` and instruction opcodes get a `0` in the bitmask - *then* the zero padding would work.</div>
<div class='msg'><time>2024‑09‑12 09:19</time>&ensp;<span class='u' style='color:#7664c9'>emielvanderhoek</span>: Rereading GP-0.3.6-eq:276 (encoding of bitsequence) to me seems to explicitly force leading zero’s when encoding to an octet. </div>
<div class='msg'><time>2024‑09‑12 09:21</time>&ensp;<span class='u' style='color:#7664c9'>emielvanderhoek</span>: * Rereading GP-0.3.6-eq:276 (encoding of bitsequence) to me seems to explicitly force leading zero’s when encoding to an octet.

Example: Value [T,F,F] leads to value 1 or 0x01 (0-filled). And no other value. </div>
<div class='msg'><time>2024‑09‑12 09:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; We have a bit in the bit mask for every instruction, right? But we can&#x27;t just encode singular bits; we need to physically encode them as bytes

The encoding is irrelevant.</div>
<div class='msg'><time>2024‑09‑12 09:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * &gt; We have a bit in the bit mask for every instruction, right? But we can&#x27;t just encode singular bits; we need to physically encode them as bytes

The encoding is irrelevant from the perspective of the PVM spec.</div>
<div class='msg'><time>2024‑09‑12 09:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: They&#x27;re totally separate concerns.</div>
<div class='msg'><time>2024‑09‑12 09:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I say again: the length of any sequence (including a sequence of bits) do not need to be divisible by 8. From the perspective of the spec there is *absolutely nothing special* about bit-sequences compared to any other kind of sequence.</div>
<div class='msg'><time>2024‑09‑12 09:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There is a perfectly well-defined serialization codec. It does not prejudice the business logic at all.</div>
<div class='msg'><time>2024‑09‑12 09:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * There is a perfectly well-defined serialization codec. It is independent of the business logic and does not prejudice it at all.</div>
<div class='msg'><time>2024‑09‑12 09:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Reading what you&#x27;re saying, the only thing I can think of which might need a tweak is the skip function.</div>
<div class='msg'><time>2024‑09‑12 09:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: image.png</div>
<div class='msg'><time>2024‑09‑12 09:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Since the final instruction&#x27;s opcode bitmask could not be followed by a 1 as that would imply the opcode bitmask sequence as being longer than the instruction data sequence.</div>
<div class='msg'><time>2024‑09‑12 09:40</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Sure, but the bits *are* physically there, so everyone needs to agree to handle them in the same way. (:

So, again, if the implicit assumption is that those extra physical bits in a bitstream must be zero then that doesn&#x27;t work for PVM as currently defined, and we need to fix it somehow.

One simple way we could fix it is to invert the bitmask (so change the `1` to `0` in the skip equation) at a tiny cost to performance (~0.006% worse compilation speed as I just implemented it and measured); if that&#x27;s fine to you then we can go with that.</div>
<div class='msg'><time>2024‑09‑12 09:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: it should probably read k + 1 + j &gt;= |k| OR ...</div>
<div class='msg'><time>2024‑09‑12 09:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; Sure, but the bits are physically there, so everyone needs to agree to handle them in the same way. (:

Not necessarily.</div>
<div class='msg'><time>2024‑09‑12 09:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: You&#x27;re thinking far too implementation specific.</div>
<div class='msg'><time>2024‑09‑12 09:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Please check the room title.</div>
<div class='msg'><time>2024‑09‑12 09:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Maybe someone implements the bit sequence as `Vec&lt;bool&gt;`. Maybe they&#x27;re in C++ and it&#x27;s `std::vector&lt;bool&gt;`. Maybe they&#x27;re in Scheme or Haskell and it&#x27;s linked list of bools.</div>
<div class='msg'><time>2024‑09‑12 09:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The serialization format and the internal business logic are NOT the same.</div>
<div class='msg'><time>2024‑09‑12 09:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: They&#x27;re not even close to being the same thing.</div>
<div class='msg'><time>2024‑09‑12 09:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: AFAICT nobody has brought up any value concern related to bit-sequences. The spec is 100% clear.</div>
<div class='msg'><time>2024‑09‑12 09:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Bit sequences are arbitrary in length and any attempt by the spec to reference a value beyond its length is undefined regardless of what might happen to be in any particular place in a machine&#x27;s physical RAM.</div>
<div class='msg'><time>2024‑09‑12 09:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: You seem to be conflating the fact that encoding a bit sequence of type B_8 and value [1, 1, 1, 1, 1, 1, 1, 0] happens to give the same octet sequence as a bit sequence of type B_7 and value [1, 1, 1, 1, 1, 1, 1].</div>
<div class='msg'><time>2024‑09‑12 09:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * You seem to be conflating some element of (perfectly well defined) business logic with the fact that the serialization of a bit sequence of type B\_8 and value \[1, 1, 1, 1, 1, 1, 1, 0\] happens to give the same octet sequence as a bit sequence of type B\_7 and value \[1, 1, 1, 1, 1, 1, 1\].</div>
<div class='msg'><time>2024‑09‑12 09:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: As I say, at present the skip function appears to be in part undefined. This is the only alteration I see the need for. And it&#x27;s just a broken function - it has nothing to do with the serialization format of sequences.</div>
<div class='msg'><time>2024‑09‑12 09:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * AFAICT nobody has brought up any valid concern related to bit-sequences. The spec is 100% clear.</div>
<div class='msg'><time>2024‑09‑12 09:59</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Bit sequences are arbitrary in length and anywhere spec subscripts by an index &gt;= length is undefined regardless of what might happen to be in any particular place in a machine&#x27;s physical RAM.</div>
<div class='msg'><time>2024‑09‑12 09:59</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * As I say, at present the skip function appears to be in part undefined. This is the only alteration I see the need for. And it&#x27;s just a broken function - it has nothing to do with the serialization format of sequences, or subscripting into bit sequences.</div>
<div class='msg'><time>2024‑09‑12 10:03</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Okay, sure, but the bits *are* physically there, so it needs to be defined somehow (implicitly or explicitly) how they are handled. Are they validated (enforced to be zero) or are they ignored? The protocol *will* physically transmit those bytes, so it needs to define how they&#x27;re handled (even if, again, this definition is only implicit and not explicitly written out). So I disagree that this is in any way an implementation-only concern. It&#x27;s just a matter of whether the spec defines what happens explicitly or implicitly.

Like, for example, let&#x27;s take this pseudo code as an example:

```
a = spawn_pvm(instructions = [1,2,3,4,5,6,7], bitmask = [0b11111110])
b = spawn_pvm(instructions = [1,2,3,4,5,6,7], bitmask = [0b11111111])
```

We need the behaviour of this snippet to be the same for every implementation, hence the spec must define what happens here. Sure, the spec doesn&#x27;t explicitly have to concern itself whether the last bit is there, but it needs to at least implicitly define (as a consequence of what it *does* explicitly define) exactly what happens, whether that be just ignoring the extra bits, or checking whether the extra bits are zero and if not then rejecting the program. If you want to say &quot;this concern is too low level for the the spec to explicitly define, and we will only define it implicitly&quot; then okay, fair enough.

Anyway, so, can we change the bitmask for the skip to be the other way around - `0`s for instructions and `1`s for the argumets? That should resolve the issue with only a minimal hit to the performance of any potential implementations and not require any extra modifications.</div>
<div class='msg'><time>2024‑09‑12 10:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; but the bits are physically there

Not in the spec they&#x27;re not./</div>
<div class='msg'><time>2024‑09‑12 10:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * &gt; but the bits are physically there

Not in the spec they&#x27;re not.</div>
<div class='msg'><time>2024‑09‑12 10:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: And the spec is what is correct.</div>
<div class='msg'><time>2024‑09‑12 10:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: So NO. They&#x27;re not.</div>
<div class='msg'><time>2024‑09‑12 10:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It sounds as though your implementation of the spec is probably based on non-conformant assumptions about memory layouts.</div>
<div class='msg'><time>2024‑09‑12 10:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: And that you&#x27;re conflating these non-conformant assumptions with the spec&#x27;s serialization format for bit sequences.</div>
<div class='msg'><time>2024‑09‑12 10:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Now I don&#x27;t think there&#x27;s any issue with altering the skip function in the way I state above.</div>
<div class='msg'><time>2024‑09‑12 10:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Implementations are free to include a bounds-check, but they can also allocate an extra byte or two and fill them with `true`s.</div>
<div class='msg'><time>2024‑09‑12 10:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Implementations are free to include a bounds-check, but they can also allocate an extra byte or two and fill them with `1`s.</div>
<div class='msg'><time>2024‑09‑12 10:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Implementations are free to include a bounds-check, but they can also just place extra bits (of value `1`) on the end of their bit sequence `k`.</div>
<div class='msg'><time>2024‑09‑12 10:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Inverting the meaning of bits in k is not going to help unless you presume (incorrectly) that there are accessible trailing zero bits in whatever your internal representation of sequence k is.</div>
<div class='msg'><time>2024‑09‑12 10:14</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; It&#x27;s just a matter of whether the spec defines what happens explicitly or implicitly.

I&#x27;ve no idea what you&#x27;re talking about.</div>
<div class='msg'><time>2024‑09‑12 10:14</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There&#x27;s nothing implicit.</div>
<div class='msg'><time>2024‑09‑12 10:15</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Beyond any as-yet unknown errors, the spec defines correct behaviour perfectly.</div>
<div class='msg'><time>2024‑09‑12 10:15</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There is nothing implicit about the serialization format nor about k, nor about what happens when you subscript into k.</div>
<div class='msg'><time>2024‑09‑12 10:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Implementations are free to include a bounds-check, but they can also just place extra bits (of value `1`) on the end of their (bit sequence) `k`, and thus allow writing a conformant skip function which needs no explicit bounds check as long as its argument is properly constrained (and we know it should be by virtue of how it&#x27;s used in the spec).</div>
<div class='msg'><time>2024‑09‑12 10:19</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Okay, can I ask an offtopic question?

Leaving the spec-land, can you clarify what exactly are implementations supposed to do with the extra bits in the real world to be conformant with the spec? Are they supposed to ignore it? Or validate that they are zeros? Since the spec doesn&#x27;t define what to do with them and doesn&#x27;t concern itself with them am I correct in assuming that they should be ignored?</div>
<div class='msg'><time>2024‑09‑12 10:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Inverting the meaning of bits in k is not going to help unless you presume (generally incorrectly, but perhaps by design in your implementation) that there are accessible trailing zero bits in whatever your internal representation of sequence k is.</div>
<div class='msg'><time>2024‑09‑12 10:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There are no extra bits.</div>
<div class='msg'><time>2024‑09‑12 10:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I&#x27;ve been trying to point this out for nearly 10 hours now.</div>
<div class='msg'><time>2024‑09‑12 10:22</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Okay, so they should be ignored by the implementations. Got it.</div>
<div class='msg'><time>2024‑09‑12 10:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There is a definition of how to serialize a sequence of N_2 values (&quot;bits&quot;, booleans, whatever you like to call it).</div>
<div class='msg'><time>2024‑09‑12 10:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: This implies how to deserialize.</div>
<div class='msg'><time>2024‑09‑12 10:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * This implies a deserialization definition which requires canonical serialization.</div>
<div class='msg'><time>2024‑09‑12 10:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * This implies a deserialization function definition which requires canonical serialization.</div>
<div class='msg'><time>2024‑09‑12 10:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: As for internal (in-RAM) representations: it&#x27;s purely an implementation concern.</div>
<div class='msg'><time>2024‑09‑12 10:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The GP specifies correctness through the serialization of blocks only. It does not EVER specify how a machine should represent any particular datum in a machine&#x27;s memory. For all the GP knows, it could be a pen-and-paper block execution.</div>
<div class='msg'><time>2024‑09‑12 10:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * The GP specifies correctness through the serialization of blocks only. It does not EVER specify how a machine should represent any particular datum in physical memory. For all the GP knows, it could be a pen-and-paper block execution.</div>
<div class='msg'><time>2024‑09‑12 10:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: As such there is simply no concern of &quot;extra bits&quot; with regards to correctness.</div>
<div class='msg'><time>2024‑09‑12 10:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: If I might rephrase your question (possibly incorrectly) to &quot;I plan to implement a bit sequence in Rust as a `Vec&lt;u8&gt;` and thus will naturally have access to a multiple of 8 bits at a time. If the bit sequence is a non-multiple of 8 in length and I attempt to dereference an bit whose index falls into those bits beyond the rightful length but still within the bytes which I am able to access, how should I proceed?&quot;</div>
<div class='msg'><time>2024‑09‑12 10:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * If I might rephrase your question (possibly incorrectly) to &quot;I plan to implement a bit sequence in Rust as a `Vec&lt;u8&gt;` and thus will naturally have access to a multiple of 8 bits at a time. If the bit sequence is a non-multiple of 8 in length and I attempt to dereference a bit whose index falls into those bits beyond the rightful length but still within the final byte which I am able to access, how should I proceed?&quot;</div>
<div class='msg'><time>2024‑09‑12 10:30</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: More or less, yes.</div>
<div class='msg'><time>2024‑09‑12 10:30</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: (Although the question would be the same regardless of the programming language, as long as we&#x27;re implementing JAM on a computer.)</div>
<div class='msg'><time>2024‑09‑12 10:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The answer would be: &quot;Either your implementation is incorrect (because subscripting at that index is undefined in the GP) or the GP is incorrect (because it includes an undefined term).&quot;</div>
<div class='msg'><time>2024‑09‑12 10:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * The answer would be: &quot;Either your implementation is incorrect (because the GP does not subscript at that index) or the GP is incorrect (because it includes an undefined term).&quot;</div>
<div class='msg'><time>2024‑09‑12 10:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * The answer would be: &quot;Either your implementation is incorrect (because the GP does not subscript at that index) or the GP is incorrect (because it does subscript at that index and thus includes an undefined term).&quot;</div>
<div class='msg'><time>2024‑09‑12 10:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@jan:parity.io&gt; (Although the question would be the same regardless of the programming language, as long as we&#x27;re implementing JAM on a computer.)

Again not true.</div>
<div class='msg'><time>2024‑09‑12 10:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@jan:parity.io&gt; (Although the question would be the same regardless of the programming language, as long as we&#x27;re implementing JAM on a computer.)

 * Again not true. This question can only be framed with the presumption that there is accessible capacity beyond the rightful length.</div>
<div class='msg'><time>2024‑09‑12 10:33</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Okay, so the implementation should not access those bytes, and if it does this should not change any observable behavior, so any practical implementations of JAM on a computer will have to ignore those bits.</div>
<div class='msg'><time>2024‑09‑12 10:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Again not true. This question can only be framed with the presumption that there is accessible capacity beyond the rightful length, which seems pretty specific to the presumptions inherent in your implementation.</div>
<div class='msg'><time>2024‑09‑12 10:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@jan:parity.io&gt; Okay, so the implementation should not access those bytes, and if it does this should not change any observable behavior, so any practical implementations of JAM on a computer will have to ignore those bits.

It&#x27;s not as simple as that.</div>
<div class='msg'><time>2024‑09‑12 10:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Maybe it does access those bytes.</div>
<div class='msg'><time>2024‑09‑12 10:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The point is that the GP defines correct behaviour.</div>
<div class='msg'><time>2024‑09‑12 10:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Implementations are totally free to access whatever parts of RAM they want in whatever ways they want to.</div>
<div class='msg'><time>2024‑09‑12 10:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: As long as their behaviour is in line with the GP it really doesn&#x27;t matter.</div>
<div class='msg'><time>2024‑09‑12 10:35</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Yes, that&#x27;s what I was trying to say. (:</div>
<div class='msg'><time>2024‑09‑12 10:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: From the GP&#x27;s perspective, there are no &quot;extra bits&quot;, or more generally stated, there is no capacity beyond the length. For the sequence s = [0, 1], s[2] is undefined. If the spec ever tries to evaluate it, there is a mistake in the spec.</div>
<div class='msg'><time>2024‑09‑12 10:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * From the GP&#x27;s perspective, there are no &quot;extra bits&quot;, or more generally stated, there is no capacity beyond the length. For the sequence s = \[0, 1\], s\[2\] is undefined. If the spec ever tries to evaluate it, there is a mistake in the spec. Maybe a corresponding operation in some implementions would define some result.</div>
<div class='msg'><time>2024‑09‑12 10:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * From the GP&#x27;s perspective, there are no &quot;extra bits&quot;, or more generally stated, there is no capacity beyond the length. For the sequence s = \[0, 1\], s\[2\] is undefined. If the spec ever tries to evaluate it, there is a mistake in the spec. Maybe a corresponding operation in some implementions would define some result. That&#x27;s a potential avenue for an implementation-specific optimisation perhaps, but it&#x27;s irrelevant from the perspective of asking about correct behaviour.</div>
<div class='msg'><time>2024‑09‑12 10:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: To help illustrate this a bit further you&#x27;d probably want to implement an efficient bit-sequence as a `Vec&lt;usize&gt;`, implying that you&#x27;d have up to 31 &quot;extra bits&quot; on 32-bit architectures and 63 &quot;extra bits&quot; on 64-bit architectures. Clearly the spec cannot care about what architecture any given impl instance is one. Therefore it must surely be that the GP cannot possibly consider the existence of any such &quot;extra bits&quot;.</div>
<div class='msg'><time>2024‑09‑12 10:41</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Hm... but isn&#x27;t there at least one part of the spec that accesses those &quot;extra&quot; bits, namely, the `machine` hostcall defines the program as being p_z *bytes* long, so doesn&#x27;t this impliy that there *will* be extra bits in there?</div>
<div class='msg'><time>2024‑09‑12 10:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * To help illustrate this a bit further you&#x27;d probably want to implement an efficient bit-sequence as a `Vec&lt;usize&gt;`, implying that you&#x27;d have up to 31 &quot;extra bits&quot; on 32-bit architectures and 63 &quot;extra bits&quot; on 64-bit architectures. Clearly the spec cannot care about what architecture any given impl instance is on. Therefore it must surely be that the GP cannot possibly consider the existence of any such &quot;extra bits&quot;.</div>
<div class='msg'><time>2024‑09‑12 10:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Where?</div>
<div class='msg'><time>2024‑09‑12 10:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Where exactly?</div>
<div class='msg'><time>2024‑09‑12 10:43</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMmYiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeDQzIGhlIHkxY2ZjIGZmZiBmczAgZmMwIHNjMCBsczAgd3MwXCI+IiwiPGRpdiBjbGFzcz1cInQgbTAgeDE1MyBoNCB5MWNmZSBmZjIxIGZzMiBmYzAgc2MwIGxzMCB3czBcIj4iXV0=</div>
<div class='msg'><time>2024‑09‑12 10:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: ok you mean the program blob.</div>
<div class='msg'><time>2024‑09‑12 10:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes, this draws upon the exact same (deterministic) codec as before.</div>
<div class='msg'><time>2024‑09‑12 10:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There&#x27;s still no extra bits.</div>
<div class='msg'><time>2024‑09‑12 10:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Again, you&#x27;re confusing the wire format with business logic.</div>
<div class='msg'><time>2024‑09‑12 10:44</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Okay, fair enough. So in *this* case the bits should be zero to correctly decode, otherwise an error is returned?</div>
<div class='msg'><time>2024‑09‑12 10:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The point where wire-format (the p which is passed in `machine` and passed into Phi) changes into business logic is the E function.</div>
<div class='msg'><time>2024‑09‑12 10:45</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: In appendix A, why the gas delta is always 0 for every instruction?</div>
<div class='msg'><time>2024‑09‑12 10:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Before, one can argue that there may be &quot;extra bits&quot; (though I&#x27;d say it&#x27;s unhelpful and unnecessary to frame it in that way).,</div>
<div class='msg'><time>2024‑09‑12 10:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Before, one can argue that there may be &quot;extra bits&quot; (though I&#x27;d say it&#x27;s unhelpful and unnecessary to frame it in that way). Afterwards there are most certainly not.</div>
<div class='msg'><time>2024‑09‑12 10:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Before, one can argue that there may be &quot;extra bits&quot; (though I&#x27;d say it&#x27;s unhelpful and unnecessary to frame it in that way). Afterwards there are most certainly not. As I say, some implementations will likely use optimized language primitives like C++&#x27;s `vector&lt;bool&gt;` in order to represent this data and there will be no such accessible-beyond-rightful-length data</div>
<div class='msg'><time>2024‑09‑12 10:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Before, one can argue that there may be &quot;extra bits&quot; (though I&#x27;d say it&#x27;s unhelpful and unnecessary to frame it in that way). Afterwards there are most certainly not. As I say, some implementations will likely use optimized language primitives like C++&#x27;s `vector&lt;bool&gt;` in order to represent this data and there will be no such accessible-beyond-rightful-length data.</div>
<div class='msg'><time>2024‑09‑12 10:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dakkk:matrix.org&gt; In appendix A, why the gas delta is always 0 for every instruction?

We have not yet defined gas costs - it&#x27;ll be one of the last things we do.</div>
<div class='msg'><time>2024‑09‑12 10:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dakkk:matrix.org&gt; In appendix A, why the gas delta is always 0 for every instruction?

 * We have not yet defined sensible gas costs - it&#x27;ll be one of the last things we do.</div>
<div class='msg'><time>2024‑09‑12 10:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@jan:parity.io&gt; Okay, fair enough. So in *this* case the bits should be zero to correctly decode, otherwise an error is returned?

That&#x27;s implication of the math, yeah.</div>
<div class='msg'><time>2024‑09‑12 10:48</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: &gt; &lt;@gav:polkadot.io&gt; We have not yet defined sensible gas costs - it&#x27;ll be one of the last things we do.

okiedokie; so I assume in koute pvm test vectors the default value is 1</div>
<div class='msg'><time>2024‑09‑12 10:59</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: image.png</div>
<div class='msg'><time>2024‑09‑12 11:01</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: Should &#x27;v&#x27; here be replaced with &#x27;f&#x27;?</div>
<div class='msg'><time>2024‑09‑12 11:02</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: image.png</div>
<div class='msg'><time>2024‑09‑12 11:02</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: so as eq 129</div>
<div class='msg'><time>2024‑09‑12 13:26</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: &gt; &lt;@gav:polkadot.io&gt; That&#x27;s implication of the math, yeah.

Okay, thank you for clarifying everything. Now I&#x27;m clear on the intended behavior. Sorry for being so dense. (:

So the skip equation should be fixed, as it current does access out of bounds elements of `k` as far as I understand: `j∈N∶ k_{i+1+j} = 1` (since `j` is `∈N`, so it goes up to infinity, but even without this it would do an out-of-bounds access for the very last instruction due to the `+1`)

And we might consider deleting/changing this sentence which precedes the skip equation as it explicitly talks about the extra padding. I&#x27;m not saying it&#x27;s incorrect (logically it&#x27;s true), but in the context of our &quot;there are no extra bits&quot; conversation it may be confusing when (outside of the serialization codec section) you have a sentence which explicitly says that those bits do in fact exist:

&gt; We assert that the length of the bitmask is no smaller than the length of the instruction blob (and in fact is simply rounded to the nearest multiple of eight for ease of octet-encoding).

So, let me quickly summarize the main options that I can see:

a) change `skip` to not read out of bounds,
b) keep `skip` as-is, define out of bounds reads to be `1` (after all we already do something similar with the instructions blob),
c) keep `skip` as-is, define out of bounds reads to be `1`, use a dedicated serialization codec for this bit mask which requires that `|k| mod 8 = 0` and `ceil(|c| / 8) = |k| / 8` (so this would make the business logic explicitly use the &quot;extra&quot; bits, which now I know you don&#x27;t want)

I can make a PR to the GP. I&#x27;m guessing you&#x27;d like to go with (a), correct?

(For reference, I&#x27;ve initially implemented (c) in PolkaVM because that was marginally the fastest option which didn&#x27;t require adding any extra unnecessary padding.)</div>
<div class='msg'><time>2024‑09‑12 13:33</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: &gt; &lt;@dakkk:matrix.org&gt; okiedokie; so I assume in koute pvm test vectors the default value is 1

Correct. The test vectors currently assume that every instructions costs `1` gas, but this is just a strictly temporary measure so that people can implement their gas metering machinery without needing the final gas cost model to be defined (since gas is a core part of the JAM you must have at least *some* gas cost model, and assuming every instruction costs only `1` gas is the simplest one you can have). We will be defining a proper gas cost model in the future and updating the vectors.</div>
<div class='msg'><time>2024‑09‑12 15:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@jan:parity.io&gt; Okay, thank you for clarifying everything. Now I&#x27;m clear on the intended behavior. Sorry for being so dense. (:
&gt; 
&gt; So the skip equation should be fixed, as it current does access out of bounds elements of `k` as far as I understand: `j∈N∶ k_{i+1+j} = 1` (since `j` is `∈N`, so it goes up to infinity, but even without this it would do an out-of-bounds access for the very last instruction due to the `+1`)
&gt; 
&gt; And we might consider deleting/changing this sentence which precedes the skip equation as it explicitly talks about the extra padding. I&#x27;m not saying it&#x27;s incorrect (logically it&#x27;s true), but in the context of our &quot;there are no extra bits&quot; conversation it may be confusing when (outside of the serialization codec section) you have a sentence which explicitly says that those bits do in fact exist:
&gt; 
&gt; &gt; We assert that the length of the bitmask is no smaller than the length of the instruction blob (and in fact is simply rounded to the nearest multiple of eight for ease of octet-encoding).
&gt; 
&gt; So, let me quickly summarize the main options that I can see:
&gt; 
&gt; a) change `skip` to not read out of bounds,
&gt; b) keep `skip` as-is, define out of bounds reads to be `1` (after all we already do something similar with the instructions blob),
&gt; c) keep `skip` as-is, define out of bounds reads to be `1`, use a dedicated serialization codec for this bit mask which requires that `|k| mod 8 = 0` and `ceil(|c| / 8) = |k| / 8` (so this would make the business logic explicitly use the &quot;extra&quot; bits, which now I know you don&#x27;t want)
&gt; 
&gt; I can make a PR to the GP. I&#x27;m guessing you&#x27;d like to go with (a), correct?
&gt; 
&gt; (For reference, I&#x27;ve initially implemented (c) in PolkaVM because that was marginally the fastest option which didn&#x27;t require adding any extra unnecessary padding.)

(a) sure. </div>
<div class='msg'><time>2024‑09‑12 15:57</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: And indeed that parenthesised text should be removed as it is neither useful nor commensurate with everything else. </div>
<div class='msg'><time>2024‑09‑12 15:57</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: &gt; &lt;@gav:polkadot.io&gt; (a) sure.

Got it. I&#x27;ll make a PR to the GP and update the test vectors with the fixed paddings then.</div>
<div class='msg'><time>2024‑09‑13 04:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@jan:parity.io&gt; Got it. I&#x27;ll make a PR to the GP and update the test vectors with the fixed paddings then.

That is now in https://github.com/gavofyork/graypaper/pull/77</div>
<div class='msg'><time>2024‑09‑13 04:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@jan:parity.io&gt; Got it. I&#x27;ll make a PR to the GP and update the test vectors with the fixed paddings then.

 * That is now in https://github.com/gavofyork/graypaper/pull/77 ([Fix PVM](https://github.com/gavofyork/graypaper/pull/77/commits/8aad71e12fcb829e70b8bf577de8d45d1b346d41))</div>
<div class='msg'><time>2024‑09‑13 04:48</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: jeff: Can you point us to any ELVES talks posted from you (or anyone else)?  I found one, perhaps there are more?
 Elves paper: https://eprint.iacr.org/2024/961    
 SBC 2024 video: https://www.youtube.com/watch?v=C1teIFTSphE </div>
<div class='msg reply'><time>2024‑09‑23 10:42</time>&ensp;<span class='u' style='color:#c74b98'>alistair</span>: We&#x27;ve been talking about this protcol for years.  I like this talk I gave at a workshop: https://www.youtube.com/watch?v=F8q16k4U2fA . In 2019, Jeff and I gave one at the web3 summit, https://www.youtube.com/watch?v=JgaDYFCKSxM and I gave one at Devcon Osaka, https://www.youtube.com/watch?v=Ex_1XXF29Yo . Maybe Rob Habermeier has some. Expect more now that the paper is out.</div>
<div class='msg'><time>2024‑09‑13 06:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: sourabhniyogi: Before you or your team invest too much effort into attempting to redevelop the JAM protocol please note that following the resolution of [Ordered Accumulations](https://github.com/gavofyork/graypaper/issues/57) I do not anticipate any significant changes beyond tweaks, corrections and high-value-low-impact optimizations.</div>
<div class='msg'><time>2024‑09‑13 06:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * sourabhniyogi: Before you or your team invest too much effort into attempting to redevelop the JAM protocol please note that following the resolution of [Ordered Accumulations](https://github.com/gavofyork/graypaper/issues/57) I do not anticipate any significant changes beyond tweaks, corrections and high-value-low-impact optimizations. Following this issue I consider JAM essentially feature complete and it will be very difficult to convince me to make significant, novel feature additions.</div>
<div class='msg'><time>2024‑09‑13 06:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * sourabhniyogi: Before you or your team invest too much effort into attempting to redevelop the JAM protocol please note that following the resolution of [Ordered Accumulations](https://github.com/gavofyork/graypaper/issues/57) I do not anticipate any significant changes beyond tweaks, corrections and high-value-low-impact optimizations. Following this issue I consider JAM essentially feature complete and it will be very difficult to convince me to merge significant, novel feature additions into the GP. As a rough timeline I would like to have PolkaJAM entering audit by Q2 next year, which pretty much implies a security audit of the GP starting January and thus a spec freeze by EOY.</div>
<div class='msg'><time>2024‑09‑13 08:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * sourabhniyogi: Before you or your team invest too much effort into attempting to redevelop the JAM protocol please note that following the resolution of [Ordered Accumulations](https://github.com/gavofyork/graypaper/issues/57) I do not anticipate any significant changes beyond tweaks, corrections and high-value-low-impact optimizations. Following this issue I consider JAM essentially feature complete and it will be very difficult to convince me to merge significant, novel feature additions into the GP. As a rough timeline I would like to have PolkaJAM entering audit in Q2 next year, which pretty much implies a security audit of the GP starting in Q1 and thus a spec freeze by EOY.</div>
<div class='msg'><time>2024‑09‑13 08:14</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: following up this https://github.com/gavofyork/graypaper/pull/77/commits/b1f172bdf98a52b12cebd9d5064b22230730b5d9</div>
<div class='msg'><time>2024‑09‑13 08:14</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: image.png</div>
<div class='msg'><time>2024‑09‑13 08:14</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: I guess omega X here means `A function</div>
<div class='msg'><time>2024‑09‑13 08:14</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * I guess omega X here means \`A function`</div>
<div class='msg'><time>2024‑09‑13 08:14</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * I guess omega X here means `A function`</div>
<div class='msg'><time>2024‑09‑13 08:15</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: so to avoid confusion may I suggest to remove the `_X` from the omega?</div>
<div class='msg'><time>2024‑09‑13 08:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; following up this https://github.com/gavofyork/graypaper/pull/77/commits/b1f172bdf98a52b12cebd9d5064b22230730b5d9

I cannot see any images you post unfortunately. Please use https://graypaper.fluffylabs.dev/ instead to point to the part of the GP you mean.</div>
<div class='msg'><time>2024‑09‑15 08:33</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: Is [this](https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMzEiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeDE0MyBoYiB5MWUzNiBmZjE2IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4NiBoYiB5MWUzNiBmZjE2IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iXV0=) term always zero? </div>
<div class='msg reply'><time>2024‑09‑15 08:50</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>: No, e.g., if `l` is 0, then this therm is `x`</div>
<div class='msg reply'><time>2024‑09‑15 08:50</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>: If it is the correct link.</div>
<div class='msg reply'><time>2024‑09‑15 08:59</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: image.png</div>
<div class='msg reply'><time>2024‑09‑15 08:59</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: Yes, its the correct link. Should `l` be determined implicitly by the number of octets of x? Or is it explicitly passed as an argument to the encode function? </div>
<div class='msg reply'><time>2024‑09‑15 09:04</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: it is calculated from the encoding number</div>
<div class='msg reply'><time>2024‑09‑15 09:18</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: Is there any case in which `l` calculated from the encoding number be 0?</div>
<div class='msg reply'><time>2024‑09‑15 09:26</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: For x between 2**0 to 2**7 it seems</div>
<div class='msg reply'><time>2024‑09‑16 06:36</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: To make this equation a little more clear, here&#x27;s a visualization of what it does. It essentially encodes numbers as varints in the following way:

```
At most  7bit - 0xxxxxxx
At most 14bit - 10xxxxxx xxxxxxxx
At most 21bit - 110xxxxx xxxxxxxx xxxxxxxx
...
At most 56bit - 11111110 xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
At most 64bit - 11111111 xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
```

So the first encoded byte tells you how long the encoded number is by the amount of `1`s either until the first `0` (starting at the most significant bit) or until the end of the byte. If there&#x27;s &quot;free space&quot; left after the first `0` then part of the number is packed in there (the `x`s in the first byte). And then the rest of the bits of the encoded number are appended (the `x`s after the first byte). So as you can see the number of `x` bits is always divisible by `7` (hence why you can find the `7l` in the GP equation), except the very last case where we don&#x27;t have to encode the `0` in the first byte anymore because we&#x27;ll hit the end of the byte when counting the `1`s when decoding anyway (hence the &quot;otherwise if x &lt; 2^64&quot; part in the GP).

Here are some example numbers encoded using this:
```
number -&gt; encoded as
01111111 -&gt; 01111111 (127 -&gt; [127])
10000000 -&gt; 10000000, 10000000 (128 -&gt; [128, 128])
00111111_11111111 -&gt; 10111111, 11111111 (16383 -&gt; [63, 255])
```

So if you&#x27;re maybe familiar with the &quot;standard&quot; uleb128 varint serialization scheme - this is essentially similar, except instead of putting the continuation bits in every byte it packs all of the continuation bytes in the first byte and limits the number to at most 64-bit. (The rationale for this is that this is more efficient to decode on modern CPUs, because you only need to look at the first byte to know the length of the varint, instead of having to check the most significant bit for every byte.)

Hopefully this makes it a little more clear.</div>
<div class='msg reply'><time>2024‑09‑19 15:09</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: In the last example 
`00111111_11111111 -&gt; 10111111, 11111111 (16383 -&gt; [63, 255])`
Don&#x27;t should be `16383 -&gt; [191, 255]` ?
In this case, `l = 1` 
Acording with (272): 16383 -&gt; 2⁸ - 2⁷ + (16383/2⁸) = 191
concatenate with (16383 mod 2⁸) = 255</div>
<div class='msg reply'><time>2024‑09‑19 15:12</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Yes, you&#x27;re correct. That was a copy-paste error on my part when I converted binary to decimal. 10111111 is, of course, 191 is decimal. Sorry for the confusion.</div>
<div class='msg'><time>2024‑09‑15 08:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: That link doesn’t seem to work especially well. </div>
<div class='msg'><time>2024‑09‑15 09:18</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * Is there any case in which `l` calculated from the encoding number is 0?</div>
<div class='msg'><time>2024‑09‑15 09:26</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: * For x between 2^0 to 2^7 it seems</div>
<div class='msg'><time>2024‑09‑15 09:35</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: </div>
<div class='msg'><time>2024‑09‑15 09:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  If 1 &lt;= x &lt; 128 then l = 0. </div>
<div class='msg'><time>2024‑09‑15 09:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: This is made explicit in the equation you referenced. </div>
<div class='msg'><time>2024‑09‑15 09:42</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: &gt; &lt;@gav:polkadot.io&gt; If 1 &lt;= x &lt; 128 then l = 0.

Ok, I thought `l = number of octets` of x. Thanks.</div>
<div class='msg'><time>2024‑09‑15 09:53</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>: * No, e.g., if `l` is 0, then this term is `x`</div>
<div class='msg'><time>2024‑09‑17 13:08</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Hi,

I have a question regarding state Merkelization. We say we use a Patricia trie, but looking at equation 295, it seems there are no extension nodes for common prefixes, which looks more like a regular prefix trie with Merkle hashing.

Could you confirm if my understanding is correct? If so, (we want a Patricia trie), wouldn’t we need to define l and r using b_t1 and b_t0, where t1 and t0 are the largest common prefix among paths starting with 1 and 0, respectively?</div>
<div class='msg reply'><time>2024‑09‑17 15:17</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: It&#x27;s intentional that there are no extensions nodes. The keys are all hashes and so it isn&#x27;t expected that there will be long common prefixes.</div>
<div class='msg reply'><time>2024‑09‑17 15:29</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: I see ! I&#x27;m definitely not a database expert but doesn&#x27;t it mean we&#x27;ll have at least 512 jumps in the db  </div>
<div class='msg reply'><time>2024‑09‑18 01:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@celadari:matrix.org&gt; I see ! I&#x27;m definitely not a database expert but doesn&#x27;t it mean we&#x27;ll have at least 512 jumps in the db  

Only if it is implemented in the least optimal way. </div>
<div class='msg'><time>2024‑09‑17 15:18</time>&ensp;<span class='u' style='color:#c65779'>dave</span>:  * It&#x27;s intentional that there are no extension nodes. The keys are all hashes and so it isn&#x27;t expected that there will be long common prefixes.</div>
<div class='msg'><time>2024‑09‑17 16:08</time>&ensp;<span class='u' style='color:#30c84d'>clw0908</span>: Hello, some question abount 4 Invocation function entry points:

As GP mention, the four entry points (0 (isAuthorized), 5 (Refine), 10 (Accumulate) and 15 (OnTransfer)) will pass through Ψ M -&gt; Ψ H -&gt; Ψ -&gt; Ψ 1.

My question is: What is the relationship between these four entry points and the PVM&#x27;s instruction counter? Will these different entry points affect the PVM&#x27;s instruction counter?</div>
<div class='msg'><time>2024‑09‑17 16:11</time>&ensp;<span class='u' style='color:#30c84d'>clw0908</span>:  * Hello, some question about 4 Invocation function entry points:

As GP mention, the four entry points (0 (isAuthorized), 5 (Refine), 10 (Accumulate) and 15 (OnTransfer)) will pass through Ψ M -&gt; Ψ H -&gt; Ψ -&gt; Ψ 1.

My question is: What is the relationship between these four entry points and the PVM&#x27;s instruction counter? Will these different entry points affect the PVM&#x27;s instruction counter?</div>
<div class='msg'><time>2024‑09‑17 16:12</time>&ensp;<span class='u' style='color:#30c84d'>clw0908</span>:  * Hello, some question about 4 Invocation function entry points:

As GP mentioned, the four entry points (0 (isAuthorized), 5 (Refine), 10 (Accumulate) and 15 (OnTransfer)) will pass through Ψ M -&gt; Ψ H -&gt; Ψ -&gt; Ψ 1.

My question is: What is the relationship between these four entry points and the PVM&#x27;s instruction counter? Will these different entry points affect the PVM&#x27;s instruction counter?</div>
<div class='msg'><time>2024‑09‑18 01:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The instruction counter is initialised with the entry point. </div>
<div class='msg'><time>2024‑09‑18 02:50</time>&ensp;<span class='u' style='color:#30c84d'>clw0908</span>: &gt; &lt;@gav:polkadot.io&gt; The instruction counter is initialised with the entry point.

Why initialize the instruction counter with the entry point? 
Does it mean that different invocation functions execute different parts of the instruction data (bold C in GP(218))?</div>
<div class='msg'><time>2024‑09‑18 02:50</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: The entry point *is* the instruction counter.</div>
<div class='msg'><time>2024‑09‑18 02:51</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: e.g. for refine you set the instruction pointer to 5 and start execution from there</div>
<div class='msg'><time>2024‑09‑18 02:57</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: To give more backround on this: the way this will work *in practice* is that the program will have 4 unconditional jump instructions at the very start, and the first 3 of those instructions will be encoded in such a way as to be padded and always take up 5 bytes of space. Hence the entry points of 0, 5, 10 and 15. This design allows for hardcoded addresses for each of the entry points without having to specify them dynamically anywhere in the protocol.</div>
<div class='msg'><time>2024‑09‑18 03:03</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: (And just to be clear in case it isn&#x27;t obvious: as a PVM implementation you don&#x27;t and shouldn&#x27;t care about this, and this shouldn&#x27;t be handled in any special way on the VM level. You&#x27;re supposed to set your instruction counter to the hardcoded address of the entry point, and just start execution from there, regardless of what exactly happens to be there. The fact that there will be usually unconditional jump instructions there is just an implementation detail, and is not in any way required by the GP.)</div>
<div class='msg'><time>2024‑09‑18 12:49</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: I believe i found some error in the pvm appendix. 

- https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMmIiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFtdXQ== it says `bold A`.
- i belive this is `A` set which is the ServiceAccount defined in (89) https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMTAiLCJTZXJ2aWNlIEFjY291bnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGYgaDYgeTZmNyBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiIsIjxkaXYgY2xhc3M9XCJ0IG0wIHhmIGg2IHk2ZjcgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iXV0=
- to confirm this i looked at `bold X` which is defined at 254 and `x_s` is being used in 257 for example for the `omega w`
- if ^ is correct then `omega_w` or the `write`function states that i should compare `a_t` and `a_b` but there is no `_t`in the ServiceAccount set.  </div>
<div class='msg'><time>2024‑09‑18 13:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes it should read blackboard A</div>
<div class='msg'><time>2024‑09‑18 13:28</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@gav:polkadot.io&gt; Yes it should read blackboard A

what about the subscribpted t ?</div>
<div class='msg'><time>2024‑09‑18 14:07</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMmMiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeDE1YSBoYiB5MTlmNCBmZjE2IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4NWYgaGQgeTE5ZjYgZmYxOCBmczUgZmMwIHNjMCBsczAgd3MwXCI+Il1d</div>
<div class='msg'><time>2024‑09‑18 14:08</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: same goes for `t_t` in the fn below</div>
<div class='msg'><time>2024‑09‑18 14:32</time>&ensp;<span class='u' style='color:#6ecf94'>qiwei</span>: it could be the threshold balance https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMTEiLCJTZXJ2aWNlIEFjY291bnRzIiwiQWNjb3VudCBGb290cHJpbnQgYW5kIFRocmVzaG9sZCBCYWxhbmNlIixbIjxkaXYgY2xhc3M9XCJ0IG0wIHgxMiBoNiB5NzlhIGZmNyBmczAgZmMwIHNjMCBsczAgd3MwXCI+IiwiPGRpdiBjbGFzcz1cInQgbTAgeGYgaDYgeTc5YyBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==</div>
<div class='msg'><time>2024‑09‑18 14:49</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: oooh</div>
<div class='msg'><time>2024‑09‑18 14:49</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@qiwei:matrix.org&gt; it could be the threshold balance https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMTEiLCJTZXJ2aWNlIEFjY291bnRzIiwiQWNjb3VudCBGb290cHJpbnQgYW5kIFRocmVzaG9sZCBCYWxhbmNlIixbIjxkaXYgY2xhc3M9XCJ0IG0wIHgxMiBoNiB5NzlhIGZmNyBmczAgZmMwIHNjMCBsczAgd3MwXCI+IiwiPGRpdiBjbGFzcz1cInQgbTAgeGYgaDYgeTc5YyBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==

that is definetely it thanks</div>
<div class='msg'><time>2024‑09‑19 07:44</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMmQiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGE2IGhiIHkxYWEzIGZmMTYgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiIsIjxkaXYgY2xhc3M9XCJ0IG0wIHhmZCBoZCB5MWFhNCBmZjE4IGZzNSBmYzAgc2MwIGxzMCB3czBcIj4iXV0= is this correct? i am referring to the 176 offset/length the validator data should be 336 bytes long. 

</div>
<div class='msg'><time>2024‑09‑19 09:45</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: is `m` of deferred transfer Y_64 or Y_128? i ask because in 12.4 the text reads `a memo component m of 64 octets` but then its defined as `m ∈ YM` (161) and `M` is equal to 128 in the appendix. 

What is even more interesting is that the `ΩT` fn on p.45 says we should deserialize a `M` long octet sequence into a `T`value. So my guess is that the (161) is wrong. 

Assuming `m` is Y64 then deserializing `T` means that 128-64 octets must be used to get the other elements in `T` (`s`, `d`, `a`, `g`</div>
<div class='msg'><time>2024‑09‑19 09:45</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * is `m` of deferred transfer Y\_64 or Y\_128? i ask because in 12.4 the text reads `a memo component m of 64 octets` but then its defined as `m ∈ YM` (161) and `M` is equal to 128 in the appendix.

What is even more interesting is that the `ΩT` fn on p.45 says we should deserialize a `M` long octet sequence into a `T`value. So my guess is that the (161) is wrong.

Assuming `m` is Y64 then deserializing `T` means that 128-64 octets must be used to get the other elements in `T` (`s`, `d`, `a`, `g`)</div>
<div class='msg'><time>2024‑09‑19 09:46</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * is `m` of deferred transfer Y\_64 or Y\_128? i ask because in 12.4 the text reads `a memo component m of 64 octets` but then its defined as `m ∈ YM` (161) and `M` is equal to 128 in the appendix.

What is even more interesting is that the `ΩT` fn on p.45 says we should deserialize a `M` long octet sequence into a `T`value. So my guess is that the (161) is wrong.

Assuming `m` is Y64 then deserializing `T` means that 128-64 octets must be used to get the other elements in `T` (`s`, `d`, `a`, `g`). but even if all of them were 8 octets that would mean that we&#x27;re left with 32 extra octets. so I&#x27;m a bit lost</div>
<div class='msg'><time>2024‑09‑20 02:24</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: &gt; &lt;@gav:polkadot.io&gt; sourabhniyogi: Before you or your team invest too much effort into attempting to redevelop the JAM protocol please note that following the resolution of [Ordered Accumulations](https://github.com/gavofyork/graypaper/issues/57) I do not anticipate any significant changes beyond tweaks, corrections and high-value-low-impact optimizations. Following this issue I consider JAM essentially feature complete and it will be very difficult to convince me to merge significant, novel feature additions into the GP. As a rough timeline I would like to have PolkaJAM entering audit in Q2 next year, which pretty much implies a security audit of the GP starting in Q1 and thus a spec freeze by EOY.

How does Coreplay, with its stop-freeze-registers-resume pattern fit into JAM?   

This would be the major &quot;feature request&quot;,  in addition to:
-  connecting JAM back into Polkadot&#x27;s { Staking, Coretime, and Asset Hub } system chains 
 - getting complete about the rewards/punishment for guaranteeing/auditing/...
 - JAMNP
 - getting clear about how the (refineless) privileges services work from a user point of view

I hope by Strongly Web3&#x27;s &quot;equidistant from all teams&quot; principle, we can have multiple teams (3+) undergoing audits and not just PolkaJAM in the Q2 timeframe =).  </div>
<div class='msg'><time>2024‑09‑20 07:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: sourabhniyogi: I am happy to field specific questions on interpretation of the Gray paper. I am not happy to be managed.</div>
<div class='msg'><time>2024‑09‑20 07:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: If you persist with this attitude, I **will ban you**. </div>
<div class='msg'><time>2024‑09‑20 07:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; https://graypaper.fluffylabs.dev/#WyI3YWU1MWY5MzI1IiwiMmQiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGE2IGhiIHkxYWEzIGZmMTYgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiIsIjxkaXYgY2xhc3M9XCJ0IG0wIHhmZCBoZCB5MWFhNCBmZjE4IGZzNSBmYzAgc2MwIGxzMCB3czBcIj4iXV0= is this correct? i am referring to the 176 offset/length the validator data should be 336 bytes long.

Correct - that should be 336. Will be corrected.</div>
<div class='msg'><time>2024‑09‑20 08:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; is `m` of deferred transfer Y\_64 or Y\_128? i ask because in 12.4 the text reads `a memo component m of 64 octets` but then its defined as `m ∈ YM` (161) and `M` is equal to 128 in the appendix.
&gt; 
&gt; What is even more interesting is that the `ΩT` fn on p.45 says we should deserialize a `M` long octet sequence into a `T`value. So my guess is that the (161) is wrong.
&gt; 
&gt; Assuming `m` is Y64 then deserializing `T` means that 128-64 octets must be used to get the other elements in `T` (`s`, `d`, `a`, `g`). but even if all of them were 8 octets that would mean that we&#x27;re left with 32 extra octets. so I&#x27;m a bit lost

That was a typo in the text: where it reads 64 should read 128 and is fixed in the next release. The other points are invalid. The dererialization you refer to is moot (I have since removed the function as it&#x27;s a no-op here), and &quot;deserializes&quot; only the memo data. The other fields of the record are provided elsewhere.</div>
<div class='msg'><time>2024‑09‑20 13:50</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@gav:polkadot.io&gt; That was a typo in the text: where it reads 64 should read 128 and is fixed in the next release. The other points are invalid. The dererialization you refer to is moot (I have since removed the function as it&#x27;s a no-op here), and &quot;deserializes&quot; only the memo data. The other fields of the record are provided elsewhere.

thanks</div>
<div class='msg'><time>2024‑09‑20 15:53</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: &gt; &lt;@gav:polkadot.io&gt; sourabhniyogi: Before you or your team invest too much effort into attempting to redevelop the JAM protocol please note that following the resolution of [Ordered Accumulations](https://github.com/gavofyork/graypaper/issues/57) I do not anticipate any significant changes beyond tweaks, corrections and high-value-low-impact optimizations. Following this issue I consider JAM essentially feature complete and it will be very difficult to convince me to merge significant, novel feature additions into the GP. As a rough timeline I would like to have PolkaJAM entering audit in Q2 next year, which pretty much implies a security audit of the GP starting in Q1 and thus a spec freeze by EOY.

 * How does Coreplay, with its stop-freeze-registers-resume pattern fit into JAM?

This would be the major &quot;feature request&quot;,  in addition to:

- connecting JAM back into Polkadot&#x27;s { Staking, Coretime, and Asset Hub } system chains
- getting complete about the rewards/punishment for guaranteeing/auditing/...
- JAMNP
- getting clear about how the (refineless) privileged services work from a user point of view

I hope by Strongly Web3&#x27;s &quot;equidistant from all teams&quot; principle, we can have multiple teams (3+) undergoing audits and not just PolkaJAM in the Q2 timeframe =).</div>
<div class='msg'><time>2024‑09‑22 21:18</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Screenshot 2024-09-22 at 22.17.56.png</div>
<div class='msg'><time>2024‑09‑22 21:19</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: What is the meaning of av[c] here? As far as I understood, av is an integer. 

I interpret it as the core associated with validator in index av. But I am not sure the formula is accurate to the meaning.</div>
<div class='msg'><time>2024‑09‑22 21:32</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: I think I found the answer: it should be af, not av, right? </div>
<div class='msg'><time>2024‑09‑23 06:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; sent an image.

Cannot see the image - please provide a link using https://graypaper.fluffylabs.dev/ or an equation number along with a version.</div>
<div class='msg'><time>2024‑09‑23 06:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; sent an image.

 * Cannot see the image - please provide a link using https://graypaper.fluffylabs.dev/ or an equation number along with a GP version.</div>
<div class='msg'><time>2024‑09‑23 06:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Ahh - I think I see; yes, a_v should be a_f in two of the equations.</div>
<div class='msg'><time>2024‑09‑23 06:17</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Ahh - I think I see; yes, a\_v should be a\_f in two of the equations. This is fixed in https://github.com/gavofyork/graypaper/pull/77 and will be in the next release.</div>
<div class='msg'><time>2024‑09‑23 06:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: On that note, 0.3.8 is tagged and released: https://github.com/gavofyork/graypaper/releases/tag/v0.3.8</div>
<div class='msg'><time>2024‑09‑23 08:49</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Should Formula  (128) 

af[c] ⇒ ρ†[c]≠∅

be 

af[c] ⇔ ρ†[c]≠∅

?</div>
<div class='msg'><time>2024‑09‑23 09:25</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Another doubt: What does H(Hp, af) means in formula 126? H function should take only one argument, no?</div>
<div class='msg'><time>2024‑09‑23 10:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; Should Formula  (128) 
&gt; 
&gt; af[c] ⇒ ρ†[c]≠∅
&gt; 
&gt; be 
&gt; 
&gt; af[c] ⇔ ρ†[c]≠∅
&gt; 
&gt; ?

No. </div>
<div class='msg'><time>2024‑09‑23 10:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; Another doubt: What does H(Hp, af) means in formula 126? H function should take only one argument, no?

H by default encodes any arguments give prior to hashing. </div>
<div class='msg'><time>2024‑09‑23 10:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; Another doubt: What does H(Hp, af) means in formula 126? H function should take only one argument, no?

* H is assumed to encode any arguments give prior to hashing. Multiple arguments are treated as types. </div>
<div class='msg'><time>2024‑09‑23 10:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; Another doubt: What does H(Hp, af) means in formula 126? H function should take only one argument, no?

* H is assumed to encode any arguments give prior to hashing. Multiple arguments are treated as tuples. </div>
<div class='msg'><time>2024‑09‑23 14:17</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: &gt; &lt;@gav:polkadot.io&gt; H is assumed to encode any arguments give prior to hashing. Multiple arguments are treated as tuples.

Just to make sure I understood correctly:

af is a binary string of 341 elements (e.g. represented in programming languages as an array of integers). It is not clear to me how should we hash this tuple. There is no clear definition of how to Hash a tuple in the GP. H(m ∈ Y)
 
Should I assume: concat the Hp binary with the 0 and 1 af array and then Hash the result of this concatenation?</div>
<div class='msg'><time>2024‑09‑23 17:58</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: </div>
<div class='msg'><time>2024‑09‑23 17:59</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * After implementing the codec functions, I noticed that there is already a crate [parity-scale-codec](https://github.com/paritytech/parity-scale-codec). Does this crate give the same results as the GP codec functions?</div>
<div class='msg'><time>2024‑09‑23 17:59</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * After implementing the codec functions, I noticed that there is already a crate [parity-scale-codec](https://github.com/paritytech/parity-scale-codec). Does this crate functions give the same results as the GP codec functions?</div>
<div class='msg'><time>2024‑09‑23 18:01</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * After implementing the codec functions, I noticed that there is already a crate [parity-scale-codec](https://github.com/paritytech/parity-scale-codec).. Does this crate have the same implementation as the ones of GP codec functions?</div>
<div class='msg'><time>2024‑09‑23 18:02</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * After implementing the codec functions, I noticed that there is already a crate [parity-scale-codec](https://github.com/paritytech/parity-scale-codec). Does this crate have the same implementation as the ones of GP codec functions?</div>
<div class='msg'><time>2024‑09‑23 18:02</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * After implementing the codec functions, I noticed that there is already a crate [parity-scale-codec](https://github.com/paritytech/parity-scale-codec). Does this crate have the same implementation as the GP codec functions?</div>
<div class='msg'><time>2024‑09‑23 18:20</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * After implementing the codec functions, I noticed that there is already a crate [parity-scale-codec](https://github.com/paritytech/parity-scale-codec). Does this crate have the same encode implementations as the GP codec functions?</div>
<div class='msg'><time>2024‑09‑23 19:37</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: After implementing the codec functions, I noticed that there is already a crate [parity-scale-codec](https://github.com/paritytech/parity-scale-codec). Does this crate have the same encode implementations as the GP codec functions?</div>
<div class='msg reply'><time>2024‑09‑23 19:59</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: There are some similarities, but nope. AFAIR SCALE was initially mentioned in the Gray Paper (and is mentioned on the JAM prize website), but it is no longer. Main difference is the variable-length encoding of numbers. </div>
<div class='msg reply'><time>2024‑09‑23 22:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (Updated my JAM prize page to remove reference to SCALE.)</div>
<div class='msg reply'><time>2024‑09‑23 22:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: FWIW the only difference between SCALE and JAM&#x27;s serialization codec is in treatment of compact integers.</div>
<div class='msg'><time>2024‑09‑23 22:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; Just to make sure I understood correctly:
&gt; 
&gt; af is a binary string of 341 elements (e.g. represented in programming languages as an array of integers). It is not clear to me how should we hash this tuple. There is no clear definition of how to Hash a tuple in the GP. H(m ∈ Y)
&gt;  
&gt; Should I assume: concat the Hp binary with the 0 and 1 af array and then Hash the result of this concatenation?

Ignore how you think “programming languages” represent binary strings.</div>
<div class='msg'><time>2024‑09‑23 22:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; Just to make sure I understood correctly:
&gt; 
&gt; af is a binary string of 341 elements (e.g. represented in programming languages as an array of integers). It is not clear to me how should we hash this tuple. There is no clear definition of how to Hash a tuple in the GP. H(m ∈ Y)
&gt;  
&gt; Should I assume: concat the Hp binary with the 0 and 1 af array and then Hash the result of this concatenation?

* Ignore how you think “programming languages” represent binary strings - that’s an astounding presumption. </div>
<div class='msg'><time>2024‑09‑23 22:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: As I wrote:

&gt; H is assumed to encode any arguments give prior to hashing. Multiple arguments are treated as tuples. </div>
<div class='msg'><time>2024‑09‑23 22:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The GP defines how to encode tuples and how to hash octet-sequences. </div>
<div class='msg'><time>2024‑09‑23 22:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; Just to make sure I understood correctly:
&gt; 
&gt; af is a binary string of 341 elements (e.g. represented in programming languages as an array of integers). It is not clear to me how should we hash this tuple. There is no clear definition of how to Hash a tuple in the GP. H(m ∈ Y)
&gt;  
&gt; Should I assume: concat the Hp binary with the 0 and 1 af array and then Hash the result of this concatenation?

* Ignore how you think “programming languages” represent binary strings - that’s an astounding presumption and is totally irrelevant within this channel. </div>
<div class='msg'><time>2024‑09‑23 22:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: And please note that no &quot;assumptions&quot; are needed. This is all detailed in the GP: https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiNyIsIk5vdGF0aW9uYWwgQ29udmVudGlvbnMiLCJDcnlwdG9ncmFwaHkiLFsiPGRpdiBjbGFzcz1cInQgbTAgeDE1IGhiIHkyMzcgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4MTUgaDYgeTIzYSBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==</div>
<div class='msg'><time>2024‑09‑24 02:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * There&#x27;s a lot of programming languages in the world. I&#x27;d avoid trying to make blanket statements about them.</div>
<div class='msg'><time>2024‑09‑24 02:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: To avoid further confusion I&#x27;ll make it even more explicit with the sentence:

&gt; The inputs of a hash function should be expected to be passed through our serialization codec $\mathcal{E}$ to yield an octet sequence to which the cryptography may be applied. </div>
<div class='msg'><time>2024‑09‑24 02:58</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: GP defines BLS pubkey to be 144 bytes but it seems like the BLS pubkey is usually 48 bytes?</div>
<div class='msg'><time>2024‑09‑24 03:00</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: which function should be used for the pubkey serialization? https://github.com/supranational/blst/blob/6f3136ffb636974166a93f2f25436854fe8d10ff/bindings/blst.h#L303</div>
<div class='msg'><time>2024‑09‑24 03:04</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: seems like the raw type (`blst_p1`) is 144 bytes but that should be internal details</div>
<div class='msg'><time>2024‑09‑24 07:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@xlchen:matrix.org&gt; GP defines BLS pubkey to be 144 bytes but it seems like the BLS pubkey is usually 48 bytes?

[@davxy:matrix.org](https://matrix.to/#/@davxy:matrix.org)?</div>
<div class='msg'><time>2024‑09‑24 08:59</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: The public key for the scheme consists of two public elements, each corresponding to one of the two groups used by BLS for pairing: G1 and G2. Specifically, it is represented as (g1*sk, g2*sk), where g1 is the generator of G1 and g2 is the generator of G2. Each point in G1 is compressed into 48 bytes, while each point in G2 is compressed into 96 bytes. This scheme allows for fast verification of aggregate signatures (which are very useful for bridges). In particular the G1 component allows for aggregate signature correctness verification without the need for N expensive pairings, with N the number of aggregated signatures. The full scheme is detailed in this paper: https://eprint.iacr.org/2022/1611 and is implemented by this library: https://github.com/w3f/bls. The authors of the paper are jeff  Syed Alistair and Oana Ciobotaru
</div>
<div class='msg'><time>2024‑09‑24 09:02</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I see. I guess I should switch from using blst to w3f/bls</div>
<div class='msg'><time>2024‑09‑24 09:04</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * The public key for the scheme consists of two public elements, each corresponding to one of the two groups used by BLS for pairing: G1 and G2. Specifically, it is represented as (g1 * sk, g2 * sk), where g1 is the generator of G1 and g2 is the generator of G2. Each point in G1 is compressed into 48 bytes, while each point in G2 is compressed into 96 bytes. This scheme allows for fast verification of aggregate signatures (which are very useful for bridges). In particular the G1 component allows for aggregate signature correctness verification without the need for N expensive pairings, with N the number of aggregated signatures. The full scheme is detailed in this paper: https://eprint.iacr.org/2022/1611 and is implemented by this library: https://github.com/w3f/bls. The authors of the paper are jeff  Syed Alistair and Oana Ciobotaru</div>
<div class='msg'><time>2024‑09‑24 15:07</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: I have a doubt; in A.1, we define the program blob `p` (octects containing instructions `c`, bitmask `k` and jump `j`).

Then in A.7 we say &quot;We thus define the standard program code format p, which includes not only the instructions and jump table (pre-
viously represented by the term c), but ...&quot;

This I think it is wrong since we already defined `p` as the combination of `c`, `k` and `j`; the term `c` previously indicates only the instruction data.</div>
<div class='msg'><time>2024‑09‑24 16:45</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Would it make sense to maintain an extended recent block history for checking prerequisite WP hashes? As it stands, a work package can have a recent enough anchor block to in theory be reportable, but not actually be reportable because the reporting of its prerequisite WP has been forgotten about. A WP with a prerequisite essentially has a shorter lifetime than other WPs because of this.</div>
<div class='msg'><time>2024‑09‑25 02:17</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: Screenshot 2024-09-25 at 2.17.13 PM.png</div>
<div class='msg'><time>2024‑09‑25 02:18</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: isn&#x27;t this a circular dependency? The sealing key depends on unsigned block, but it includes Hv, and Hv depends on the VRF output of Hs?</div>
<div class='msg reply'><time>2024‑09‑25 06:17</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: I think you first generate the anonymous VRF (with ring root) as a ticket submitter - you don&#x27;t aux for that: only context.

This anonymous VRF happens to be equal to Y(H_s). You compute a signature H_v and then you compute H_s.

Everything I said is you as a block author.</div>
<div class='msg reply'><time>2024‑09‑25 08:26</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: thanks. that make sense</div>
<div class='msg reply'><time>2024‑09‑25 08:39</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: how about the fallback case?</div>
<div class='msg reply'><time>2024‑09‑25 09:04</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: I think you generate Y(H_s) as a normal VRF using the context X_F ++ eta_3: anonymous and non-anonymous method give same VRF but here you can use whichever you want. You don&#x27;t need aux for VRF output: just the context.

You then compute signature H_v and then you compute signature H_s.

Again, everything I said is you as a block author.

If someone can confirm what I said it would be nice</div>
<div class='msg'><time>2024‑09‑25 02:20</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: or does the message (encoded unsigned block) won&#x27;t impact the VRF output? so I can pass empty data when calculating the VRF output?</div>
<div class='msg'><time>2024‑09‑25 06:17</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: * I think you first generate the anonymous VRF (with ring root) as a ticket submitter - you don&#x27;t need aux for that: only context.

This anonymous VRF happens to be equal to Y(H_s). You compute a signature H_v and then you compute H_s.

Everything I said is you as a block author.</div>
<div class='msg'><time>2024‑09‑25 09:04</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>:  * I think you generate Y(H\_s) as a normal VRF using the context X\_F ++ eta\_3: anonymous and non-anonymous method give same VRF so here you can use whichever you want. You don&#x27;t need aux for VRF output: just the context.

You then compute signature H\_v and then you compute signature H\_s.

Again, everything I said is you as a block author.

If someone can confirm what I said it would be nice</div>
<div class='msg'><time>2024‑09‑25 15:41</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: I confirm.
Y(H_s) can also be generated independently from the signature (you just need the context). That is what breaks the cyclic dep.
</div>
<div class='msg'><time>2024‑09‑25 15:44</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: https://github.com/davxy/bandersnatch-vrfs-spec/blob/8c82722a8e9a29df7f7aca7e3c25aa1bef0c2409/assets/example/src/main.rs#L71</div>
<div class='msg'><time>2024‑09‑25 15:45</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: Y is then the output point hash. See here:

https://github.com/davxy/bandersnatch-vrfs-spec/blob/8c82722a8e9a29df7f7aca7e3c25aa1bef0c2409/assets/example/src/main.rs#L198</div>
<div class='msg'><time>2024‑09‑27 22:34</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: A couple of questions regarding audit announcement statements (https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiMWIiLCJBdWRpdGluZyBhbmQgSnVkZ2luZyIsIlNlbGVjdGlvbiBvZiBSZXBvcnRzIixbIjxkaXYgY2xhc3M9XCJ0IG0wIHhiYyBoMTAgeWVjYiBmZjEwIGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4MTFmIGhiIHllY2IgZmYxNiBmczAgZmMwIHNjMCBsczAgd3MwXCI+Il1d):

1. Is the H(w) intended to mean the hash of the work report? It looks like the wrong font has been used
2. Is a_0 intended to read a_n instead?
3. Is it intended that announcement statements do not include eg the hash of the block that is being audited?</div>
<div class='msg'><time>2024‑09‑27 22:34</time>&ensp;<span class='u' style='color:#c65779'>dave</span>:  * A few questions regarding audit announcement statements (https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiMWIiLCJBdWRpdGluZyBhbmQgSnVkZ2luZyIsIlNlbGVjdGlvbiBvZiBSZXBvcnRzIixbIjxkaXYgY2xhc3M9XCJ0IG0wIHhiYyBoMTAgeWVjYiBmZjEwIGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4MTFmIGhiIHllY2IgZmYxNiBmczAgZmMwIHNjMCBsczAgd3MwXCI+Il1d):

1. Is the H(w) intended to mean the hash of the work report? It looks like the wrong font has been used
2. Is a\_0 intended to read a\_n instead?
3. Is it intended that announcement statements do not include eg the hash of the block that is being audited?</div>
<div class='msg'><time>2024‑09‑28 02:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 1. Yes. 
2. Yes. 
3. No - the GP describes the signed material, but other data may be passed in addition for context. </div>
<div class='msg reply'><time>2024‑09‑30 14:33</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Re (3), because the block&#x27;s hash is not included in the signed data, it doesn&#x27;t seem unlikely that an announcement intended for a block on one fork could be fiddled with and then used in the context of a block on a different fork? Maybe this is not a problem but that is not clear to me</div>
<div class='msg reply'><time>2024‑09‑30 16:40</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: One more question on this... AFAICT, as currently specified, auditing of a block is performed by the prior validator set rather than the posterior validator set. This seems a bit odd, given that eg the availability assurance stuff uses the posterior validator set. Wondering if this is intentional or if it was simply missed when lots of things were changed to use posterior state?</div>
<div class='msg reply'><time>2024‑09‑30 22:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dave:parity.io&gt; One more question on this... AFAICT, as currently specified, auditing of a block is performed by the prior validator set rather than the posterior validator set. This seems a bit odd, given that eg the availability assurance stuff uses the posterior validator set. Wondering if this is intentional or if it was simply missed when lots of things were changed to use posterior state?

They’re two very different processes - auditing is entirely off-chain and assurance is recorded on-chain - so I wouldn’t draw any conclusions about one from the other. </div>
<div class='msg reply'><time>2024‑09‑30 22:47</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Well auditors may request shards from assurers. If they&#x27;re always the same set you might for example only service shard requests if you have seen an appropriate audit announcement first (not sure if this would be sensible)</div>
<div class='msg'><time>2024‑09‑28 02:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * 1. Yes. 
2. Yes. 
3. No - the GP describes the signed material, but other data may be passed in addition for context. The signed material itself doesn’t need the block hash. </div>
<div class='msg'><time>2024‑09‑30 02:49</time>&ensp;<span class='u' style='color:#6ecf94'>qiwei</span>: https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiMmUiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGMzIGhiIHkxYzMyIGZmZiBmczAgZmMwIHNjMCBsczAgd3MwXCI+IiwiPGRpdiBjbGFzcz1cInQgbTAgeDE2OCBoYiB5MWMzMiBmZjE2IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iXV0=
just want to confirm, should it be `w &lt; t - D` for this case?</div>
<div class='msg'><time>2024‑09‑30 04:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: No - it is correct as it is. </div>
<div class='msg'><time>2024‑09‑30 04:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Note that the syntax in the preceding portion is the little-used numeric tuple subscript (the subscript “2”). I intend to remove this syntax in an upcoming revision. Instead the entire term “(x_s)_l[h,z]_2” can simply be replaced with“w”. </div>
<div class='msg'><time>2024‑09‑30 07:36</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: Graypaper releases with black backgrounds remain a pain point for me personally. Does anyone have a convenience download of the 0.3.8 release without the background and with black text? For a while these were available for download on the Graypaper site in the resources section.</div>
<div class='msg reply'><time>2024‑09‑30 07:39</time>&ensp;<span class='u' style='color:#6ecf94'>qiwei</span>: https://jamcha.in/spec you can download light version here</div>
<div class='msg reply'><time>2024‑09‑30 07:40</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: great thanks hadn&#x27;t noticed that yet :)</div>
<div class='msg reply'><time>2024‑09‑30 12:38</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Great thanks as well</div>
<div class='msg'><time>2024‑09‑30 17:03</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: Question about [Discriminator Encoding (275)](https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiMzEiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeGYgaDYgeTFlNTAgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iLCI8ZGl2IGNsYXNzPVwidCBtMCB4ZjEgaGIgeTFlNTAgZmY3IGZzMCBmYzAgc2MwIGxzMCB3czBcIj4iXV0=) Must it support encoding sequences of several types? e.g., [u32, u8, i64, u16...]</div>
<div class='msg'><time>2024‑09‑30 22:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Sequences are generally drawn from the same type. </div>
<div class='msg'><time>2024‑09‑30 22:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: But regardless, even if they were not it would not alter anything in the spec. </div>
<div class='msg'><time>2024‑09‑30 22:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * They’re two very different processes - auditing is entirely off-chain, recorded publicly only through grandpa; assurance is recorded on-chain - so I wouldn’t draw any conclusions about one from the other. </div>
<div class='msg'><time>2024‑09‑30 22:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Well in any case, it should be the posterior set for auditing </div>
<div class='msg'><time>2024‑09‑30 22:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The slight annoyance for clients is that there may be several forks. </div>
<div class='msg'><time>2024‑09‑30 22:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: So clients need to track all forks and do all audits of those forks where they are in the posterior set. </div>
<div class='msg'><time>2024‑09‑30 23:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Well in any case, it should in some sense be the posterior set for auditing.</div>
<div class='msg'><time>2024‑09‑30 23:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Well in any case, it should in some sense be the posterior set for auditing; there is not really a difference for auditing as it&#x27;s a fully off-chain process. With assurance, you actually check signatures on-chain, so you need to select which of the two sets those sigs refer to. Auditing doesn&#x27;t happen inside a block. No audit signatures are routinely checked on-chain (judgements are the exception, and these are intentionally drawn from the prior set). Auditing happens *between* blocks. So there really isn&#x27;t a prior or posterior. There&#x27;s just the &quot;current&quot; keyset.</div>
<div class='msg'><time>2024‑09‑30 23:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Well in any case, it should in some sense be the posterior set for auditing; there is not really a difference for auditing as it&#x27;s a fully off-chain process. With assurance, you actually check signatures on-chain, so you need to select which of the two sets those sigs refer to. Auditing doesn&#x27;t happen inside a block. No audit signatures are routinely checked on-chain (judgements are the exception, and these are intentionally drawn from the prior set). Auditing happens _between_ blocks. So there really isn&#x27;t a prior or posterior. There&#x27;s just the &quot;current&quot; validator key set.</div>
<div class='msg'><time>2024‑09‑30 23:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * There is not really the prior/posterior difference for auditing as it&#x27;s a fully off-chain process. With assurance, you actually check signatures on-chain, so you need to select which of the two sets those sigs refer to. Auditing doesn&#x27;t happen inside a block. No audit signatures are routinely checked on-chain (judgements are the exception, and these are intentionally drawn from the prior set). Auditing happens _between_ blocks. So there really isn&#x27;t a prior or posterior. There&#x27;s just the &quot;current&quot; validator key set.</div>
<div class='msg'><time>2024‑09‑30 23:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * David Emett: There is not really the prior/posterior difference for auditing as it&#x27;s a fully off-chain process. With assurance, you actually check signatures on-chain, so you need to select which of the two sets those sigs refer to. Auditing doesn&#x27;t happen inside a block. No audit signatures are routinely checked on-chain (judgements are the exception, and these are intentionally drawn from the prior set). Auditing happens _between_ blocks. So there really isn&#x27;t a prior or posterior. There&#x27;s just the &quot;current&quot; validator key set.</div>
<div class='msg'><time>2024‑09‑30 23:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * David Emett: There is not really the prior/posterior difference for auditing as it&#x27;s a fully off-chain process. With assurance, you actually check signatures on-chain, so you need to select which of the two sets those sigs refer to. Auditing doesn&#x27;t happen inside a block. No audit signatures are routinely checked on-chain (judgements are the exception, and these are intentionally drawn from the prior set). Auditing happens _between_ blocks. So there really isn&#x27;t a prior or posterior. There&#x27;s just the &quot;current&quot; validator key set. I suppose that could be phrased as the posterior of the block associated with the timeslot at the point that the auditing process began.</div>
<div class='msg'><time>2024‑09‑30 23:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * So clients need to track all forks and do all audits of those forks where they are in the resultant (i.e. posterior) set. </div>
<div class='msg'><time>2024‑09‑30 23:14</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: AIUI auditing happens in the context of a block, and this block has a prior validator set and a posterior validator set. We presumably need to pick one of these to be the validator set that is expected to audit the block? I don&#x27;t understand how you could just use the &quot;current&quot; validator set as (a) there is no consensus over this and (b) auditing is stateful and thus we presumably need the same validator set throughout the whole auditing process for a block?</div>
<div class='msg'><time>2024‑09‑30 23:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: So both auditing and block STF happen in the context of some pre-existing chain-head and its implied (posterior) state. In the context of the the block STF (which essentially validates a candidate child-block and determines the implied (posterior) state), then we now have two states - the old implied state and the new implied state. I call these two the prior and the posterior, since one is the state before the STF and the other is after the STF.</div>
<div class='msg'><time>2024‑09‑30 23:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Auditing is not an STF.</div>
<div class='msg'><time>2024‑09‑30 23:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There is only one state: the former.</div>
<div class='msg'><time>2024‑09‑30 23:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * There is only one state to consider: the former.</div>
<div class='msg'><time>2024‑09‑30 23:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Now, depending on how you argue that this should be named the prior or the posterior. But the reality is that neither name is sensible.</div>
<div class='msg'><time>2024‑09‑30 23:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Now, depending on how you argue, this should be named the prior or the posterior. But the reality is that neither name is sensible.</div>
<div class='msg'><time>2024‑09‑30 23:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Now, depending on how you argue, this could be named the prior or the posterior. But the reality is that neither name is sensible.</div>
<div class='msg'><time>2024‑09‑30 23:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * So both auditing and block STF happen in the context of some pre-existing chain-head and its implied (posterior) state. In the context of the the block STF (which essentially validates a candidate child-block and determines the implied (posterior) state), then we now have two states - the old implied state and the new implied state. I call these two the prior and the posterior, since one is the state before the STF and the other is after the effects of the STF.</div>
<div class='msg'><time>2024‑09‑30 23:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: AFAIK I never actually specify either term in the section on auditing (nor should I have). I guess the confusion comes from the fact that I didn&#x27;t suffix kappa with a prime. But this wouldn&#x27;t make sense since there is no concept of a non-prime kappa here.</div>
<div class='msg'><time>2024‑09‑30 23:25</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiMWIiLCJBdWRpdGluZyBhbmQgSnVkZ2luZyIsIlNlbGVjdGlvbiBvZiBSZXBvcnRzIixbIjxkaXYgY2xhc3M9XCJ0IG0wIHhmIGg2IHk3YyBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiIsIjxkaXYgY2xhc3M9XCJ0IG0wIHhmIGg2IHk3ZiBmZjcgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==</div>
<div class='msg'><time>2024‑09‑30 23:26</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: You state here that the terms are in the context of the block that is being audited, so sigma prime is the posterior state for example</div>
<div class='msg'><time>2024‑09‑30 23:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yeah fair enough - that part is wrong.</div>
<div class='msg'><time>2024‑09‑30 23:26</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: This seems sensible to me</div>
<div class='msg'><time>2024‑09‑30 23:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It should read as what I wrote above.</div>
<div class='msg'><time>2024‑09‑30 23:28</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Particularly given that you use for example bold W to refer to the accumulated reports, which is defined in terms of prior state and the extrinsic</div>
<div class='msg'><time>2024‑09‑30 23:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: So basically replacing 

&gt; assume ourselves focused on some block B with other terms corresponding, so σ′ is said block’s posterior state, H is its header &amp;c.

with 

&gt; assume ourselves focused on the most recent implied state of the chain σ.</div>
<div class='msg'><time>2024‑09‑30 23:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * So basically replacing

&gt; assume ourselves focused on some block B with other terms corresponding, so σ′ is said block’s posterior state, H is its header &amp;c.

with

&gt; assume ourselves focused on the most recent implied state of the chain, σ.</div>
<div class='msg'><time>2024‑09‑30 23:29</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: It would seem odd to say that &quot;non-prime&quot; variables actually refer to items in the posterior state of the block</div>
<div class='msg'><time>2024‑09‑30 23:29</time>&ensp;<span class='u' style='color:#c65779'>dave</span>:  * It would seem odd to say that &quot;non-prime&quot; names actually refer to items in the posterior state of the block</div>
<div class='msg'><time>2024‑09‑30 23:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * So basically replacing

&gt; assume ourselves focused on some block B with other terms corresponding, so σ′ is said block’s posterior state, H is its header &amp;c.

with

&gt; assume ourselves focused on the most recent implied state of the chain, σ. The header of the most recent block of the chain is assumed as H.</div>
<div class='msg'><time>2024‑09‑30 23:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I&#x27;ll make it explicit.</div>
<div class='msg'><time>2024‑09‑30 23:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: But using prime doesn&#x27;t make sense here for the reasons I mention above.</div>
<div class='msg'><time>2024‑09‑30 23:42</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Not sure I agree. But in any case, if we agree that the validator set which should validate a block is the validator set in the state after the block has been executed, then I&#x27;m happy</div>
<div class='msg'><time>2024‑09‑30 23:43</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: * Not sure I agree. But in any case, if we agree that the validator set which should audit a block is the validator set in the state after the block has been executed, then I&#x27;m happy</div>
<div class='msg'><time>2024‑09‑30 23:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Ok - I notice that we need to use rho (non-prime) in order to describe work-reports which became available as part of the STF. So it&#x27;s going to be convenient (indeed, pretty much necessary) to have both prior and posterior even though auditing *per se* doesn&#x27;t impact their relationship.</div>
<div class='msg'><time>2024‑09‑30 23:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Ok - I notice that we need to draw upon the prior of rho in order to describe work-reports which became available as part of the STF. So it&#x27;s going to be convenient (indeed, pretty much necessary) to have both prior and posterior even though auditing _per se_ doesn&#x27;t impact their relationship.</div>
<div class='msg'><time>2024‑09‑30 23:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Ok - I notice that we need to draw upon the prior of rho in order to describe work-reports which became available during the block. So it&#x27;s going to be convenient (indeed, pretty much necessary) to have both prior and posterior even though auditing _per se_ doesn&#x27;t impact their relationship.</div>
<div class='msg'><time>2024‑09‑30 23:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: So we&#x27;ll keep it as-is and I&#x27;ll add some clarifying text and a prime to kappa.</div>
<div class='msg'><time>2024‑09‑30 23:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: David Emett  https://github.com/gavofyork/graypaper/pull/90</div>
<div class='msg reply'><time>2024‑10‑01 00:35</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: LGTM. Getting back to the original question, should the \kappa bits be \kappa&#x27;?</div>
<div class='msg reply'><time>2024‑10‑01 04:17</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I think kappa’ makes more sense yes. That&#x27;s now in the PR.</div>
<div class='msg'><time>2024‑10‑01 03:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: </div>
<div class='msg'><time>2024‑10‑01 04:17</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * I think kappa’ makes more sense yes. That&#x27;s now in the PR.</div>
<div class='msg'><time>2024‑10‑01 12:26</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: What are the default values for GA, GI and GR?
https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiM2IiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeDExNSBoZSB5ZTUgZmYyMiBmczAgZmMwIHNjMCBsczAgd3MwXCI+IiwiPGRpdiBjbGFzcz1cInQgbTAgeDFmIGg2IHliMiBmZjEgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==</div>
<div class='msg'><time>2024‑10‑01 12:29</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>:  * What are the default values for GA, GI and GR? BTW, if I am not wrong, GR is not used anywhere in the GP
https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiM2IiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFsiPGRpdiBjbGFzcz1cInQgbTAgeDExNSBoZSB5ZTUgZmYyMiBmczAgZmMwIHNjMCBsczAgd3MwXCI+IiwiPGRpdiBjbGFzcz1cInQgbTAgeDFmIGg2IHliMiBmZjEgZnMwIGZjMCBzYzAgbHMwIHdzMFwiPiJdXQ==</div>
<div class='msg'><time>2024‑10‑01 14:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 0, 0, 0</div>
<div class='msg'><time>2024‑10‑01 14:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: This will be detailed in 0.4.0</div>
<div class='msg'><time>2024‑10‑01 14:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * This will be detailed more properly in 0.4 series</div>
<div class='msg'><time>2024‑10‑04 08:47</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: </div>
<div class='msg'><time>2024‑10‑04 09:38</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: shouldnt this be `Y` ?

https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiMTgiLCJXb3JrIFBhY2thZ2VzIGFuZCBXb3JrIFJlcG9ydHMiLCJQYWNrYWdlcyBhbmQgSXRlbXMiLFtdXQ==</div>
<div class='msg'><time>2024‑10‑04 10:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; shouldnt this be `Y` ?
&gt; 
&gt; https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiMTgiLCJXb3JrIFBhY2thZ2VzIGFuZCBXb3JrIFJlcG9ydHMiLCJQYWNrYWdlcyBhbmQgSXRlbXMiLFtdXQ==

Shouldn&#x27;t what by `Y`?</div>
<div class='msg'><time>2024‑10‑04 11:06</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@gav:polkadot.io&gt; Shouldn&#x27;t what by `Y`?

sorry (181) the return should by a sequence of `Y` imho as the output of `zeroPad` (P) does not guarantuee size output</div>
<div class='msg'><time>2024‑10‑07 07:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; shouldnt this be `Y` ?
&gt; 
&gt; https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiMTgiLCJXb3JrIFBhY2thZ2VzIGFuZCBXb3JrIFJlcG9ydHMiLCJQYWNrYWdlcyBhbmQgSXRlbXMiLFtdXQ==

* Shouldn&#x27;t what be `Y`?</div>
<div class='msg'><time>2024‑10‑07 07:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; sorry (181) the return should by a sequence of `Y` imho as the output of `zeroPad` (P) does not guarantuee size output

In this case the zeropad function just has the effect of padding the segment to the size of a single segment (blackboard G) since its input is never bigger than a segment. </div>
<div class='msg'><time>2024‑10‑07 07:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: </div>
<div class='msg'><time>2024‑10‑07 10:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; sorry (181) the return should by a sequence of `Y` imho as the output of `zeroPad` (P) does not guarantuee size output

 * Zeropad function guarantees that the output is an integer multiple of the subscript (l = W_S.W_E, the length of a single segment in bytes). In this case the zeropad function just has the effect of padding the segment to exactly this size (blackboard Y_l === blackboard G) since its input is always greater than zero and never bigger than a segment. </div>
<div class='msg'><time>2024‑10‑07 11:57</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: [GP v0.3.9 is released](https://github.com/gavofyork/graypaper/releases/tag/v0.3.9)</div>
<div class='msg'><time>2024‑10‑07 11:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Expect 0.4.0 to come soon with #78 merged.</div>
<div class='msg'><time>2024‑10‑08 13:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: [GP v0.4.0 is released](https://github.com/gavofyork/graypaper/releases/tag/v0.4.0)

This includes the rather large change, [Ordered Accumulation](https://github.com/gavofyork/graypaper/issues/57). </div>
<div class='msg'><time>2024‑10‑08 13:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There&#x27;s a few other important changes too as well as some fixes for the PVM spec.</div>
<div class='msg'><time>2024‑10‑08 13:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * The `bits` function for building tree nodes is now MSB-first and the PVM spec has several fixes as well as a fair amount of restructuring needed for OrdAcc.</div>
<div class='msg'><time>2024‑10‑08 13:04</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: </div>
<div class='msg'><time>2024‑10‑08 13:04</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: that &quot;i&quot; should be &quot;l&quot;?</div>
<div class='msg'><time>2024‑10‑08 13:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dakkk:matrix.org&gt; that &quot;i&quot; should be &quot;l&quot;?

Please link to GPreader - images don&#x27;t seem to work on this server</div>
<div class='msg'><time>2024‑10‑08 13:08</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>:  * https://graypaper.fluffylabs.dev/#WyIzODcxMDNkODIzIiwiMzAiLCJBY2tub3dsZWRnZW1lbnRzIixudWxsLFtdXQ==

that &quot;i&quot; should be &quot;l&quot;?</div>
<div class='msg'><time>2024‑10‑09 09:04</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: was looking at 0.4.0 i noticed that the isAuthorized invocation&#x27;s F function at 267 should &quot;return&quot; 2 registers .

it was like this even in 0.3.8 but i believe it is atypo. `F` should return </div>
<div class='msg'><time>2024‑10‑09 09:04</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * was looking at 0.4.0 i noticed that the isAuthorized invocation&#x27;s F function at 267 should &quot;return&quot; 2 registers .

it was like this even in 0.3.8 but i believe it is atypo. `F` should return **all** registers considering is being used by `ΨM` and `ΨH` which uses `F` to builld `ω&#x27;&#x27;`</div>
<div class='msg'><time>2024‑10‑09 09:05</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: same goes for the number of input registers. shouldnt that be 13?</div>
<div class='msg'><time>2024‑10‑09 09:06</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: side note: if i am wrong then why/what is the expected output is `n != gas` ? i see `w_8` is now being used</div>
<div class='msg'><time>2024‑10‑09 09:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Planned changes for 0.5 will be comparatively minor and very much directed towards tweaking and optimization:
- Post-Accumulate Preimage Integration
- Extrinsic Commitment should be hash of hashes
- 64-bit PVM</div>
<div class='msg'><time>2024‑10‑09 09:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; same goes for the number of input registers. shouldnt that be 13?

Yes, this is an old typo and will be corrected in 0.4.1</div>
<div class='msg'><time>2024‑10‑09 09:44</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@gav:polkadot.io&gt; Yes, this is an old typo and will be corrected in 0.4.1

thanks for confirming, then... is w_8 value to be placed in w_1 and the rest set to zero?</div>
<div class='msg'><time>2024‑10‑09 09:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: w_1 isn&#x27;t used.</div>
<div class='msg'><time>2024‑10‑09 09:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * w\_1 isn&#x27;t used any more.</div>
<div class='msg'><time>2024‑10‑09 09:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * w\_1 isn&#x27;t used any more. (it was also a typo from when the register sets were limited to the argument/return value registers)</div>
<div class='msg'><time>2024‑10‑09 09:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 0.4.1 is on its way with these fixes.</div>
<div class='msg'><time>2024‑10‑09 09:57</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Released [0.4.1](https://github.com/gavofyork/graypaper/releases/tag/v0.4.1)</div>
<div class='msg'><time>2024‑10‑09 10:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Released GP [v0.4.1](https://github.com/gavofyork/graypaper/releases/tag/v0.4.1)</div>
<div class='msg'><time>2024‑10‑09 13:04</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: on (275) am I wrong or all `bold o` should be `bold u`? </div>
<div class='msg'><time>2024‑10‑09 13:07</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: same goes with (280) </div>
<div class='msg'><time>2024‑10‑09 13:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: image.png</div>
<div class='msg'><time>2024‑10‑09 13:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: ^ here?</div>
<div class='msg'><time>2024‑10‑09 13:08</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: the one below</div>
<div class='msg'><time>2024‑10‑09 13:08</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: `I`</div>
<div class='msg'><time>2024‑10‑09 13:08</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: i&#x27;m looking at 0.4.1</div>
<div class='msg'><time>2024‑10‑09 13:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: ahh yes</div>
<div class='msg'><time>2024‑10‑09 13:09</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: since you might be there gav  check also first case of `C` (279) and (280) &gt; check</div>
<div class='msg'><time>2024‑10‑09 13:10</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * since you might be there gav  check also first case of `C` (279) and (280) &gt; `check fn`</div>
<div class='msg'><time>2024‑10‑09 13:10</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * since you might be there gav  you might also want to check the first case of `C` (279) and (280) &gt; `check fn`</div>
<div class='msg'><time>2024‑10‑09 13:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: First case of C seems fine</div>
<div class='msg'><time>2024‑10‑09 13:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: `check` is corrected in https://github.com/gavofyork/graypaper/pull/99</div>
<div class='msg'><time>2024‑10‑09 15:53</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: quick question, Initially i thought it was a typo but I am now sure i am missing something, what is `_t` in relation to a service account?

for example in the `new</div>
<div class='msg'><time>2024‑10‑09 15:54</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * quick question, Initially i thought it was a typo but I am now sure i am missing something, what is `_t` in relation to a service account?

for example in the `new` accumulate function both `bold s` and `bold a` reference this `_t` </div>
<div class='msg'><time>2024‑10‑09 15:56</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: as well as `(X_{bold s})_t` in the first matching case of `new` </div>
<div class='msg'><time>2024‑10‑09 17:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Threshold balance.</div>
<div class='msg'><time>2024‑10‑09 19:18</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: hi there! we&#x27;ve just deployed a new version of the GP Reader. It has much shorter links and displays notes as annotations on the document itself. If you run into any issues please let us know on github. The GP is also updated to the latest 0.4.1 released earlier today.</div>
<div class='msg'><time>2024‑10‑10 06:50</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: gav: in your opinion what are the parts of the paper that you consider almost &quot;written on stone&quot; (or at least enough solid to be considered almost ready)?</div>
<div class='msg'><time>2024‑10‑10 06:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Nothing is likely to change very much now. Safrole might not change at all.</div>
<div class='msg'><time>2024‑10‑10 06:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It’s hard to see what will need to be tweaked until we begin actually testing and benchmarking. </div>
<div class='msg'><time>2024‑10‑10 06:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: But beyond the issues already in the GP repo and its readme, there’s nothing on my mind which needs altering. </div>
<div class='msg'><time>2024‑10‑10 10:21</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: https://graypaper.fluffylabs.dev/#/c71229b/2e20012e2301 
@gav:polkadot.io we are replacing X.c here, but c is not present in the ResultContext definition 272</div>
<div class='msg'><time>2024‑10‑10 10:21</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>:  * https://graypaper.fluffylabs.dev/#/c71229b/2e20012e2301 
 gav we are replacing X.c here, but c is not present in the ResultContext definition 272</div>
<div class='msg'><time>2024‑10‑10 11:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dakkk:matrix.org&gt; https://graypaper.fluffylabs.dev/#/c71229b/2e20012e2301 
&gt;  gav we are replacing X.c here, but c is not present in the ResultContext definition 272

yeah that&#x27;s a rename issue.</div>
<div class='msg'><time>2024‑10‑10 11:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: fixed in https://github.com/gavofyork/graypaper/pull/99/commits/fd7aee1ab73dbc16271f8136fe671cf42cc61725</div>
<div class='msg'><time>2024‑10‑10 11:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * fixed in https://github.com/gavofyork/graypaper/pull/99/commits/fd7aee1ab73dbc16271f8136fe671cf42cc61725 (will be in 0.4.2)</div>
<div class='msg'><time>2024‑10‑10 12:57</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: Hi everyone, we noticed that the polkavm rust implementation charges 1 extra gas when load/store fails with out of bounds error, however we couldn’t find this described in the graypaper, is this expected behaviour?</div>
<div class='msg reply'><time>2024‑10‑10 13:01</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Do you mean that there is extra gas charged on top of the 1 gas that the instruction costs normally?

If so then that&#x27;s a bug. Nevertheless, it doesn&#x27;t really matter what PolkaVM does here. PolkaVM is *not* a reference implementation of the GP; it&#x27;s just *an* implementation, so you need to remember that just because PolkaVM does something it doesn&#x27;t mean it&#x27;s correct. :P</div>
<div class='msg reply'><time>2024‑10‑10 13:18</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: I understand, I was asking this because there is a PR for the [jamtestvectors](https://github.com/w3f/jamtestvectors/pull/3) and as I can see these are based the PolkaVM implementation, so we are also trying to validate our implementation agains these tests</div>
<div class='msg reply'><time>2024‑10‑10 13:20</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Ah, okay.</div>
<div class='msg reply'><time>2024‑10‑10 13:20</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: in this case I assume a more appropriate place to ask this would me in the PR itself :)</div>
<div class='msg reply'><time>2024‑10‑10 13:20</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: In that case this is expected behavior.</div>
<div class='msg reply'><time>2024‑10‑10 13:21</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: The gas cost model in general is still a work-in-progress, so this is not specced in the GP yet (nor it should be considered final behavior), however the reason you&#x27;re seeing 1 extra gas being charged there is because we charge gas on an entry to a basic block, and not per instruction.</div>
<div class='msg reply'><time>2024‑10‑10 13:22</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Basically, for efficiency&#x27;s sake what we do is we calculate the gas cost for the whole basic block, and charge the whole cost at the start.</div>
<div class='msg reply'><time>2024‑10‑10 13:22</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: And in that particular test case you have a load/store instruction in the middle of a basic block, so the execution gets interrupted.</div>
<div class='msg reply'><time>2024‑10‑10 13:23</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: But since we&#x27;ve already entered the basic block the gas was already charged, as if the *whole* basic block was execution.</div>
<div class='msg reply'><time>2024‑10‑10 13:25</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: So charging the gas at the start of basic blocks allows us to do two things: 1) be more efficient (charging gas on each executed instruction is expensive), and 2) it should allow us to have a better gas cost model which will also take the dependencies between the instructions into account instead of only assigning static costs to each instruction in isolation</div>
<div class='msg reply'><time>2024‑10‑10 13:34</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: oh I see, thanks for explaining, that&#x27;s what I needed to know. So charging for the whole block even though it is probably not going to be fully executed is what we actually want, is this behaviour going to be described in the gray paper eventually?</div>
<div class='msg reply'><time>2024‑10‑10 13:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The behaviour will be fully described, but for now we will be removing these non-concordant test instances.</div>
<div class='msg'><time>2024‑10‑10 13:21</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>:  * in this case I assume a more appropriate place to ask this would be in the PR itself :)</div>
<div class='msg'><time>2024‑10‑10 13:27</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>:  * But since we&#x27;ve already entered the basic block the gas was already charged, as if the _whole_ basic block was executed.</div>
<div class='msg'><time>2024‑10‑10 13:35</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: I&#x27;m a bit confused about this list indexing notation, where a dot is used. I&#x27;ve found this notation only in zip/lace functions of appendix H. I&#x27;m not sure what it means, and I can&#x27;t find a reference in the Notation chapter

https://graypaper.fluffylabs.dev/#/c71229b/382700382700</div>
<div class='msg'><time>2024‑10‑11 08:02</time>&ensp;<span class='u' style='color:#c77c36'>luke_f</span>: Hello
Could anyone please help me understand Eq. 159?
https://graypaper.fluffylabs.dev/#/c71229b/152702152702

Is the symbol ⋃  defined anywhere? I couldn&#x27;t find a  definition.

I’m interpreting it as the union of all dictionaries in Eq. 158, but I’m not sure what exactly the union of dictionaries means in this context. Could someone explain?

Thank you!
</div>
<div class='msg'><time>2024‑10‑11 08:17</time>&ensp;<span class='u' style='color:#c77c36'>luke_f</span>: &gt; &lt;@luke_f:matrix.org&gt; Hello
&gt; Could anyone please help me understand Eq. 159?
&gt; https://graypaper.fluffylabs.dev/#/c71229b/152702152702
&gt; 
&gt; Is the symbol ⋃  defined anywhere? I couldn&#x27;t find a  definition.
&gt; 
&gt; I’m interpreting it as the union of all dictionaries in Eq. 158, but I’m not sure what exactly the union of dictionaries means in this context. Could someone explain?
&gt; 
&gt; Thank you!

oh. i guess the definition is in eq 11
https://graypaper.fluffylabs.dev/#/c71229b/068301068401</div>
<div class='msg'><time>2024‑10‑11 12:58</time>&ensp;<span class='u' style='color:#55d5d5'>rosarp</span>: In section I.4.1  Block-context Terms, reference to equation explaining C is missing. 
C: The service accumulation-commitment, used to form the Beefy root. See equation ??.
Which equation it points to? </div>
<div class='msg'><time>2024‑10‑11 13:01</time>&ensp;<span class='u' style='color:#55d5d5'>rosarp</span>: is it (176) in 12.4 ? 
(176) let (n, o, t, C) = ∆+ (GT , W∗ , (χ, δ † , ι, φ), χg )</div>
<div class='msg'><time>2024‑10‑11 13:03</time>&ensp;<span class='u' style='color:#55d5d5'>rosarp</span>:  * In section I.4.1  Block-context Terms, reference to equation explaining C is missing. 
C: The service accumulation-commitment, used to form the Beefy root. See equation ??.
Which equation it points to? 

https://graypaper.fluffylabs.dev/#/c71229b/3c18003c1b00</div>
<div class='msg'><time>2024‑10‑11 13:03</time>&ensp;<span class='u' style='color:#55d5d5'>rosarp</span>:  * is it (176) in 12.4 ? 
(176) let (n, o, t, C) = ∆+ (GT , W∗ , (χ, δ † , ι, φ), χg )
https://graypaper.fluffylabs.dev/#/c71229b/17b10217b102</div>
<div class='msg'><time>2024‑10‑11 15:01</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@dakkk:matrix.org&gt; I&#x27;m a bit confused about this list indexing notation, where a dot is used. I&#x27;ve found this notation only in zip/lace functions of appendix H. I&#x27;m not sure what it means, and I can&#x27;t find a reference in the Notation chapter
&gt; 
&gt; https://graypaper.fluffylabs.dev/#/c71229b/382700382700

I &#x27;m interested as well. i assumed `times` but didnt explore any further</div>
<div class='msg'><time>2024‑10‑11 15:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@rosarp:matrix.org&gt; is it (176) in 12.4 ? 
&gt; (176) let (n, o, t, C) = ∆+ (GT , W∗ , (χ, δ † , ι, φ), χg )
&gt; https://graypaper.fluffylabs.dev/#/c71229b/17b10217b102

Yes</div>
<div class='msg'><time>2024‑10‑11 15:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dakkk:matrix.org&gt; I&#x27;m a bit confused about this list indexing notation, where a dot is used. I&#x27;ve found this notation only in zip/lace functions of appendix H. I&#x27;m not sure what it means, and I can&#x27;t find a reference in the Notation chapter
&gt; 
&gt; https://graypaper.fluffylabs.dev/#/c71229b/382700382700

Simple scalar multiply</div>
<div class='msg'><time>2024‑10‑11 15:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: But it should be $\cdot$ - i&#x27;ll fix</div>
<div class='msg'><time>2024‑10‑13 17:39</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: What&#x27;s the purpose of `i` in the accumulation context? https://graypaper.fluffylabs.dev/#/c71229b/2b31002b3100

Is it a created account? But it should be optional in that case?</div>
<div class='msg'><time>2024‑10‑14 08:34</time>&ensp;<span class='u' style='color:#c77c36'>luke_f</span>: Hello,
i have a doubt

160 shows \seq{\seq{(\mathbb{W}, \{\H\})}}_\mathsf{E}
but it should be \seq{(\mathbb{W}, \{\H\})}_\mathsf{E}

i.e list of  length E of tuples. not list of lists of tuples

shouldn&#x27;t it?

https://graypaper.fluffylabs.dev/#/c71229b/154402155002

</div>
<div class='msg'><time>2024‑10‑14 09:23</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: I also have a question when calculating posteruor accumulation queue https://graypaper.fluffylabs.dev/#/c71229b/174803174803. what exactly is `n` ?</div>
<div class='msg'><time>2024‑10‑14 09:49</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * I also have a question when calculating posteruor accumulation queue https://graypaper.fluffylabs.dev/#/c71229b/174803174803. what exactly are`n` and `m`used in the accumulation queue poserior calculation ?</div>
<div class='msg'><time>2024‑10‑14 09:50</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * I also have a question when calculating posteruor accumulation queue https://graypaper.fluffylabs.dev/#/c71229b/174803174803. what exactly are `n` (posterior history) and `m`used in the accumulation queue posterior calculation ?</div>
<div class='msg'><time>2024‑10‑14 10:15</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * I also have a question when calculating posteruor accumulation queue https://graypaper.fluffylabs.dev/#/c71229b/174803174803. what exactly are `n` (posterior history) ?

Also `W*` is of `type` sequence</div>
<div class='msg'><time>2024‑10‑14 10:19</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * I also have a question when calculating posteruor accumulation queue https://graypaper.fluffylabs.dev/#/c71229b/174803174803. what exactly are `n` (posterior history) ?

Also `W*` is of `type` sequence 168,165,161 but being used as second parameter of `E` which is a dictionary in 182</div>
<div class='msg'><time>2024‑10‑14 10:20</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * I also have a question when calculating posteruor accumulation queue https://graypaper.fluffylabs.dev/#/c71229b/174803174803. what exactly are `n` (posterior history) ?

Also `W*` is of `type` sequence 168,165,161 but being used as second parameter of `E` which is a dictionary in 182, maybe it was meant to be `P(W*..n)` ?</div>
<div class='msg'><time>2024‑10‑14 10:21</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * I also have a question when calculating posteruor accumulation queue https://graypaper.fluffylabs.dev/#/c71229b/174803174803. what exactly are `n` () ?

Also `W*` is of `type` sequence 168,165,161 but being used as second parameter of `E` which is a dictionary in 182, maybe it was meant to be `P(W*..n)` ?</div>
<div class='msg'><time>2024‑10‑14 10:21</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * I also have a question when calculating posteruor accumulation queue https://graypaper.fluffylabs.dev/#/c71229b/174803174803. what exactly are `n` ?

Also `W*` is of `type` sequence 168,165,161 but being used as second parameter of `E` which is a dictionary in 182, maybe it was meant to be `P(W*..n)` ?</div>
<div class='msg'><time>2024‑10‑14 10:21</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * I also have a question when calculating posteruor accumulation queue https://graypaper.fluffylabs.dev/#/c71229b/174803174803. what exactly is`n` ?

Also `W*` is of `type` sequence 168,165,161 but being used as second parameter of `E` which is a dictionary in 182, maybe it was meant to be `P(W*..n)` ?</div>
<div class='msg'><time>2024‑10‑14 10:24</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: </div>
<div class='msg'><time>2024‑10‑14 11:18</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: n is the number of work reports that were actually accumulated, as returned by \Delta_+, see https://graypaper.fluffylabs.dev/#/c71229b/179e0217b102</div>
<div class='msg'><time>2024‑10‑14 11:41</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@dave:parity.io&gt; n is the number of work reports that were actually accumulated, as returned by \Delta_+, see https://graypaper.fluffylabs.dev/#/c71229b/179e0217b102

I must go to see a doctor I might be turning blind</div>
<div class='msg'><time>2024‑10‑14 12:32</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: A question concerning audit announcements. If we see a negative judgment for a work-report from some other auditor, we are required to audit the work-report ourselves. The GP states that we must announce our intention to audit this work-report (&quot;In all cases, we publish a signed statement of which of the cores we believe we are required to audit&quot;). Currently this isn&#x27;t really possible in JAM-SNP as the &quot;evidence&quot; for requirement to audit a work-report only covers the no-shows case. I can extend the announcement message format to support this but I&#x27;m not sure what the reason is for announcing in this case, is it actually necessary?</div>
<div class='msg'><time>2024‑10‑15 02:21</time>&ensp;<span class='u' style='color:#dbc767'>stanleyli</span>: Hi David Emett , I have read your wonderful JAMNP-S simple.md. I have a few questions and was wondering if you could answer them.

(1)Are the [Segment Shard] of CE139/140 the same as those of CE137?

(2) in CE 139, you mentioned that &quot;Guarantors should initially use protocol 139 to fetch segment shards. If a reconstructed import segment is inconsistent with its reconstructed proof&quot;. What exactly is this &quot;reconstructed proof&quot; when CE 139 only asked for [Segment Shard]? Perhaps you meant Guarantor will use [Segment Shard] retrieved from Assurer to verify against its own pageProof that it sent out during CE 137?

(3) You mentioned that guarantors will use CE139/CE140 to request import segment shards from assurers. However, Builder specify Imported segments using the combination of ({tree_root, index})[https://github.com/w3f/jamtestvectors/blob/master/codec/data/work_package.json#L22-L35] in CE 133 and not [Erasure Root ++ Shard Index ++ len++[Segment Index]]. Should CE 139 have some alternative request format using only [segment_root ++ index]?

(4) I need clarification on how is pageProof being used in CE139/CE140? Our understanding is that page proof is quite large as it&#x27;s encoded with Justification &amp; ↕si⋅⋅⋅+64 in  https://graypaper.fluffylabs.dev/#/c71229b/1a15001a1500. So it&#x27;s probably possible to recover exported segments from pageproof alone;

Do I understand this wrong?</div>
<div class='msg reply'><time>2024‑10‑15 11:09</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: &gt; Are the [Segment Shard] of CE139/140 the same as those of CE137?

Yes. In CE137 the assurer receives a Segment Shard sequence, the CE139/140 Segment Index is an index into this sequence.</div>
<div class='msg reply'><time>2024‑10‑15 11:19</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: &gt; What exactly is this &quot;reconstructed proof&quot; when CE 139 only asked for [Segment Shard]

The segments that are erasure coded consist of the segments exported by the work package _plus_ a sequence of &quot;proof&quot; pages, essentially containing Merkle proofs from the segment root to the exported segments. When you fetch an exported segment, you also need to fetch the corresponding proof to the segment root, so that you can convince yourself and auditors that the segment is correct.</div>
<div class='msg reply'><time>2024‑10‑15 11:23</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: In the full network protocol these proof pages might be implicitly returned, but with SNP you will need to explicitly ask for them.</div>
<div class='msg reply'><time>2024‑10‑15 11:24</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: These proof pages are generated by the function P in the GP, defined here https://graypaper.fluffylabs.dev/#/c71229b/1a1c001a6e00</div>
<div class='msg reply'><time>2024‑10‑15 11:39</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: &gt; You mentioned that guarantors will use CE139/CE140 to request import segment shards from assurers. However, Builder specify Imported segments using the combination of ({tree_root, index})[https://github.com/w3f/jamtestvectors/blob/master/codec/data/work_package.json#L22-L35] in CE 133 and not [Erasure Root ++ Shard Index ++ len++[Segment Index]]. Should CE 139 have some alternative request format using only [segment_root ++ index]

Guarantors will need to maintain a map from Segment Root to Erasure Root. This can be built from the work-reports placed on-chain. Note that an individual assurer cannot in general prove the relationship between a segment shard and the segment root, only between the shard and the erasure root. This is why for CE139/140 an erasure root is sent rather than a segment root. Note also that any segment root --&gt; erasure root mapping constructed based on reports included on-chain may have incorrect entries, as reports included on-chain are not necessarily correct. Guarantors can conclude that an erasure root was incorrect if after fetching all shards with CE 140 and verifying all the justifications, the reconstructed segment and proof do not match up.</div>
<div class='msg reply'><time>2024‑10‑15 11:51</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: &gt; I need clarification on how is pageProof being used in CE139/CE140? Our understanding is that page proof is quite large as it&#x27;s encoded with Justification &amp; ↕si⋅⋅⋅+64 in https://graypaper.fluffylabs.dev/#/c71229b/1a15001a1500. So it&#x27;s probably possible to recover exported segments from pageproof alone;

The proof pages contain Merkle proofs from the segment root to the exported segments. Each proof page/segment contains proofs for 64 exported segments. You certainly can&#x27;t reconstruct the exported segments themselves from these proof pages. CE139/140 is intended to be used to fetch proof page shards as well as exported segment shards. You need to explicitly request proof page shards by passing the appropriate segment indices.</div>
<div class='msg'><time>2024‑10‑15 11:40</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: &gt; You mentioned that guarantors will use CE139/CE140 to request import segment shards from assurers. However, Builder specify Imported segments using the combination of ({tree_root, index})[https://github.com/w3f/jamtestvectors/blob/master/codec/data/work_package.json#L22-L35] in CE 133 and not [Erasure Root ++ Shard Index ++ len++[Segment Index]]. Should CE 139 have some alternative request format using only [segment_root ++ index]

 * &gt; You mentioned that guarantors will use CE139/CE140 to request import segment shards from assurers. However, Builder specify Imported segments using the combination of ({tree\_root, index})\[https://github.com/w3f/jamtestvectors/blob/master/codec/data/work\_package.json#L22-L35\] in CE 133 and not \[Erasure Root ++ Shard Index ++ len++\[Segment Index\]\]. Should CE 139 have some alternative request format using only \[segment\_root ++ index\]

Guarantors will need to maintain a map from Segment Root to Erasure Root. This can be built from the work-reports placed on-chain / distributed via CE135. Note that an individual assurer cannot in general prove the relationship between a segment shard and the segment root, only between the shard and the erasure root. This is why for CE139/140 an erasure root is sent rather than a segment root. Note also that any segment root --&gt; erasure root mapping constructed based on reports included on-chain may have incorrect entries, as reports included on-chain are not necessarily correct. Guarantors can conclude that an erasure root was incorrect if after fetching all shards with CE 140 and verifying all the justifications, the reconstructed segment and proof do not match up.</div>
<div class='msg'><time>2024‑10‑16 07:17</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: In the &#x27;new&#x27; hostcall (https://graypaper.fluffylabs.dev/#/c71229b/2e9a022ee302):
- in case of OOB | CASH, we are assigning 2 elements to a tuple of 3 elements
- we are referencing X_T, which I&#x27;m unable to find defined in any other part of the paper </div>
<div class='msg'><time>2024‑10‑16 11:15</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dakkk:matrix.org&gt; In the &#x27;new&#x27; hostcall (https://graypaper.fluffylabs.dev/#/c71229b/2e9a022ee302):
&gt; - in case of OOB | CASH, we are assigning 2 elements to a tuple of 3 elements
&gt; - we are referencing X_T, which I&#x27;m unable to find defined in any other part of the paper

Will be fixed in 0.4.3</div>
<div class='msg'><time>2024‑10‑16 11:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: @room [0.4.2 is released](https://github.com/gavofyork/graypaper/releases/tag/v0.4.2) </div>
<div class='msg'><time>2024‑10‑17 23:22</time>&ensp;<span class='u' style='color:#dbc767'>stanleyli</span>: Hi gav: is there a typo in the Page proof function here? https://graypaper.fluffylabs.dev/#/293bf5a/1a4f001a5100

Is eq 196 in the ↕s referring to the actual segment or the segment hash? If it’s the segment, then each element within the page proof (encoded as 6Hash + G) would make this page proof extremely large (up to 64 G)  ?</div>
<div class='msg'><time>2024‑10‑17 23:25</time>&ensp;<span class='u' style='color:#dbc767'>stanleyli</span>:  * Hi gav: is there a typo in the Page proof function here? https://graypaper.fluffylabs.dev/#/293bf5a/1a4f001a5100

In eq 196, is the ↕s referring to the actual segment or the segment hash? If it’s the segment, then each element within the page proof (encoded as 6Hash + G) would make this page proof extremely large (up to 64 G) ?</div>
<div class='msg'><time>2024‑10‑18 03:27</time>&ensp;<span class='u' style='color:#30c84d'>clw0908</span>: Hello everyone:

Based on the GP&#x27;s definition, I speculate the following, (not certain if it&#x27;s correct):
(1) The genesis state will have privileged service code to obtain preimages.
(2) Users will use (1) to get their code into on-chain preimages.

My question is: How will the privileged service get the code into the system?</div>
<div class='msg'><time>2024‑10‑18 03:28</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I guess just have it included in genesis state</div>
<div class='msg'><time>2024‑10‑18 07:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Indeed, on both points. </div>
<div class='msg'><time>2024‑10‑18 11:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@stanleyli:matrix.org&gt; Hi gav: is there a typo in the Page proof function here? https://graypaper.fluffylabs.dev/#/293bf5a/1a4f001a5100
&gt; 
&gt; In eq 196, is the ↕s referring to the actual segment or the segment hash? If it’s the segment, then each element within the page proof (encoded as 6Hash + G) would make this page proof extremely large (up to 64 G) ?

Yes, as David Emett suggested, there should be a `H^#(...)` around the `s_{i...+64}`</div>
<div class='msg'><time>2024‑10‑18 11:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Will be in 0.4.3.</div>
<div class='msg'><time>2024‑10‑21 03:08</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: I am likely missing a crucial point important detail concerning the idea that guarantors, in order to use CE139/CE140, must maintain a map from Segment Root to Erasure Root -- this now requires every validator to become a indexer of pretty much a month&#x27;s worth of work packages&#x27;s work reports to be able to be guarantors.   They need to take every single work report, and index ALL the *potential* segment roots to Erasure Roots just to be able to *maybe* fetch some import segment in some future work package&#x27;s work items-- Could this be?   If so, what is the simplest process to map an on-chain work report to all its segment roots *without*  auditing the work report? 

As of 0.4.x, imported segments can now also be specified in a SECOND way with $H^\boxplus$ as (work package hash, segment index) combinations, and further requires that validators build a lookup dictionary mapping these into segment roots.  But given CE139 has `[Erasure-Root ++ Shard Index ++ len++[Segment Index]]`, it seems that this second way to specify imported segments is sufficient for builders to specify import segments ... and has far lower indexing requirements because validators just need to store a months worth of workpackagehash =&gt; erasure-Root mappings to use CE139 (which are just sitting in the work report).  Would it be reasonable to drop the first &quot;older&quot; way with segmentroot and just keep this SECOND method?  If not, why not?

I must have missed something crucial here...  Thank you for your help!</div>
<div class='msg reply'><time>2024‑10‑21 09:10</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Each work report has only one segment root, this is in the availability specifier</div>
<div class='msg reply'><time>2024‑10‑21 09:15</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Re the WP hash to segment root mapping, this only needs to be tracked for ~1 epoch, as the chain can only check mappings going this far back</div>
<div class='msg reply'><time>2024‑10‑21 09:21</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: This is also a reason for still permitting the &quot;older&quot; way: the &quot;newer&quot; way using WP hashes will only work for referencing segments exported by WPs reported in the last ~hour, whereas the &quot;older&quot; way should work for any segments exported in the last ~28 days</div>
<div class='msg reply'><time>2024‑10‑21 09:21</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: &gt; &lt;@dave:parity.io&gt; Each work report has only one segment root, this is in the availability specifier

Probably this is what you are missing?</div>
<div class='msg reply'><time>2024‑10‑21 09:23</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: It should be possible to build this index using only the last 28 days worth of blocks</div>
<div class='msg reply'><time>2024‑10‑21 12:01</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Will review+follow up, thank you!</div>
<div class='msg reply'><time>2024‑10‑21 20:29</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Alright, thank you very much for clarifying the &quot;one segment root&quot;, there are so many different things &quot;segments root&quot; and &quot;segment roots&quot; could mean I&#x27;ll make a point to use singular &quot;segment-root (e)&quot; based on your design and my now clear understanding of what is going on!</div>
<div class='msg reply'><time>2024‑10‑21 20:36</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: One remaining nitpick questio is this: Are you saying that a work item of a work package is _invalid_ if it uses a (workpackagehash, index) combination to specify an import segment if the workpackagehash is more than an epoch old? 

</div>
<div class='msg reply'><time>2024‑10‑21 21:31</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Alright, thank you very much for clarifying the &quot;one segment root&quot;, there are so many different things &quot;segments root&quot; and &quot;segment roots&quot; could mean I&#x27;ll make a point to use singular &quot;segment-root (e)&quot; based on your design and my now clear understanding of what is going on!

FWIW I changed the SNP doc to use &quot;segments-root&quot; as opposed to &quot;segment root&quot;</div>
<div class='msg reply'><time>2024‑10‑21 23:02</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; One remaining nitpick question is this: Are you saying that a work item of a work package is _invalid_ if it uses a (workpackagehash, index) combination to specify an import segment if the workpackagehash is more than an epoch old?  Is this implied/stated in the GP somewhere?  If not, it should be added or made more explicit?

Well, &quot;more than an epoch old&quot; is not exact. The GP is quite explicit about what work reports are valid for inclusion in a block and what happens to them after this point. The WP hash -&gt; segment root mapping is checked at accumulation time, against the history of accumulated work packages, lower-case xi. This happens in the E function with the &quot;x u w_l = w_l u x&quot; check. The history is a circular buffer of length E (= timeslots per epoch), with one entry pushed every block. So it can store _at least_ one epoch&#x27;s worth of history but possibly more if there are &quot;missing&quot; blocks</div>
<div class='msg reply'><time>2024‑10‑21 23:44</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: No debate on that, thanks for explaining.  But  on this last nitpick I mean  the work items in the work package, as of 0.4.x have this $H^\boxplus$ source here: 
https://graypaper.fluffylabs.dev/#/293bf5a/199e0019a500
As far as I can tell, I could have an old work package hash from a long time ago -- &quot;whereas a value drawn from H⊞ implies the hash value is
the hash of the exporting work-package. In the latter case, it must be converted into a segment-root by the guarantor and this conversion reported in the work-report for on-chain validation.&quot;   If you believe this last statement is only applied for around an epoch (with the circular buffer mechanics, as you mention) then we should ensure this is clear in GP, don&#x27;t you think?</div>
<div class='msg reply'><time>2024‑10‑22 10:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; No debate on that, thanks for explaining.  But  on this last nitpick I mean  the work items in the work package, as of 0.4.x have this $H^\boxplus$ source here: 
&gt; https://graypaper.fluffylabs.dev/#/293bf5a/199e0019a500
&gt; As far as I can tell, I could have an old work package hash from a long time ago -- &quot;whereas a value drawn from H⊞ implies the hash value is
&gt; the hash of the exporting work-package. In the latter case, it must be converted into a segment-root by the guarantor and this conversion reported in the work-report for on-chain validation.&quot;   If you believe this last statement is only applied for around an epoch (with the circular buffer mechanics, as you mention) then we should ensure this is clear in GP, don&#x27;t you think?

The guarantor will not be punished for introducing a WR with an old/unvalidatable SR lookup entry. They might just not get rewarded.
And it beyond the scope of the GP (at least currently) to go deep into the optimum strategies across all off-chain behaviour. </div>
<div class='msg'><time>2024‑10‑21 03:11</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * I am likely missing a crucial point important detail concerning the idea that guarantors, in order to use CE139/CE140, must maintain a map from Segment Root to Erasure Root -- this now requires every validator to become a indexer of pretty much a month&#x27;s worth of work packages&#x27;s work reports to be able to be guarantors.   They need to take every single work report, and index ALL the _potential_ segment roots to Erasure Roots just to be able to _maybe_ fetch some import segment in some future work package&#x27;s work items-- Could this be?   If so, what is the simplest process to map an on-chain work report to all its segment roots _without_  auditing the work report?

As of 0.4.x, imported segments can now also be specified in a SECOND way with $H^\\boxplus$ as (work package hash, segment index) combinations, and further requires that validators build a lookup dictionary mapping these into segment roots.  But given CE139 has `[Erasure-Root ++ Shard Index ++ len++[Segment Index]]` as the request key, it seems that this second way to specify imported segments is (a) sufficient for builders to specify import segments ... and (b) has far lower indexing requirements because validators just need to store a months worth of workpackagehash =&gt; erasure-Root mappings to use CE139 (which are just sitting in the work report!).  Would it be reasonable to drop the first &quot;older&quot; way with segmentroot and just keep this SECOND method as the sole method to specify imported segments in a work package?  If not, why not?

I must have missed something crucial here...  Thank you for your help!</div>
<div class='msg'><time>2024‑10‑21 03:13</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * I am likely missing a crucial point important detail concerning the idea that guarantors, in order to use CE139/CE140, must maintain a map from Segment Root to Erasure Root -- this now requires every validator to become a indexer of pretty much a month&#x27;s worth of work packages&#x27;s work reports to be able to be guarantors.   No problem in indexing a month&#x27;s worth of ImportDa, but they need to take every single work report, and index ALL the _potential_ segment roots to Erasure Roots just to be able to _maybe_ fetch some import segment in some future work package&#x27;s work items-- Could this be??   If so, what is the simplest process to map an on-chain work report to all its segment roots _without_  auditing the work report?

As of 0.4.x, imported segments can now also be specified in a SECOND way with $H^\\boxplus$ as (work package hash, segment index) combinations, and further requires that validators build a lookup dictionary mapping these into segment roots.  But given CE139 has `[Erasure-Root ++ Shard Index ++ len++[Segment Index]]` as the request key, it seems that this second way to specify imported segments is (a) sufficient for builders to specify import segments ... and (b) has far lower indexing requirements because validators just need to store a months worth of workpackagehash =&gt; erasure-Root mappings to use CE139 (which are just sitting in the work report!).  Would it be reasonable to drop the first &quot;older&quot; way with segmentroot and just keep this SECOND method as the sole method to specify imported segments in a work package?  If not, why not?

I must have missed something crucial here...  Thank you for your help!</div>
<div class='msg'><time>2024‑10‑21 03:13</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * I am likely missing a crucial point or important detail concerning the idea that guarantors, in order to use CE139/CE140, must maintain a map from Segment Root to Erasure Root -- this now requires every validator to become a indexer of pretty much a month&#x27;s worth of work packages&#x27;s work reports to be able to be guarantors.   No problem in indexing a month&#x27;s worth of ImportDa, but they need to take every single work report, and index ALL the _potential_ segment roots to Erasure Roots just to be able to _maybe_ fetch some import segment in some future work package&#x27;s work items-- Could this be??   If so, what is the simplest process to map an on-chain work report to all its segment roots _without_  auditing the work report?

As of 0.4.x, imported segments can now also be specified in a SECOND way with $H^\\boxplus$ as (work package hash, segment index) combinations, and further requires that validators build a lookup dictionary mapping these into segment roots.  But given CE139 has `[Erasure-Root ++ Shard Index ++ len++[Segment Index]]` as the request key, it seems that this second way to specify imported segments is (a) sufficient for builders to specify import segments ... and (b) has far lower indexing requirements because validators just need to store a months worth of workpackagehash =&gt; erasure-Root mappings to use CE139 (which are just sitting in the work report!).  Would it be reasonable to drop the first &quot;older&quot; way with segmentroot and just keep this SECOND method as the sole method to specify imported segments in a work package?  If not, why not?

I must have missed something crucial here...  Thank you for your help!</div>
<div class='msg'><time>2024‑10‑21 03:14</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * I am likely missing a crucial point or important detail concerning the idea that guarantors, in order to use CE139/CE140, every validator must maintain a map from every Segment Root to Erasure Root -- this now requires every validator to become a indexer of pretty much a month&#x27;s worth of work packages&#x27;s work reports to be able to be guarantors.   No problem in indexing a month&#x27;s worth of ImportDa, but they need to take every single work report, and index ALL the _potential_ segment roots to Erasure Roots just to be able to _maybe_ fetch some import segment in some future work package&#x27;s work items-- Could this be??   If so, what is the simplest process to map an on-chain work report to all its segment roots _without_  auditing the work report?

As of 0.4.x, imported segments can now also be specified in a SECOND way with $H^\\boxplus$ as (work package hash, segment index) combinations, and further requires that validators build a lookup dictionary mapping these into segment roots.  But given CE139 has `[Erasure-Root ++ Shard Index ++ len++[Segment Index]]` as the request key, it seems that this second way to specify imported segments is (a) sufficient for builders to specify import segments ... and (b) has far lower indexing requirements because validators just need to store a months worth of workpackagehash =&gt; erasure-Root mappings to use CE139 (which are just sitting in the work report!).  Would it be reasonable to drop the first &quot;older&quot; way with segmentroot and just keep this SECOND method as the sole method to specify imported segments in a work package?  If not, why not?

I must have missed something crucial here...  Thank you for your help!</div>
<div class='msg'><time>2024‑10‑21 03:15</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * I am likely missing a crucial point or important detail concerning the idea that guarantors, in order to use CE139/CE140, every validator must maintain a map from every Segment Root to Erasure Root -- this now requires every validator to become a indexer of pretty much a month&#x27;s worth of work packages&#x27;s work reports to be able to be guarantors.   No problem in indexing a month&#x27;s worth of ImportDA actiity, but validator need to take every single work report across all of JAM, and index ALL the _potential_ segment roots to Erasure Roots just to be able to _maybe_ fetch some import segment in some future work package&#x27;s work items -- Could this be??   If so, what is the simplest process to map an on-chain work report to all its segment roots _without_  auditing the work report?

As of 0.4.x, imported segments can now also be specified in a SECOND way with $H^\\boxplus$ as (work package hash, segment index) combinations, and further requires that validators build a lookup dictionary mapping these into segment roots.  But given CE139 has `[Erasure-Root ++ Shard Index ++ len++[Segment Index]]` as the request key, it seems that this second way to specify imported segments is (a) sufficient for builders to specify import segments ... and (b) has far lower indexing requirements because validators just need to store a months worth of workpackagehash =&gt; erasure-Root mappings to use CE139 (which are just sitting in the work report!).  Would it be reasonable to drop the first &quot;older&quot; way with segmentroot and just keep this SECOND method as the sole method to specify imported segments in a work package?  If not, why not?

I must have missed something crucial here...  Thank you for your help!</div>
<div class='msg'><time>2024‑10‑21 04:12</time>&ensp;<span class='u' style='color:#de68ab'>ksc85pwpj5</span>: image.png</div>
<div class='msg'><time>2024‑10‑21 04:12</time>&ensp;<span class='u' style='color:#de68ab'>ksc85pwpj5</span>: What does this mean?</div>
<div class='msg'><time>2024‑10‑21 05:00</time>&ensp;<span class='u' style='color:#de68ab'>ksc85pwpj5</span>:  * Excuse me, I would like to ask what the difference is between x ∪ wl and wl ∪ x, and what is the meaning of x ∪ wl = wl ∪ x.</div>
<div class='msg'><time>2024‑10‑21 06:11</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: If I remember properly left or right side take priority in case of keys existing in both elements. This means that a U b = b U a effectively means there are no conflicting keys or if there are their values are the same</div>
<div class='msg reply'><time>2024‑10‑21 09:07</time>&ensp;<span class='u' style='color:#de68ab'>ksc85pwpj5</span>: Understood, thank you for your help.</div>
<div class='msg reply'><time>2024‑10‑21 11:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Indeed. I was a bit torn over how to express this in the paper.</div>
<div class='msg'><time>2024‑10‑21 08:52</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: what is the `w` referenced in the forget host call? https://graypaper.fluffylabs.dev/#/293bf5a/30e60030e600</div>
<div class='msg'><time>2024‑10‑21 08:55</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: in quit hostcall, `a` is never used: https://graypaper.fluffylabs.dev/#/293bf5a/2f55012f5e01</div>
<div class='msg'><time>2024‑10‑21 09:13</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: in historical_lookup hostcall, `k` is undefined: https://graypaper.fluffylabs.dev/#/293bf5a/307102307102 </div>
<div class='msg'><time>2024‑10‑21 09:26</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: `i` is undefined in poke hostcall: https://graypaper.fluffylabs.dev/#/293bf5a/316d02317402</div>
<div class='msg reply'><time>2024‑10‑21 09:31</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Typo; that should be `l`</div>
<div class='msg'><time>2024‑10‑21 12:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dakkk:matrix.org&gt; in quit hostcall, `a` is never used: https://graypaper.fluffylabs.dev/#/293bf5a/2f55012f5e01

a is used to construct t: https://graypaper.fluffylabs.dev/#/293bf5a/2f97012f9801</div>
<div class='msg'><time>2024‑10‑21 12:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dakkk:matrix.org&gt; what is the `w` referenced in the forget host call? https://graypaper.fluffylabs.dev/#/293bf5a/30e60030e600

It is the third item of (x_s)_l[h, z] with the assertion that it&#x27;s a three-item array </div>
<div class='msg'><time>2024‑10‑21 12:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dakkk:matrix.org&gt; what is the `w` referenced in the forget host call? https://graypaper.fluffylabs.dev/#/293bf5a/30e60030e600

 * It is the third item of (x\_s)\_l\[h, z\] with the condition that it&#x27;s a three-item array (notice it&#x27;s behind the &quot;if&quot; condition)</div>
<div class='msg'><time>2024‑10‑21 12:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It wasn&#x27;t especially clear that the value was used as it was only referenced with the &quot;_2&quot; subscript prior to the &quot;if&quot;. This will be improved in 0.4.3.</div>
<div class='msg'><time>2024‑10‑21 12:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: @room [0.4.3](https://github.com/gavofyork/graypaper/releases/tag/v0.4.3) is released with all the latest corrections/clarifications.</div>
<div class='msg'><time>2024‑10‑21 21:26</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * One remaining nitpick question is this: Are you saying that a work item of a work package is _invalid_ if it uses a (workpackagehash, index) combination to specify an import segment if the workpackagehash is more than an epoch old?  Is this implied/stated in the GP somewhere?  If not, it should be added or made more explicit?</div>
<div class='msg'><time>2024‑10‑22 07:22</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: in export hostcall, constant W_X is not defined: https://graypaper.fluffylabs.dev/#/439ca37/31ab0031ae00</div>
<div class='msg'><time>2024‑10‑22 11:14</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: Hello, I am struggling to understand appendix A.7 more specifically I can&#x27;t find the explanation for a bunch of variables like `o`, `w`, `z`, `s` in formula `260` and later `a`, `W`, `R`, `V`, `A` in formula `264`. I have managed to decode RAM but mainly looking at the polkavm rust implementation however I don&#x27;t understand how to decode the registers from the program code `p`</div>
<div class='msg reply'><time>2024‑10‑22 11:27</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: The formula (264) defines the memory map of the standard program initialization (that is: what is put at a given memory address, whether it&#x27;s initialized, whether it&#x27;s read-only/read-write, etc.). The formula (260) is essentially the standard JAM &quot;program blob&quot;. You don&#x27;t decode the registers from **p** (260); the initial values of the registers are given in (265).</div>
<div class='msg reply'><time>2024‑10‑22 11:54</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: Yeah, that would make sense however I got confused by this sentance:
&quot;We thus define the standard program code format p, which includes not only the instructions and jump table (pre-
viously represented by the term c), but also information on the state of the ram and registers at program start&quot;</div>
<div class='msg reply'><time>2024‑10‑22 11:56</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: here it says that we get registers from program code p and later in the formula 259 we have this `Y(p) -&gt; (c, ω, μ)`</div>
<div class='msg reply'><time>2024‑10‑22 12:19</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: The wording here might be a little confusing as-is. The initial registers are defined as part of the standard program initialization (eq. 265), but they&#x27;re *not* explicitly part of the program blob (eq. 260). The Y in eq. 259 is meant to represent the standard program initialization, but it doesn&#x27;t necessarily mean that the values of the registers are directly extracted from **p**.</div>
<div class='msg reply'><time>2024‑10‑22 12:46</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: Thank you, this explanation makes sense, also formula 266 shows `a` as separate from `p`. I guess formula 259 should be something like this then`Y(p, a) -&gt; (c, ω, μ)?`</div>
<div class='msg reply'><time>2024‑10‑22 13:19</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: one more thing, formula 265 describes what are the initial registers, but I can&#x27;t find defined anywhere how to convert `a` which is a series of octets with at most Z_I elements to registers [N_R]_13</div>
<div class='msg reply'><time>2024‑10‑22 13:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It is |a|, the number of items in a, which should easily fit in register index 8. </div>
<div class='msg reply'><time>2024‑10‑22 14:35</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: I think I understand now, so when we refer to data arguments here it means a slice of bytes that can later be decoded when executing the program. I thought there would be a way to pass arguments as register values directly when invoking the PVM</div>
<div class='msg'><time>2024‑10‑22 12:00</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>:  * here it says that we get registers from program code p and later in the formula 259 we have this `Y(p) -&gt; (c, ω, μ)?`</div>
<div class='msg'><time>2024‑10‑22 12:47</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>:  * Thank you, this explanation makes sense, also formula 266 shows `a` as separate from `p`. I guess formula 259 should be something like this then `Y(p, a) -&gt; (c, ω, μ)?`</div>
<div class='msg'><time>2024‑10‑22 13:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It is |a|, the number of items in a which should easily fit in a register. </div>
<div class='msg'><time>2024‑10‑22 13:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * It is |a|, the number of items in a, which should easily fit in a register. </div>
<div class='msg'><time>2024‑10‑22 13:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * It is |a|, the number of items in a, which should easily fit in register index 8. </div>
<div class='msg'><time>2024‑10‑22 13:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Improved in https://github.com/gavofyork/graypaper/pull/114</div>
<div class='msg'><time>2024‑10‑22 14:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: No, not in this “standard argument passing” invocation</div>
<div class='msg'><time>2024‑10‑22 14:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Obviously you can use the PVM directly. </div>
<div class='msg'><time>2024‑10‑22 15:13</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: In state merklization of validator statistic (pi) (https://graypaper.fluffylabs.dev/#/439ca37/345702345802), I don&#x27;t understand why we are using E_4 for serialization</div>
<div class='msg'><time>2024‑10‑22 16:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It is perhaps not super clear, but it&#x27;s intended to serialize all of the inner elements as E_4</div>
<div class='msg'><time>2024‑10‑22 19:35</time>&ensp;<span class='u' style='color:#3c8ec8'>bmaas</span>: Are we guaranteed to have deterministic ordering here: https://graypaper.fluffylabs.dev/#/293bf5a/346502346f02 ? I could not find any mention of how to handle (small) sets when encoding—whether to sort them or not. When I read about Theta as defined here:  https://graypaper.fluffylabs.dev/#/c71229b/154402154e02, where `{H}` is a set of work-package hashes, it raises a question. Should this set containing work-package hashes be ordered before encoding?</div>
<div class='msg'><time>2024‑10‑23 09:07</time>&ensp;<span class='u' style='color:#4068cd'>0xjunha</span>: https://graypaper.fluffylabs.dev/#/439ca37/121503121503
Is this supposed to be `ρ[c]_w`?</div>
<div class='msg'><time>2024‑10‑23 09:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@bmaas:matrix.org&gt; Are we guaranteed to have deterministic ordering here: https://graypaper.fluffylabs.dev/#/293bf5a/346502346f02 ? I could not find any mention of how to handle (small) sets when encoding—whether to sort them or not. When I read about Theta as defined here:  https://graypaper.fluffylabs.dev/#/c71229b/154402154e02, where `{H}` is a set of work-package hashes, it raises a question. Should this set containing work-package hashes be ordered before encoding?

GP should state that sets of encodable items should be encoded in order. </div>
<div class='msg'><time>2024‑10‑23 09:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Similar to dictionary encoding, but without the value part. </div>
<div class='msg'><time>2024‑10‑23 09:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@0xjunha:matrix.org&gt; https://graypaper.fluffylabs.dev/#/439ca37/121503121503
&gt; Is this supposed to be `ρ[c]_w`?

Yes. Will be fixed in next release. </div>
<div class='msg'><time>2024‑10‑24 07:39</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: https://graypaper.fluffylabs.dev/#/439ca37/348a02349202 about here</div>
<div class='msg'><time>2024‑10‑24 07:40</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: i guess a_l is actually cardinality of a_l </div>
<div class='msg'><time>2024‑10‑24 07:40</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: and couldnt really find a_i</div>
<div class='msg reply'><time>2024‑10‑24 08:04</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: see Eq 95 for a_i</div>
<div class='msg reply'><time>2024‑10‑24 08:05</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: thanks mate</div>
<div class='msg reply'><time>2024‑10‑24 08:06</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: it&#x27;s not the first time i ask about this derived terms. my memory is not working properly :)</div>
<div class='msg'><time>2024‑10‑24 08:04</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>:  * see Eq 95 for a\_i and a_l</div>
<div class='msg'><time>2024‑10‑24 13:02</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: Hello gav 
I think there is a mistake in Equation 183
`E(WQ, W∗ ...n) if i = 0`


the second argument is of the type ⟦W⟧ (list of work reports)

but the second argument that function E expects is D⟨H → H⟩ (Equation 164)





</div>
<div class='msg'><time>2024‑10‑24 13:02</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>:  * Hello gav
I think there is a mistake in Equation 183
`E(WQ, W∗ ...n) if i = 0`

the second argument is of the type `⟦W⟧` (list of work reports)

but the second argument that function `E` expects is `D⟨H → H⟩` (Equation 164)</div>
<div class='msg'><time>2024‑10‑24 13:03</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: &gt; &lt;@luke_fishman:matrix.org&gt; Hello gav
&gt; I think there is a mistake in Equation 183
&gt; `E(WQ, W∗ ...n) if i = 0`
&gt; 
&gt; the second argument is of the type `⟦W⟧` (list of work reports)
&gt; 
&gt; but the second argument that function `E` expects is `D⟨H → H⟩` (Equation 164)

There is a PR open to fix this: https://github.com/gavofyork/graypaper/pull/112</div>
<div class='msg'><time>2024‑10‑24 13:04</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: i see. Thank you</div>
<div class='msg'><time>2024‑10‑24 21:13</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: In formula 268, psi_i definition:

https://graypaper.fluffylabs.dev/#/439ca37/29f80229fc02

↦ r where (g, r, ∅) = ΨM (pc, 0, GI , E(p, c), F, ∅)

What is pc? I believe there is a typo in the correct field, since work packages do not have a field &#x27;c&#x27;</div>
<div class='msg'><time>2024‑10‑24 21:14</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>:  * In formula 268, psi\_i definition:

https://graypaper.fluffylabs.dev/#/439ca37/29f80229fc02

↦ r where (g, r, ∅) = ΨM (pc, 0, GI , E(p, c), F, ∅)

What is pc? I believe there is a typo in the argument, since work packages do not have a field &#x27;c&#x27;</div>
<div class='msg'><time>2024‑10‑24 21:25</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: I believe a correction is needed in GP in the State Transition Dependency Graph section for gamma and kappa.

Suggested change: Remove `ψ&#x27;` from GP-0.4.3-eq:21 and adding `ψ&#x27;` to GP-0.4.3-eq:19.
Likely an unchanged bit from an earlier version of GP.

Details here: https://github.com/gavofyork/graypaper/pull/118</div>
<div class='msg'><time>2024‑10‑24 21:38</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>:  * I believe a correction is needed in GP in the State Transition Dependency Graph section for gamma and kappa.

Suggested change: Remove `ψ&#x27;` from GP-0.4.3-eq:21 and add `ψ&#x27;` to GP-0.4.3-eq:19.
Likely an unchanged bit from an earlier version of GP.

Details here: https://github.com/gavofyork/graypaper/pull/118</div>
<div class='msg'><time>2024‑10‑25 09:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; In formula 268, psi\_i definition:
&gt; 
&gt; https://graypaper.fluffylabs.dev/#/439ca37/29f80229fc02
&gt; 
&gt; ↦ r where (g, r, ∅) = ΨM (pc, 0, GI , E(p, c), F, ∅)
&gt; 
&gt; What is pc? I believe there is a typo in the argument, since work packages do not have a field &#x27;c&#x27;

Bold c is defined as the preimage of regular c. </div>
<div class='msg'><time>2024‑10‑25 09:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It’s a derived term. </div>
<div class='msg'><time>2024‑10‑25 12:16</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: The state keys as currently defined in the State Merklization section can collide for different bits of state. e.g. The keys for general service storage and for service preimages are calculated identically? It seems like a_l keys can be made to collide with almost anything as both h and l are completely controllable by the code calling solicit.</div>
<div class='msg'><time>2024‑10‑25 14:42</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Where do I get the value of GI from in psi_I? Is it a constant? Or how should I calculate it? 
https://graypaper.fluffylabs.dev/#/439ca37/29f80229fd02</div>
<div class='msg'><time>2024‑10‑25 15:19</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: What does [WHAT, ω8, . . . ] mean here? What do I put on ...? I assume to pass through ω2, ω3, ... ?</div>
<div class='msg'><time>2024‑10‑25 15:20</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>:  * What does \[WHAT, ω8, . . . \] mean here? What do I put on ...? I assume to pass through ω2, ω3, ... ? 
https://graypaper.fluffylabs.dev/#/439ca37/2a60002a6000</div>
<div class='msg'><time>2024‑10‑25 16:10</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: &gt; &lt;@danicuki:matrix.org&gt; What does \[WHAT, ω8, . . . \] mean here? What do I put on ...? I assume to pass through ω2, ω3, ... ? 
&gt; https://graypaper.fluffylabs.dev/#/439ca37/2a60002a6000

That&#x27;s how I understand it as well. You assign ω0=WHAT, ω1 = ω8, and the rest stays the same. The same notation is used later as parameters pass-through (e.g. Omega_G).</div>
<div class='msg'><time>2024‑10‑25 16:33</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: If you all have a precise idea of what a &quot;null authorizer&quot; should be in our JAM implementations [disconnected from the CoreTime system chain], like down to pvm assembly code included in genesis state, kindly share --I think we can converge on something very quickly?</div>
<div class='msg'><time>2024‑10‑26 11:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dave:parity.io&gt; The state keys as currently defined in the State Merklization section can collide for different bits of state. e.g. The keys for general service storage and for service preimages are calculated identically? It seems like a_l keys can be made to collide with almost anything as both h and l are completely controllable by the code calling solicit.

[h is the hash of the preimage; l is the preimage&#x27;s length](https://github.com/gavofyork/graypaper/pull/119)</div>
<div class='msg'><time>2024‑10‑26 11:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dave:parity.io&gt; The state keys as currently defined in the State Merklization section can collide for different bits of state. e.g. The keys for general service storage and for service preimages are calculated identically? It seems like a_l keys can be made to collide with almost anything as both h and l are completely controllable by the code calling solicit.

 * [Should be fixed by this](https://github.com/gavofyork/graypaper/pull/119)</div>
<div class='msg'><time>2024‑10‑26 11:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; Where do I get the value of GI from in psi_I? Is it a constant? Or how should I calculate it? 
&gt; https://graypaper.fluffylabs.dev/#/439ca37/29f80229fd02

I&#x27;ll put some values in.</div>
<div class='msg'><time>2024‑10‑26 11:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * I&#x27;ll put some values in: https://github.com/gavofyork/graypaper/pull/120/commits/edafbd0a6d618cd1949e665e6a7fbc6187201c4b</div>
<div class='msg'><time>2024‑10‑26 11:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (They&#x27;re not going to be especially meaningful yet as we don&#x27;t have a sensible gas model yet)</div>
<div class='msg'><time>2024‑10‑26 11:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; What does \[WHAT, ω8, . . . \] mean here? What do I put on ...? I assume to pass through ω2, ω3, ... ? 
&gt; https://graypaper.fluffylabs.dev/#/439ca37/2a60002a6000

PVM Invocations: Correct fallback condition</div>
<div class='msg'><time>2024‑10‑26 11:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * [PVM Invocations: Correct fallback condition](https://github.com/gavofyork/graypaper/pull/120/commits/a4d857586f3253712edc73a09827075e05604f69)</div>
<div class='msg'><time>2024‑10‑26 11:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Note that it is omega_7 which gets set to the error code `WHAT`. omega otherwise remains the same.</div>
<div class='msg'><time>2024‑10‑26 18:26</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: I did not understand yet how do we have access to d and s (bold) in these formulas:

X(w ∈ I) ≡ [d ∣ (H(d),∣d∣) −&lt; wx]
S(w ∈ I) ≡ [s[n] ∣ M(s) = L(r),(r,n) &lt;− wi]
J ( w ∈ I ) ≡ [ ↕ J ( s , n ) ∣ M ( s ) = L ( r ) , ( r , n ) &lt;− w i ]

https://graypaper.fluffylabs.dev/#/439ca37/1a98011ad401

Anyone has a clue?</div>
<div class='msg'><time>2024‑10‑26 18:27</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: </div>
<div class='msg'><time>2024‑10‑26 20:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; I did not understand yet how do we have access to d and s (bold) in these formulas:
&gt; 
&gt; X(w ∈ I) ≡ [d ∣ (H(d),∣d∣) −&lt; wx]
&gt; S(w ∈ I) ≡ [s[n] ∣ M(s) = L(r),(r,n) &lt;− wi]
&gt; J ( w ∈ I ) ≡ [ ↕ J ( s , n ) ∣ M ( s ) = L ( r ) , ( r , n ) &lt;− w i ]
&gt; 
&gt; https://graypaper.fluffylabs.dev/#/439ca37/1a98011ad401
&gt; 
&gt; Anyone has a clue?

Extrinsics are expected to be passed alongside the work package by the block builder.</div>
<div class='msg'><time>2024‑10‑26 20:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Extrinsic preimages are expected to be passed alongside the work package by the block builder.</div>
<div class='msg'><time>2024‑10‑26 20:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Import segments are expected to be retrieved by the guarantor through erasure-code reconstruction from pieces from the validators collected on the network.</div>
<div class='msg'><time>2024‑10‑26 20:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Import segments are expected to be retrieved by the guarantor through erasure-code reconstruction from pieces from the validators collected via the network.</div>
<div class='msg'><time>2024‑10‑27 08:31</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: https://graypaper.fluffylabs.dev/#/439ca37/2cf9012cfc01 It seems to me that the extra hashing here is redundant, unless the keys in preimage dictionary are double-hashed (which I didn&#x27;t find info about in section 9)</div>
<div class='msg'><time>2024‑10‑27 12:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Certainly if https://github.com/gavofyork/graypaper/pull/119 goes in it would be</div>
<div class='msg'><time>2024‑10‑27 12:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: But yeah, it&#x27;s a provision from an older revision where it was desirable to ensure that equivalent keys in different services wouldn&#x27;t result in similar trie paths.</div>
<div class='msg'><time>2024‑10‑27 12:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It&#x27;s less important with the current trie as there&#x27;s already a provision to split it based on service ID. It&#x27;s still probably more optimal to hash with the service ID in order to uniformally distribute tree paths.</div>
<div class='msg'><time>2024‑10‑27 12:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * It&#x27;s less important with the current trie as there&#x27;s already a provision to split it based on service ID. It&#x27;s still more optimal to hash in order to uniformally distribute tree paths, and generally more secure to hash with the service ID.</div>
<div class='msg'><time>2024‑10‑27 12:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * It&#x27;s less important with the current trie as there&#x27;s already a provision to split it based on service ID. It&#x27;s still more optimal to hash in order to uniformally distribute tree paths, and generally more secure to &quot;salt&quot; the hash with the service ID.</div>
<div class='msg'><time>2024‑10‑27 12:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: https://github.com/gavofyork/graypaper/pull/121</div>
<div class='msg'><time>2024‑10‑27 12:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * https://github.com/gavofyork/graypaper/pull/121 is probably the alteration which will make it through.</div>
<div class='msg'><time>2024‑10‑28 16:43</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: Something i might be missing. https://graypaper.fluffylabs.dev/#/439ca37/2bb6002bb800 here preimage code ( i guess) is provided to the argument invocation.

d[s]_bold_c)</div>
<div class='msg reply'><time>2024‑10‑29 06:55</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: again my memory failed me... for those landing here</div>
<div class='msg reply'><time>2024‑10‑29 06:56</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: section 9.1 basically is the answer to this above</div>
<div class='msg'><time>2024‑10‑28 16:43</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * Something i might be missing. https://graypaper.fluffylabs.dev/#/439ca37/2bb6002bb800 here preimage code ( i guess) is provided to the argument invocation. (d\[s\]\_bold\_c)</div>
<div class='msg'><time>2024‑10‑28 16:43</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * Something i might be missing. https://graypaper.fluffylabs.dev/#/439ca37/2bb6002bb800 here preimage code ( i guess) is provided to the argument invocation. (d\[s\]\_bold\_c)sdfsdf</div>
<div class='msg'><time>2024‑10‑28 16:47</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * Something i might be missing. https://graypaper.fluffylabs.dev/#/439ca37/2bb6002bb800 here preimage code ( i guess) is provided to the argument invocation. (d\[s\]\_bold\_c)

but the preimage section does not seem to mention any mechanism of storing/fetching preimage for the service. I marked my code with a TODO and now i am fixing all the leftovers.

omega_n (new service host call) does not seem to have access of such preimage but rather codehash is being directly provided in memory.... so I&#x27;m a bit lost of where the preimage is being handled</div>
<div class='msg'><time>2024‑10‑28 17:09</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: https://graypaper.fluffylabs.dev/#/439ca37/2e70002e7100 Should this `d` that&#x27;s being subscripted here be just `\mi`? I&#x27;m having a hard time to figure out where is the data necessary to build that dictionary coming from. In other context `d` is just a dictionary indexed by service id afaict.</div>
<div class='msg reply'><time>2024‑10‑28 20:18</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: it&#x27;s basically delta</div>
<div class='msg'><time>2024‑10‑28 20:18</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: </div>
<div class='msg'><time>2024‑10‑28 23:15</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@tomusdrw:matrix.org&gt; https://graypaper.fluffylabs.dev/#/439ca37/2e70002e7100 Should this `d` that&#x27;s being subscripted here be just `\mi`? I&#x27;m having a hard time to figure out where is the data necessary to build that dictionary coming from. In other context `d` is just a dictionary indexed by service id afaict.

Yes. Will be corrected in next revision</div>
<div class='msg'><time>2024‑10‑29 19:41</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Is JAMNP intended to socialize individual vs aggregated BLS signatures ie
https://graypaper.fluffylabs.dev/#/439ca37/1e7a001e7a00
If not, what does a validator do with ${\bf F}_v$?  Should these be aggregated into EpochMarkers or into BridgeHub somehow?  </div>
<div class='msg'><time>2024‑10‑30 01:42</time>&ensp;<span class='u' style='color:#7875cf'>charliewinston14</span>: Hello. I asked this in the Jam chat and didn&#x27;t get a response so trying here (if this is not allowed let me know ill delete this post). Question about erasure coding in JAM. I’ve broken the blob into pieces, and then those pieces into the octet pairs. The pairs were then converted to 16 bits. I’m now trying to figure out the field element formula. It looks to be the summation of each bit multiplied by “vj” and this is where I’m not sure what value to use. If j = 7, then vj = α14 +α4 +α. What is α here? </div>
<div class='msg'><time>2024‑10‑30 01:42</time>&ensp;<span class='u' style='color:#7875cf'>charliewinston14</span>: Screen Shot 2024-10-28 at 1.20.33 PM.png</div>
<div class='msg'><time>2024‑10‑30 07:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: [@davxy:matrix.org](https://matrix.to/#/@davxy:matrix.org)^^^</div>
<div class='msg'><time>2024‑10‑30 07:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Version 0.4.4 is out. This includes several corrections but two important protocol alterations. One change to the state merklisation, and one to the way that segment root lookup dictionary validations are done.</div>
<div class='msg'><time>2024‑10‑30 07:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I’ll probably be pushing on with 0.5 mostly now with a number of smaller protocol tweaks. See the milestone in the GP report if you want to know what to expect. </div>
<div class='msg'><time>2024‑10‑30 10:42</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: &gt; &lt;@charliewinston14:matrix.org&gt; Hello. I asked this in the Jam chat and didn&#x27;t get a response so trying here (if this is not allowed let me know ill delete this post). Question about erasure coding in JAM. I’ve broken the blob into pieces, and then those pieces into the octet pairs. The pairs were then converted to 16 bits. I’m now trying to figure out the field element formula. It looks to be the summation of each bit multiplied by “vj” and this is where I’m not sure what value to use. If j = 7, then vj = α14 +α4 +α. What is α here?

 I have written a toy example here: https://github.com/w3f/jamtestvectors/blob/skalman--add-sage-toy-example/erasure_coding/sage/spec.sage#L35 it erasure code m1 = 0x0001 and m2 = 0x0002 if it helps. I think  V_j&#x27;s are elements of the contor basis, you can find them here https://github.com/w3f/jamtestvectors/blob/skalman--add-sage-toy-example/erasure_coding/sage/spec.sage#L26. </div>
<div class='msg reply'><time>2024‑10‑30 12:40</time>&ensp;<span class='u' style='color:#7875cf'>charliewinston14</span>: This is really helpful. Thanks!</div>
<div class='msg'><time>2024‑10‑30 10:50</time>&ensp;<span class='u' style='color:#da6aa2'>syed</span>: From_V function is basically computing the sum you are pointing at but in real life you shouldn&#x27;t do that, you should directly compute the code polynomial from (m_0, m_1,..m_15) vectors without the need to convert to standard field element representation.</div>
<div class='msg'><time>2024‑10‑30 11:48</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Is JAMNP intended to socialize individual vs aggregated BLS signatures ie
&gt; https://graypaper.fluffylabs.dev/#/439ca37/1e7a001e7a00
&gt; If not, what does a validator do with ${\bf F}_v$?  Should these be aggregated into EpochMarkers or into BridgeHub somehow?

Currently, JAMNP does not incorporate any Beefy-related messaging. This gadget will need to be implemented
on top of GRANDPA, which itself is not described by JAMNP yet.

I would tentatively assume that the protocol won’t diverge _significantly_ from the one described by Polkadot.
Of course, there are some differences, such as constructing the MMR with accumulation outputs, and using only BLS instead of BLS or ECDSA for signatures. However, for context, there are numerous introductory
resources on these concepts available.

Regarding the state of the &quot;BEEFY Distribution&quot; section in GP, it currently suggests signing each finalized block B.
I&#x27;m not sure if this will later shift to a &quot;sign every X blocks&quot; approach similar to Polkadot Beefy.

The signatures are for sure BLS signatures, which can be later aggregated for efficient light client verification.
Aggregated signatures will necessitate an aggregated key, and APK proofs might be introduced to verify the validity of these aggregated keys (there is at least a talk and one good tutorial from Syed  online).

Who is in charge of aggregation of BLS keys in JAM? Who is in charge of maintaining the keys commitment eventually required for APK proofs? Maybe a dedicated Beefy service (I&#x27;m just speculating)? In that case this aspect may be outside of the core JAM protocol per se.

These aspects likely warrants further discussion, and it is probably not worth for you (or anyone else) to focus on it right now, given that GRANDPA is not on M1, and potentially not even on M2 either, meaning BEEFY is further down the line (it may be the last component indeed). I believe further details will be provided when the time is appropriate.
</div>
<div class='msg reply'><time>2024‑10‑30 18:26</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Ok thank you for making the known unknowns super clear!

For the Syed talk do you mean this:
 https://www.youtube.com/watch?v=xzC9KJXtidE
For the tutorial can you share the link please?</div>
<div class='msg reply'><time>2024‑10‑30 18:40</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: Yeah. I found [this](https://medium.com/web3foundation/apk-proofs-by-hand-and-sage-3f5feb3fcca4) walkthrough very helpful for understanding some low level aspects underlying APK (aggregated public key) proofs. It may also serve as a beneficial read before diving into the ring-proof primitive we&#x27;re using for Safrole (technical spec draft available [here](https://github.com/davxy/ring-proof-spec)), as they share some similarities. However, unless you’re interested for your own learning, it may not be essential to review this material. Regarding your JAM impl, you might prefer to just use FFI</div>
<div class='msg'><time>2024‑10‑30 11:48</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * Currently, JAMNP does not incorporate any Beefy-related messaging. This gadget will need to be implemented on top of GRANDPA, which itself is not described by JAMNP yet.

I would tentatively assume that the protocol won’t diverge _significantly_ from the one described by Polkadot.
Of course, there are some differences, such as constructing the MMR with accumulation outputs, and using only BLS instead of BLS or ECDSA for signatures. However, for context, there are numerous introductory
resources on these concepts available.

Regarding the state of the &quot;BEEFY Distribution&quot; section in GP, it currently suggests signing each finalized block B.
I&#x27;m not sure if this will later shift to a &quot;sign every X blocks&quot; approach similar to Polkadot Beefy.

The signatures are for sure BLS signatures, which can be later aggregated for efficient light client verification.
Aggregated signatures will necessitate an aggregated key, and APK proofs might be introduced to verify the validity of these aggregated keys (there is at least a talk and one good tutorial from Syed  online).

Who is in charge of aggregation of BLS keys in JAM? Who is in charge of maintaining the keys commitment eventually required for APK proofs? Maybe a dedicated Beefy service (I&#x27;m just speculating)? In that case this aspect may be outside of the core JAM protocol per se.

These aspects likely warrants further discussion, and it is probably not worth for you (or anyone else) to focus on it right now, given that GRANDPA is not on M1, and potentially not even on M2 either, meaning BEEFY is further down the line (it may be the last component indeed). I believe further details will be provided when the time is appropriate.</div>
<div class='msg'><time>2024‑10‑30 11:48</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * Currently, JAMNP does not incorporate any Beefy-related messaging. This gadget will need to be implemented on top of GRANDPA, which itself is not described by JAMNP yet.

I would tentatively assume that the protocol won’t diverge _significantly_ from the one described by Polkadot. Of course, there are some differences, such as constructing the MMR with accumulation outputs, and using only BLS instead of BLS or ECDSA for signatures. However, for context, there are numerous introductory resources on these concepts available.

Regarding the state of the &quot;BEEFY Distribution&quot; section in GP, it currently suggests signing each finalized block B. I&#x27;m not sure if this will later shift to a &quot;sign every X blocks&quot; approach similar to Polkadot Beefy.

The signatures are for sure BLS signatures, which can be later aggregated for efficient light client verification. Aggregated signatures will necessitate an aggregated key, and APK proofs might be introduced to verify the validity of these aggregated keys (there is at least a talk and one good tutorial from Syed  online).

Who is in charge of aggregation of BLS keys in JAM? Who is in charge of maintaining the keys commitment eventually required for APK proofs? Maybe a dedicated Beefy service (I&#x27;m just speculating)? In that case this aspect may be outside of the core JAM protocol per se.

These aspects likely warrants further discussion, and it is probably not worth for you (or anyone else) to focus on it right now, given that GRANDPA is not on M1, and potentially not even on M2 either, meaning BEEFY is further down the line (it may be the last component indeed). I believe further details will be provided when the time is appropriate.</div>
<div class='msg'><time>2024‑10‑30 11:49</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * Currently, JAMNP does not incorporate any Beefy-related messaging. This gadget will need to be implemented on top of GRANDPA, which itself is not described by JAMNP yet.

I would tentatively assume that the protocol won’t diverge _significantly_ from the one described by Polkadot. Of course, there are some differences, such as constructing the MMR with accumulation outputs, and using only BLS instead of BLS or ECDSA for signatures. However, for context, there are numerous introductory resources on these concepts available.

Regarding the state of the &quot;BEEFY Distribution&quot; section in GP, it currently suggests signing each finalized block B. I&#x27;m not sure if this will later shift to a &quot;sign every X blocks&quot; approach similar to Polkadot Beefy.

The signatures are for sure BLS signatures, which can be later aggregated for efficient light client verification. Aggregated signatures will necessitate an aggregated key, and APK proofs might be introduced to verify the validity of these aggregated keys (there is at least a talk and one excellent tutorial from Syed  online).

Who is in charge of aggregation of BLS keys in JAM? Who is in charge of maintaining the keys commitment eventually required for APK proofs? Maybe a dedicated Beefy service (I&#x27;m just speculating)? In that case this aspect may be outside of the core JAM protocol per se.

These aspects likely warrants further discussion, and it is probably not worth for you (or anyone else) to focus on it right now, given that GRANDPA is not on M1, and potentially not even on M2 either, meaning BEEFY is further down the line (it may be the last component indeed). I believe further details will be provided when the time is appropriate.</div>
<div class='msg'><time>2024‑10‑30 11:57</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * Currently, JAMNP does not incorporate any Beefy-related messaging. This gadget will need to be implemented on top of GRANDPA, which itself is not described by JAMNP yet.

I would tentatively assume that the protocol won’t diverge _significantly_ from the one described by Polkadot. Of course, there are some differences, such as constructing the MMR with accumulation outputs, and using only BLS instead of BLS or ECDSA for signatures. However, for context, there are numerous introductory resources on these concepts available.

Regarding the state of the &quot;BEEFY Distribution&quot; section in GP, it currently suggests signing each finalized block B. I&#x27;m not sure if this will later shift to a &quot;sign every X blocks&quot; approach similar to Beefy on Polkadot.

The signatures are for sure BLS signatures, which can be later aggregated for efficient light client verification. Aggregated signatures will necessitate an aggregated key, and APK proofs might be introduced to verify the validity of these aggregated keys (there is at least a talk and one excellent tutorial from Syed  online).

Who is in charge of aggregation of BLS keys in JAM? Who is in charge of maintaining the keys commitment eventually required for APK proofs? Maybe a dedicated Beefy service (I&#x27;m just speculating)? In that case this aspect may be outside of the core JAM protocol per se.

These aspects likely warrants further discussion, and it is probably not worth for you (or anyone else) to focus on it right now, given that GRANDPA is not on M1, and potentially not even on M2 either, meaning BEEFY is further down the line (it may be the last component indeed). I believe further details will be provided when the time is appropriate.</div>
<div class='msg'><time>2024‑10‑30 11:57</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * Currently, JAMNP does not incorporate any Beefy-related messaging. This gadget will need to be implemented on top of GRANDPA, which itself is not described by JAMNP yet.

I would tentatively assume that the protocol won’t diverge _significantly_ from the one described for Polkadot. Of course, there are some differences, such as constructing the MMR with accumulation outputs, and using only BLS instead of BLS or ECDSA for signatures. However, for context, there are numerous introductory resources on these concepts available.

Regarding the state of the &quot;BEEFY Distribution&quot; section in GP, it currently suggests signing each finalized block B. I&#x27;m not sure if this will later shift to a &quot;sign every X blocks&quot; approach similar to Beefy on Polkadot.

The signatures are for sure BLS signatures, which can be later aggregated for efficient light client verification. Aggregated signatures will necessitate an aggregated key, and APK proofs might be introduced to verify the validity of these aggregated keys (there is at least a talk and one excellent tutorial from Syed  online).

Who is in charge of aggregation of BLS keys in JAM? Who is in charge of maintaining the keys commitment eventually required for APK proofs? Maybe a dedicated Beefy service (I&#x27;m just speculating)? In that case this aspect may be outside of the core JAM protocol per se.

These aspects likely warrants further discussion, and it is probably not worth for you (or anyone else) to focus on it right now, given that GRANDPA is not on M1, and potentially not even on M2 either, meaning BEEFY is further down the line (it may be the last component indeed). I believe further details will be provided when the time is appropriate.</div>
<div class='msg'><time>2024‑10‑30 11:58</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * Currently, JAMNP does not incorporate any Beefy-related messaging. This gadget will need to be implemented on top of GRANDPA, which itself is not described by JAMNP yet.
I would tentatively assume that the protocol won’t diverge _significantly_ from the one described for Polkadot. Of course, there are some differences, such as constructing the MMR with accumulation outputs, and using only BLS instead of BLS or ECDSA for signatures. However, for context, there are numerous introductory resources on these concepts available.
Regarding the state of the &quot;BEEFY Distribution&quot; section in GP, it currently suggests signing each finalized block B. I&#x27;m not sure if this will later shift to a &quot;sign every X blocks&quot; approach similar to Beefy on Polkadot.
The signatures are for sure BLS signatures, which can be later aggregated for efficient light client verification. Aggregated signatures will necessitate an aggregated key, and APK proofs might be introduced to verify the validity of these aggregated keys (there is at least a talk and one excellent tutorial from Syed  online).
Who is in charge of aggregation of BLS keys in JAM? Who is in charge of maintaining the keys commitment eventually required for APK proofs? Maybe a dedicated Beefy service (I&#x27;m just speculating)? In that case this aspect may be outside of the core JAM protocol per se.
These aspects likely warrants further discussion, and it is probably not worth for you (or anyone else) to focus on it right now, given that GRANDPA is not on M1, and potentially not even on M2 either, meaning BEEFY is further down the line (it may be the last component indeed). I believe further details will be provided when the time is appropriate.</div>
<div class='msg'><time>2024‑10‑30 12:13</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Is JAMNP intended to socialize individual vs aggregated BLS signatures ie
&gt; https://graypaper.fluffylabs.dev/#/439ca37/1e7a001e7a00
&gt; If not, what does a validator do with ${\bf F}_v$?  Should these be aggregated into EpochMarkers or into BridgeHub somehow?  

* Currently, JAMNP does not incorporate any Beefy-related messaging. This gadget will need to be implemented on top of GRANDPA, which itself is not described by JAMNP yet.
I would tentatively assume that the protocol won’t diverge _significantly_ from the one described for Polkadot. Of course, there are some differences, such as constructing the MMR with accumulation outputs, and using only BLS instead of BLS or ECDSA for signatures. However, for context, there are numerous introductory resources on these concepts available.
Regarding the state of the &quot;BEEFY Distribution&quot; section in GP, it currently suggests signing each finalized block B. I&#x27;m not sure if this will later shift to a &quot;sign every X blocks&quot; approach similar to Beefy on Polkadot.
The signatures are for sure BLS signatures, which can be later aggregated for efficient light client verification. Aggregated signatures will necessitate an aggregated key, and APK proofs might be introduced to verify the validity of these aggregated keys (there is at least a talk and one excellent tutorial from Syed  online).
Who is in charge of aggregation of BLS keys in JAM? Who is in charge of maintaining the keys commitment eventually required for APK proofs? Probably this aspect is outside of the core JAM protocol per se.
These aspects likely warrants further discussion, and it is probably not worth for you (or anyone else) to focus on it right now, given that GRANDPA is not on M1, and potentially not even on M2 either, meaning BEEFY is further down the line (it may be the last component indeed). I believe further details will be provided when the time is appropriate.</div>
<div class='msg'><time>2024‑10‑30 18:41</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>:  * Yeah. I think [this](https://medium.com/web3foundation/apk-proofs-by-hand-and-sage-3f5feb3fcca4) walkthrough is very helpful for understanding some low level aspects underlying APK (aggregated public key) proofs. It may also serve as a beneficial read before diving into the ring-proof primitive we&#x27;re using for Safrole (technical spec draft available [here](https://github.com/davxy/ring-proof-spec)), as they share some similarities. However, unless you’re interested for your own learning, it may not be essential to review this material. Regarding your JAM impl, you might prefer to just use FFI</div>
<div class='msg'><time>2024‑10‑31 10:48</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Below are some basic questions on Ordered Accumulation and Prerequisites.  

*Background*. Lets say we wish to compute $C[n + 1] = A[n] + B[n] + C[n]$ (some kind of recurrence relationship, lets say Fibonacci, Tribonnaci, and Quadranocci in a toy example, all of $A$, $B$, $C$ trying to write their value into service storage of key 0) using the `refine` work results of services $A[n]$, $B[n]$, $C[n]$ coming into `accumulate`.  We would like service $C$ to be able to `read` the results of $A, B, C$ and `write` out $C[n+1]$ to the service storage of $C$ in $C$&#x27;s `accumulate` code.    

Questions:

1. If we have a _single_ work package $p$ with 3 work items from service $A$, $B$, $C$ (with no prerequisites), there is **NO** way to have $C$&#x27;s `write` _guaranteed_ to happen **AFTER** $A$ and $B$. This is because $\Delta_{+}$ will initialize _parallelized_ execution of $\Delta_1$ for all 3 services through $\Delta_*$.  Can you confirm this?

2. If we have _three_ work packages $p_A, p_B, p_C$ with 1 work item each ($p_A$ with `refine` work results from service A, $p_B$ from service $B$, $p_C$ from $C$), we **CAN** have C&#x27;s `write` happen after A and B, by specifying BOTH $p_A$ and $p_B$ as _prerequisite_ work packages of $p_C$.  This SET of TWO prereqs was not possible until GP 0.4.5 supporting a _set_ of prerequisites.  Can you confirm this?

3. If (2) is correct, for the $C[n + 1] = A[n] + B[n] + C[n]$ `write` to happen _at the same time slot_ for some `n`, then another to happen within 2 timeslots for the next `n`, we **REQUIRE** _three_ cores for _three_ work packages, one core for each work package.  In a tiny $V=6,C=2$ test configuration, we CANNOT achieve this, but in a small configuration with $V=9,C=3$, we CAN.  Can you confirm this?

4. Actually, the answer to (3) is more nuanced!   Because we could actually solve this ordered accumulation $C[n + 1] = A[n] + B[n] + C[n]$ with only TWO cores working on TWO packages -- one package $p_{A,B}$ with 2 work items using services $A$ and $B$ and then another package $p_C$ with ONE prerequisite: $p_{A,B}$.  Then with a tiny $V=6,C=2$ test configuration, we CAN achieve the `read` of $C$ based on the `write`s of $A$ and $B$ all in one `accumulate` at the same time slot.  Can you confirm this?

5. With a tiny testnet of $V=6,C=2$, it IS possible test (4) using $\Delta_+$ with $i$ splitting ${\bf w}$ into two pieces that test $\Delta_*$ and the tail recursion of $\Delta_+$.  To observe $N$ calls to $\Delta_+$, you need $N-1$ cores though and need to figure out how to manage $g$ in $N$ splits.  Can you confirm this? 

    [If this is wrong, please advise how we should test $\Delta_+$]

6. Setting aside gas limits for a while (because at present anyway every operation is gas 1 or so, and the accumulation limit is 5-6 orders of magnitude higher) we can have 25 cores working on 25 work packages like this all in one `accumulate` of `Z[n+1]`, with each work package having 2 prerequisites (except for $p_{A,B}$ which have none):

  * $C[n + 1] = A[n] + B[n] + C[n]$ ($p_C$ depending on $p_{A,B}$ using 2 cores)
  * $D[n + 1] = B[n] + C[n+1] + D[n]$       ($p_D$ depending on $p_{A,B}$ and $p_{C}$ using 1 more core for $D$)
  * $E[n + 1] = C[n+1] + D[n+1] + E[n]$     ($p_E$ depending on $p_{C}$ and $p_{D}$ using 1 more core for $E$)
  * $F[n + 1] = D[n+1] + E[n+1] + F[n]$     ($p_F$ depending on $p_{D}$ and $p_{E}$ using 1 more core for $F$)
  * ... and so on until ...
  * $Z[n + 1] = X[n+1] + Y[n+1] + Z[n]$     ($p_Z$ depending on $p_{X}$ and $p_{Y}$ using 1 more core for $Z$)

  Assuming all 25 cores can complete their 25 refines and get 25 work reports guaranteed and assured in a medium configuration ($V=120,C=40$), we can have the entire ordered accumulation done in ONE timeslot.  Can you confirm this?

Because there is a lot of formatting that github treats at least somewhat better also putting it here https://github.com/gavofyork/graypaper/issues/129 -- is that better?</div>
<div class='msg'><time>2024‑10‑31 13:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 1. Correct</div>
<div class='msg'><time>2024‑10‑31 13:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 2. No. You’ll only get the same guarantee at in (1)</div>
<div class='msg'><time>2024‑10‑31 13:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: </div>
<div class='msg'><time>2024‑10‑31 13:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: </div>
<div class='msg'><time>2024‑10‑31 13:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * 2. The intention was only get the same guarantee as in (1). However the way the queuing works at present will, I think, allow this. </div>
<div class='msg'><time>2024‑10‑31 13:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * 2. The intention was only give the same guarantee as in (1). However the way the queuing works at present will, I think, allow this. </div>
<div class='msg'><time>2024‑10‑31 13:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: </div>
<div class='msg'><time>2024‑10‑31 13:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: </div>
<div class='msg'><time>2024‑10‑31 13:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * The invariant you can definitely rely on is that work packages will not be accumulated any later than their dependencies.  </div>
<div class='msg'><time>2024‑10‑31 13:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: In reality the order of item accumulation may come down to the service code. </div>
<div class='msg'><time>2024‑10‑31 13:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * In reality the order of item accumulation of any single service may come down to that service’s Accumulate code. </div>
<div class='msg'><time>2024‑10‑31 13:57</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: For dependent WPs with items in different services, you’ll just be guaranteed that the dependency service doesn’t see the dependent service’s changes before it’s own happen.</div>
<div class='msg'><time>2024‑10‑31 13:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Below are some basic questions on Ordered Accumulation and Prerequisites.  
&gt; 
&gt; *Background*. Lets say we wish to compute $C[n + 1] = A[n] + B[n] + C[n]$ (some kind of recurrence relationship, lets say Fibonacci, Tribonnaci, and Quadranocci in a toy example, all of $A$, $B$, $C$ trying to write their value into service storage of key 0) using the `refine` work results of services $A[n]$, $B[n]$, $C[n]$ coming into `accumulate`.  We would like service $C$ to be able to `read` the results of $A, B, C$ and `write` out $C[n+1]$ to the service storage of $C$ in $C$&#x27;s `accumulate` code.    
&gt; 
&gt; Questions:
&gt; 
&gt; 1. If we have a _single_ work package $p$ with 3 work items from service $A$, $B$, $C$ (with no prerequisites), there is **NO** way to have $C$&#x27;s `write` _guaranteed_ to happen **AFTER** $A$ and $B$. This is because $\Delta_{+}$ will initialize _parallelized_ execution of $\Delta_1$ for all 3 services through $\Delta_*$.  Can you confirm this?
&gt; 
&gt; 2. If we have _three_ work packages $p_A, p_B, p_C$ with 1 work item each ($p_A$ with `refine` work results from service A, $p_B$ from service $B$, $p_C$ from $C$), we **CAN** have C&#x27;s `write` happen after A and B, by specifying BOTH $p_A$ and $p_B$ as _prerequisite_ work packages of $p_C$.  This SET of TWO prereqs was not possible until GP 0.4.5 supporting a _set_ of prerequisites.  Can you confirm this?
&gt; 
&gt; 3. If (2) is correct, for the $C[n + 1] = A[n] + B[n] + C[n]$ `write` to happen _at the same time slot_ for some `n`, then another to happen within 2 timeslots for the next `n`, we **REQUIRE** _three_ cores for _three_ work packages, one core for each work package.  In a tiny $V=6,C=2$ test configuration, we CANNOT achieve this, but in a small configuration with $V=9,C=3$, we CAN.  Can you confirm this?
&gt; 
&gt; 4. Actually, the answer to (3) is more nuanced!   Because we could actually solve this ordered accumulation $C[n + 1] = A[n] + B[n] + C[n]$ with only TWO cores working on TWO packages -- one package $p_{A,B}$ with 2 work items using services $A$ and $B$ and then another package $p_C$ with ONE prerequisite: $p_{A,B}$.  Then with a tiny $V=6,C=2$ test configuration, we CAN achieve the `read` of $C$ based on the `write`s of $A$ and $B$ all in one `accumulate` at the same time slot.  Can you confirm this?
&gt; 
&gt; 5. With a tiny testnet of $V=6,C=2$, it IS possible test (4) using $\Delta_+$ with $i$ splitting ${\bf w}$ into two pieces that test $\Delta_*$ and the tail recursion of $\Delta_+$.  To observe $N$ calls to $\Delta_+$, you need $N-1$ cores though and need to figure out how to manage $g$ in $N$ splits.  Can you confirm this? 
&gt; 
&gt;     [If this is wrong, please advise how we should test $\Delta_+$]
&gt; 
&gt; 6. Setting aside gas limits for a while (because at present anyway every operation is gas 1 or so, and the accumulation limit is 5-6 orders of magnitude higher) we can have 25 cores working on 25 work packages like this all in one `accumulate` of `Z[n+1]`, with each work package having 2 prerequisites (except for $p_{A,B}$ which have none):
&gt; 
&gt;   * $C[n + 1] = A[n] + B[n] + C[n]$ ($p_C$ depending on $p_{A,B}$ using 2 cores)
&gt;   * $D[n + 1] = B[n] + C[n+1] + D[n]$       ($p_D$ depending on $p_{A,B}$ and $p_{C}$ using 1 more core for $D$)
&gt;   * $E[n + 1] = C[n+1] + D[n+1] + E[n]$     ($p_E$ depending on $p_{C}$ and $p_{D}$ using 1 more core for $E$)
&gt;   * $F[n + 1] = D[n+1] + E[n+1] + F[n]$     ($p_F$ depending on $p_{D}$ and $p_{E}$ using 1 more core for $F$)
&gt;   * ... and so on until ...
&gt;   * $Z[n + 1] = X[n+1] + Y[n+1] + Z[n]$     ($p_Z$ depending on $p_{X}$ and $p_{Y}$ using 1 more core for $Z$)
&gt; 
&gt;   Assuming all 25 cores can complete their 25 refines and get 25 work reports guaranteed and assured in a medium configuration ($V=120,C=40$), we can have the entire ordered accumulation done in ONE timeslot.  Can you confirm this?
&gt; 
&gt; Because there is a lot of formatting that github treats at least somewhat better also putting it here https://github.com/gavofyork/graypaper/issues/129 -- is that better?

Sounds right, yes. </div>
<div class='msg'><time>2024‑10‑31 13:59</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: ima_b388934.jpeg</div>
<div class='msg'><time>2024‑10‑31 14:00</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: Where can I find function C defined? I don’t see if in section 12 and in the appendix under C it says “see equation ??”</div>
<div class='msg'><time>2024‑10‑31 14:04</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: * Where can I find function C defined? I don’t see it in section 12 and in the appendix under C it says “see equation ??”</div>
<div class='msg'><time>2024‑10‑31 14:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@jaymansfield:matrix.org&gt; Where can I find function C defined? I don’t see it in section 12 and in the appendix under C it says “see equation ??”

Please provide link with GP reader. </div>
<div class='msg'><time>2024‑10‑31 14:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Images are a bit broken in matrix currently. </div>
<div class='msg'><time>2024‑10‑31 14:08</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: &gt; &lt;@gav:polkadot.io&gt; Images are a bit broken in matrix currently. 

https://graypaper.fluffylabs.dev/#/439ca37/0f8a010f9601</div>
<div class='msg'><time>2024‑10‑31 14:11</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: Looking for function C to be able to generate the accumulate root</div>
<div class='msg'><time>2024‑10‑31 14:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: it&#x27;s not a function</div>
<div class='msg'><time>2024‑10‑31 14:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: and as the GP says right about your selection, it&#x27;s defined in section 12.</div>
<div class='msg'><time>2024‑10‑31 14:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (177) specifically.</div>
<div class='msg'><time>2024‑10‑31 14:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * and as the GP says right above your selection, it&#x27;s defined in section 12.</div>
<div class='msg'><time>2024‑10‑31 14:15</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: &gt; &lt;@gav:polkadot.io&gt; and as the GP says right above your selection, it&#x27;s defined in section 12.

Thanks I’ll take a look. Confusing though as there is no mention of C in 177 either. </div>
<div class='msg'><time>2024‑10‑31 14:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@jaymansfield:matrix.org&gt; Thanks I’ll take a look. Confusing though as there is no mention of C in 177 either.

https://graypaper.fluffylabs.dev/#/439ca37/179e02179e02</div>
<div class='msg'><time>2024‑10‑31 14:19</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: Oh thanks got it now! I should have specified which GP version. In v0.4.5 I found it as 182.</div>
<div class='msg'><time>2024‑10‑31 14:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I was just referencing the GP you used in your link.</div>
<div class='msg'><time>2024‑10‑31 14:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * I was just referencing the GP you used in your link, but yeah using numbers are a bad idea :)</div>
<div class='msg'><time>2024‑10‑31 14:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@gav:polkadot.io&gt; Sounds right, yes.

Answered in the issue.</div>
<div class='msg'><time>2024‑10‑31 18:04</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: Hello, I have a few questions about the [solicit](https://graypaper.fluffylabs.dev/#/439ca37/2f20022f2002) host call for the accumulation host functions 
1: This condition: `if h ≠ ∇ ∧ (h, z) /∈ (x_s)l` I assume should be `if h ≠ ∇ ∧ (h, z) /∈ K(x_s)l` since `l` is a dictionary so here we are trying to verify if the key is in the dictionary
2: one line bellow here: `if (x_s)l[(h, z)] = [x, y]` I can&#x27;t figure out where do the *x* and *y* (italic) come from?</div>
<div class='msg'><time>2024‑10‑31 18:05</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>:  * Hello, I have a few questions about the [solicit](https://graypaper.fluffylabs.dev/#/439ca37/2f20022f2002) host call for the accumulation host functions

1: This condition: `if h ≠ ∇ ∧ (h, z) /∈ (x_s)l` I assume should be `if h ≠ ∇ ∧ (h, z) /∈ K(x_s)l` since `l` is a dictionary so here we are trying to verify if the key is in the dictionary

2: one line bellow here: `if (x_s)l[(h, z)] = [x, y]` I can&#x27;t figure out where do the _x_ and _y_ (italic) come from?</div>
<div class='msg'><time>2024‑10‑31 18:10</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>:  * Hello, I have a few questions about the [solicit](https://graypaper.fluffylabs.dev/#/439ca37/2f20022f2002) host call for the accumulation host functions

1: This condition: `if h ≠ ∇ ∧ (h, z) /∈ (x_s)l` I assume should be `if h ≠ ∇ ∧ (h, z) /∈ K(x_s)l` since `l` is a dictionary so here we are trying to verify if the key is in the dictionary

2: one line bellow here: `if (x_s)l[(h, z)] = [x, y]` I can&#x27;t figure out where do the _x_ and _y_ (italic) come from? (edit and *t* as well)</div>
<div class='msg'><time>2024‑10‑31 18:10</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>:  * Hello, I have a few questions about the [solicit](https://graypaper.fluffylabs.dev/#/439ca37/2f20022f2002) host call for the accumulation host functions

1: This condition: `if h ≠ ∇ ∧ (h, z) /∈ (x_s)l` I assume should be `if h ≠ ∇ ∧ (h, z) /∈ K((x_s)l)` since `l` is a dictionary so here we are trying to verify if the key is in the dictionary

2: one line bellow here: `if (x_s)l[(h, z)] = [x, y]` I can&#x27;t figure out where do the _x_ and _y_ (italic) come from? (edit and _t_ as well)</div>
<div class='msg'><time>2024‑10‑31 18:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 1. When it’s unambiguous then I don’t bother writing the extra K() since it clutters and adds no clarity. This is often the case in dictionaries when we care about key inclusion. </div>
<div class='msg'><time>2024‑10‑31 18:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 2. They are free variables filled by the fact that the value has two items. </div>
<div class='msg'><time>2024‑10‑31 18:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * 2. They are free variables defined by the fact that the value in question has two items. </div>
<div class='msg'><time>2024‑10‑31 18:14</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: nevermind about `t` I see in the latest version it&#x27;s changed :)</div>
<div class='msg'><time>2024‑10‑31 18:16</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: So basically `if l = [x, y]` just means we check that there are two items</div>
<div class='msg'><time>2024‑10‑31 18:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes</div>
<div class='msg'><time>2024‑10‑31 21:37</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: https://github.com/gavofyork/graypaper/pull/121#discussion_r1823768372 what&#x27;s the reason to hash the preimage hash when serialize it into the state trie?</div>
<div class='msg'><time>2024‑10‑31 22:29</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: The preimage hash is passed in to eg solicit directly, it&#x27;s trivial to pass in almost-colliding hashes. As the trie key construction function doesn&#x27;t preserve all hash bits, these almost-colliding hashes could actually collide in the trie if they are not hashed beforehand</div>
<div class='msg'><time>2024‑11‑03 11:24</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: In 150 (https://graypaper.fluffylabs.dev/#/364735a/159a00159e00) for every element `q` of `theta`, we are getting keys of `q`, but `theta` has this type: List[List[Tuple[WorkReport, Set[Hash]]]
So elements of `theta` are Lists, and I don&#x27;t understand the use of `K` on lists (It&#x27;s possible that I&#x27;m misunderstanding the formula)</div>
<div class='msg'><time>2024‑11‑03 17:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yeah it should be (w, d) in q. Will be corrected. </div>
<div class='msg'><time>2024‑11‑04 10:47</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: Hello, I would like to confirm if the gas calculation [here](https://graypaper.fluffylabs.dev/#/364735a/2f38012f3b01) is correct, it seems to me that `ω8` contains the memory address for memo</div>
<div class='msg'><time>2024‑11‑04 10:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dvladco:matrix.org&gt; Hello, I would like to confirm if the gas calculation [here](https://graypaper.fluffylabs.dev/#/364735a/2f38012f3b01) is correct, it seems to me that `ω8` contains the memory address for memo

Copy-paste error. g should be 1</div>
<div class='msg'><time>2024‑11‑04 10:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dvladco:matrix.org&gt; Hello, I would like to confirm if the gas calculation [here](https://graypaper.fluffylabs.dev/#/364735a/2f38012f3b01) is correct, it seems to me that `ω8` contains the memory address for memo

* Copy-paste error. g should be 10</div>
<div class='msg'><time>2024‑11‑04 16:43</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: https://graypaper.fluffylabs.dev/#/364735a/0f59020f6e02

In phi, is correct that the size of the inner list is exactly Q? Q is the maximum number of element in the authorizer_queue, so I expect to be `:Q`</div>
<div class='msg'><time>2024‑11‑04 16:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: What is authoriser_queue?</div>
<div class='msg'><time>2024‑11‑04 16:50</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: &gt; &lt;@gav:polkadot.io&gt; What is authoriser_queue?

phi is called authorizer queue in the graypaper</div>
<div class='msg'><time>2024‑11‑04 16:51</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>:  * https://graypaper.fluffylabs.dev/#/364735a/0f59020f6e02

In phi, is correct that the size of the inner list is exactly Q? Q is `the maximum number of items in the authorizations queue`, so I expect to be `:Q`</div>
<div class='msg'><time>2024‑11‑04 16:51</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: &gt; &lt;@gav:polkadot.io&gt; What is authoriser_queue?

 * phi is called authorizer queue in the graypaper

EDIT: I edited my question to match the GP</div>
<div class='msg'><time>2024‑11‑04 16:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Where does the “maximum number of items” come from? (The formalism is correct, it is the exact number not the maximum)</div>
<div class='msg'><time>2024‑11‑04 16:53</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: here: https://graypaper.fluffylabs.dev/#/364735a/3d6c003d6e00</div>
<div class='msg'><time>2024‑11‑04 16:54</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>:  * here (appendix I):  https://graypaper.fluffylabs.dev/#/364735a/3d6c003d6e00</div>
<div class='msg'><time>2024‑11‑04 16:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Ok that should not have “maximum” in there. </div>
<div class='msg'><time>2024‑11‑04 16:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Ok that should not have the word “maximum” in there. </div>
<div class='msg'><time>2024‑11‑04 16:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Will be corrected in the next release. </div>
<div class='msg'><time>2024‑11‑06 13:16</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: gav: is it possible to modify the formula numbering system within the graypaper? Currently, when formulas are added or removed, subsequent formula numbers shift, which can be problematic when referencing formulas from code.

A potential solution to this issue is to implement section-based numbering. For instance, the third formula in Chapter 10 would be labeled as 10.3. This approach would also enhance readability when formula numbers are referenced within the paper itself, as it would immediately indicate the formula&#x27;s location.</div>
<div class='msg'><time>2024‑11‑06 13:36</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@dakkk:matrix.org&gt; gav: is it possible to modify the formula numbering system within the graypaper? Currently, when formulas are added or removed, subsequent formula numbers shift, which can be problematic when referencing formulas from code.
&gt; 
&gt; A potential solution to this issue is to implement section-based numbering. For instance, the third formula in Chapter 10 would be labeled as 10.3. This approach would also enhance readability when formula numbers are referenced within the paper itself, as it would immediately indicate the formula&#x27;s location.

I&#x27;d love this. I do reference formulas in my code as well for future reference. I just recently added graypaper v number next to the formula &quot;Id&quot; but this suggestion is much more robust</div>
<div class='msg'><time>2024‑11‑06 13:38</time>&ensp;<span class='u' style='color:#92c76e'>rick</span>: &gt; &lt;@prematurata:matrix.org&gt; I&#x27;d love this. I do reference formulas in my code as well for future reference. I just recently added graypaper v number next to the formula &quot;Id&quot; but this suggestion is much more robust

Permanent formula ids would be very helpful</div>
<div class='msg'><time>2024‑11‑06 14:52</time>&ensp;<span class='u' style='color:#6ecf94'>qiwei</span>: in `quit` host-call, if halt with a transfer, the service account balance will be below threshold balance, just wondering is the account supposed to be removed from state afterwards? I did not find such logic (maybe i missed it..)</div>
<div class='msg'><time>2024‑11‑06 17:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@qiwei:matrix.org&gt; in `quit` host-call, if halt with a transfer, the service account balance will be below threshold balance, just wondering is the account supposed to be removed from state afterwards? I did not find such logic (maybe i missed it..)

I&#x27;m not sure what you mean. The `quit` hostcall would delete the account in question.</div>
<div class='msg'><time>2024‑11‑07 15:14</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: Hey, is `d` [here](https://graypaper.fluffylabs.dev/#/364735a/2bb1002bb100) from `u` ? I don&#x27;t see it being explicitly defined anywhere </div>
<div class='msg'><time>2024‑11‑07 15:20</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>:  * Hey, is `d` [here](https://graypaper.fluffylabs.dev/#/364735a/2bb1002bb100) taken from `u` ? I don&#x27;t see it being explicitly defined anywhere</div>
<div class='msg'><time>2024‑11‑07 16:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes should be u_d - will be fixed in the next revision</div>
<div class='msg'><time>2024‑11‑07 18:33</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Is it intended that reports can sit around in rho essentially forever? Seems like some shenanigans might be possible if someone in control of a core leaves a report sitting there long enough for auditors to no longer be able to audit it</div>
<div class='msg reply'><time>2024‑11‑07 18:35</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: I think there is timeout: if new report comes in and timeout has passed the old report is flushed and the new report takes place im rho</div>
<div class='msg reply'><time>2024‑11‑07 18:45</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: There is a timeout but the report is only discarded if a new one comes along to replace it. Someone in control of the core could ensure no other report comes along. Might not be abusable but doesn&#x27;t seem impossible to me and would be easy to fix by forcibly clearing reports after a certain amount of time</div>
<div class='msg reply'><time>2024‑11‑07 18:52</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: What does it mean to be &quot;in control of the core&quot; if validators are rotated within an epoch at high frequency?</div>
<div class='msg reply'><time>2024‑11‑07 18:54</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: If you mean the coretime owner, and they aren&#x27;t using their core at a high frequency, that&#x27;s not really a concern, I believe.</div>
<div class='msg reply'><time>2024‑11‑07 20:10</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Yes I mean the coretime owner. I&#x27;m not concerned about the core not getting used, I&#x27;m concerned about an invalid report potentially getting accumulated because noone audits it. The core not getting used would be a cost to execute this attack 😅</div>
<div class='msg reply'><time>2024‑11‑08 11:17</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I don&#x27;t think it matters - the only reason it wouldn&#x27;t go into accumulation is because it&#x27;s not yet available and if happens to stick around for ages before 2/3+1 of validators finally all decide it is available, then there&#x27;s no great harm in initiating the auditing from that point.</div>
<div class='msg reply'><time>2024‑11‑08 11:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Also, it&#x27;s not the coretime owner who can prevent its becoming available: it&#x27;s only the guarantors.</div>
<div class='msg reply'><time>2024‑11‑08 11:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: If two guarantors and the coretime owner coordinated, then they could keep an unavailable WP in rho indefinitely and only choose to make it available at some arbitrary late stage (assuming the coretime owner has indefinite funds). But again, auditing only begins once available is assured.</div>
<div class='msg reply'><time>2024‑11‑08 11:40</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: &gt; &lt;@gav:polkadot.io&gt; If two guarantors and the coretime owner coordinated, then they could keep an unavailable WP in rho indefinitely and only choose to make it available at some arbitrary late stage (assuming the coretime owner has indefinite funds). But again, auditing only begins once available is assured.

Yes this is the case I was imagining. Of course this assumes it is _possible_ to make the WP available at an arbitrary later point. It&#x27;s not obvious to me that this wouldn&#x27;t be possible. If you wait long enough to do this then auditors will be able to assemble the bundle but may not be able to check the report because they have discarded necessary state. What then?</div>
<div class='msg reply'><time>2024‑11‑08 11:43</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: &gt; &lt;@gav:polkadot.io&gt; I don&#x27;t think it matters - the only reason it wouldn&#x27;t go into accumulation is because it&#x27;s not yet available and if it happens to stick around for ages before 2/3+1 of validators finally all decide it is available, then there&#x27;s no great harm in initiating the auditing from that point.

My point is that I think it _is_ harmful to kick off auditing so late as we don&#x27;t keep eg preimages forever</div>
<div class='msg'><time>2024‑11‑08 10:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: </div>
<div class='msg'><time>2024‑11‑08 11:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * I don&#x27;t think it matters - the only reason it wouldn&#x27;t go into accumulation is because it&#x27;s not yet available and if it happens to stick around for ages before 2/3+1 of validators finally all decide it is available, then there&#x27;s no great harm in initiating the auditing from that point.</div>
<div class='msg'><time>2024‑11‑08 11:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Also, it&#x27;s not the coretime owner who can prevent its becoming available: it&#x27;s only the guarantors, and they do a switcheroo every 10 blocks.</div>
<div class='msg'><time>2024‑11‑08 11:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: What state might they have discarded?</div>
<div class='msg'><time>2024‑11‑08 11:44</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: &gt; &lt;@gav:polkadot.io&gt; What state might they have discarded?

Forgotten preimages for example</div>
<div class='msg'><time>2024‑11‑08 11:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I think the tolerances are pretty high on that, but it’s a lot easier to reason about correctness if it’s prevented outright. We can disable availability for WRs which should have timed out.  </div>
<div class='msg'><time>2024‑11‑08 11:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * I think the tolerances are pretty high on that, but it’s a lot easier to reason about correctness if it’s prevented outright. We can disable availability for WRs which should have timed out. This should avert any possibility of misuse. </div>
<div class='msg'><time>2024‑11‑08 11:50</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: &gt; &lt;@dakkk:matrix.org&gt; gav: is it possible to modify the formula numbering system within the graypaper? Currently, when formulas are added or removed, subsequent formula numbers shift, which can be problematic when referencing formulas from code.
&gt; 
&gt; A potential solution to this issue is to implement section-based numbering. For instance, the third formula in Chapter 10 would be labeled as 10.3. This approach would also enhance readability when formula numbers are referenced within the paper itself, as it would immediately indicate the formula&#x27;s location.

If anyone is interested in using this type of numbering in their project, it is sufficient to put this line at the beginning of graypaper.tex:

```\numberwithin{equation}{section}```</div>
<div class='msg'><time>2024‑11‑10 19:38</time>&ensp;<span class='u' style='color:#bc4a3e'>basedafdev</span>: Screenshot 2024-11-10 at 2.38.09 PM.png</div>
<div class='msg'><time>2024‑11‑10 19:38</time>&ensp;<span class='u' style='color:#bc4a3e'>basedafdev</span>: in the latest GP, the state-key constructor for (service, hash) in the second term exceeds 32 bytes. E_4(l) ~ H(h) = 36 bytes. Unless i&#x27;m missing something here</div>
<div class='msg'><time>2024‑11‑11 06:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: You’re not: there’s already a correction for it in my open PR: https://github.com/gavofyork/graypaper/commit/896430a35c6247175d0fdf41d2e791bacd2686e7</div>
<div class='msg'><time>2024‑11‑14 03:58</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: Shouldn&#x27;t this `G` function in the definition of the `Accumulate` invocation take the status from the host call as well in the first argument?

https://graypaper.fluffylabs.dev/#/c71229b/2b6f022b6f02

Definition of the host call: https://graypaper.fluffylabs.dev/#/364735a/28a80228a802</div>
<div class='msg'><time>2024‑11‑14 10:03</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: davxy: in your safrole test vectors, is it possible to know the validators&#x27; secret keys? </div>
<div class='msg'><time>2024‑11‑14 10:35</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: dakkk | JamPy: `i`-th key is geneted as follows:
1. interpret `i` as a 32 bit unsigned integer. 
2. Encode it in LE. 
3. Repeat the encoded value 8 times (you get a 32 bytes `data`)

- Ed25519 secret: is `data` 
- Bandersnatch secret: use `data` to call `Secret::from_seed` in ark-ec-vrfs</div>
<div class='msg'><time>2024‑11‑14 10:35</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: This is a trivial key generation used by the tests</div>
<div class='msg'><time>2024‑11‑14 10:47</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: &gt; &lt;@davxy:matrix.org&gt; dakkk | JamPy: `i`-th key is geneted as follows:
&gt; 1. interpret `i` as a 32 bit unsigned integer. 
&gt; 2. Encode it in LE. 
&gt; 3. Repeat the encoded value 8 times (you get a 32 bytes `data`)
&gt; 
&gt; - Ed25519 secret: is `data` 
&gt; - Bandersnatch secret: use `data` to call `Secret::from_seed` in ark-ec-vrfs

thank you (y) </div>
<div class='msg'><time>2024‑11‑14 11:33</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@davxy:matrix.org&gt; dakkk | JamPy: `i`-th key is geneted as follows:
&gt; 1. interpret `i` as a 32 bit unsigned integer. 
&gt; 2. Encode it in LE. 
&gt; 3. Repeat the encoded value 8 times (you get a 32 bytes `data`)
&gt; 
&gt; - Ed25519 secret: is `data` 
&gt; - Bandersnatch secret: use `data` to call `Secret::from_seed` in ark-ec-vrfs

not sure who&#x27;s behind jamcha.in but I&#x27;d suggest we all use this to generate keys</div>
<div class='msg'><time>2024‑11‑14 12:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@cisco:parity.io&gt; Shouldn&#x27;t this `G` function in the definition of the `Accumulate` invocation take the status from the host call as well in the first argument?
&gt; 
&gt; https://graypaper.fluffylabs.dev/#/c71229b/2b6f022b6f02
&gt; 
&gt; Definition of the host call: https://graypaper.fluffylabs.dev/#/364735a/28a80228a802

Yes the triangle sign is in fact missing from a few places. Will be corrected in next release.</div>
<div class='msg'><time>2024‑11‑14 12:17</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: &gt; &lt;@davxy:matrix.org&gt; dakkk | JamPy: `i`-th key is geneted as follows:
&gt; 1. interpret `i` as a 32 bit unsigned integer. 
&gt; 2. Encode it in LE. 
&gt; 3. Repeat the encoded value 8 times (you get a 32 bytes `data`)
&gt; 
&gt; - Ed25519 secret: is `data` 
&gt; - Bandersnatch secret: use `data` to call `Secret::from_seed` in ark-ec-vrfs

Thank you for this! Needed it as well.</div>
<div class='msg'><time>2024‑11‑14 13:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@gav:polkadot.io&gt; Yes the triangle sign is in fact missing from a few places. Will be corrected in next release.

https://github.com/gavofyork/graypaper/pull/141</div>
<div class='msg'><time>2024‑11‑14 14:29</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: Here, R looks like a function but it is multiplying with the inner term (t&#x27;/R -1)

https://graypaper.fluffylabs.dev/#/364735a/14f40214ff02</div>
<div class='msg'><time>2024‑11‑14 15:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: R is a constant; it&#x27;s a simple product.</div>
<div class='msg'><time>2024‑11‑14 15:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: https://graypaper.fluffylabs.dev/#/c71229b/3d6b003d6d00</div>
<div class='msg'><time>2024‑11‑14 15:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * This (san-serif) R is a constant; it&#x27;s a simple product.</div>
<div class='msg'><time>2024‑11‑14 20:51</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: The prerequisites of a work report are already a set, so shouldn&#x27;t [the D function](https://graypaper.fluffylabs.dev/#/364735a/16c70016c900) just do w_x_p U ...?</div>
<div class='msg'><time>2024‑11‑14 21:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@cisco:parity.io&gt; The prerequisites of a work report are already a set, so shouldn&#x27;t [the D function](https://graypaper.fluffylabs.dev/#/364735a/16c70016c900) just do w_x_p U ...?

Yes. Will be fixed in next release</div>
<div class='msg'><time>2024‑11‑14 21:27</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: I have a question about acc history. According to https://graypaper.fluffylabs.dev/#/364735a/162000162800 , its a `E long sequence of Hash sets` 

When merkleizing https://graypaper.fluffylabs.dev/#/364735a/34fa0234fc02 we&#x27;re asked to serialize it but C.1.7 https://graypaper.fluffylabs.dev/#/364735a/33d70033d700 defines set serialization which if intended to be used for ξ encoding, then it means we won&#x27;t be able to decode it (due to not containing length discriminator). Right now we don&#x27;t really need to decode it but not sure this is intended</div>
<div class='msg'><time>2024‑11‑15 08:44</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: &gt; &lt;@prematurata:matrix.org&gt; I have a question about acc history. According to https://graypaper.fluffylabs.dev/#/364735a/162000162800 , its a `E long sequence of Hash sets` 
&gt; 
&gt; When merkleizing https://graypaper.fluffylabs.dev/#/364735a/34fa0234fc02 we&#x27;re asked to serialize it but C.1.7 https://graypaper.fluffylabs.dev/#/364735a/33d70033d700 defines set serialization which if intended to be used for ξ encoding, then it means we won&#x27;t be able to decode it (due to not containing length discriminator). Right now we don&#x27;t really need to decode it but not sure this is intended

Your assumptions seems correct, but the state merklization is not intendeed to be &quot;reversible&quot;</div>
<div class='msg'><time>2024‑11‑15 08:46</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>:  * Your assumptions seems correct, but the state serialization is not intendeed to be &quot;reversible&quot;</div>
<div class='msg'><time>2024‑11‑15 08:47</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@dakkk:matrix.org&gt; Your assumptions seems correct, but the state serialization is not intendeed to be &quot;reversible&quot;

I agree with you but, according to my (bad) memory this is the only case when we serialize something but we are unable to deserialize it... I wonder if we really want to introduce a first here</div>
<div class='msg'><time>2024‑11‑15 08:49</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: &gt; &lt;@prematurata:matrix.org&gt; I agree with you but, according to my (bad) memory this is the only case when we serialize something but we are unable to deserialize it... I wonder if we really want to introduce a first here

it&#x27;s not the first case; check preimage metadata serialization key: we are hashing an hash, that&#x27;s not reversible</div>
<div class='msg'><time>2024‑11‑15 08:51</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: &gt; &lt;@dakkk:matrix.org&gt; it&#x27;s not the first case; check preimage metadata serialization key: we are hashing an hash, that&#x27;s not reversible

I knew my bad memory failed me again =) tkz</div>
<div class='msg'><time>2024‑11‑15 08:54</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: &gt; &lt;@prematurata:matrix.org&gt; I knew my bad memory failed me again =) tkz

No problem; btw it would be an interesting feature to have a deserializable encoding of the state, so for instance we can use it for storing on disk. But as mentioned earlier it is not the main purpose of this</div>
<div class='msg'><time>2024‑11‑15 09:48</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: we don’t really need the ability to decide state key for node usage. so it  is mostly useful as a dev / debug / indexing needs. the simple solution is just save the preimage in a aux store next to the state store</div>
<div class='msg'><time>2024‑11‑15 09:59</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: We need to be able to decode state values for warp sync so this does seem like an oversight. In any case if there is an ambiguous encoding that results in two different states having the same state root this is at the least not ideal...</div>
<div class='msg'><time>2024‑11‑15 10:02</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: In general it should be possible to execute a block given just the initial state trie without needing a &quot;real&quot; state to deal with ambiguity</div>
<div class='msg'><time>2024‑11‑15 10:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; I have a question about acc history. According to https://graypaper.fluffylabs.dev/#/364735a/162000162800 , its a `E long sequence of Hash sets` 
&gt; 
&gt; When merkleizing https://graypaper.fluffylabs.dev/#/364735a/34fa0234fc02 we&#x27;re asked to serialize it but C.1.7 https://graypaper.fluffylabs.dev/#/364735a/33d70033d700 defines set serialization which if intended to be used for ξ encoding, then it means we won&#x27;t be able to decode it (due to not containing length discriminator). Right now we don&#x27;t really need to decode it but not sure this is intended

this is an oversight. It will be fixed in 0.5.0 (state encoding of curly E will have a length prefixes)</div>
<div class='msg'><time>2024‑11‑15 10:09</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: since 0.5.0 is merged do you think it would be better to have formula numbers follow the subchapters as well? ex...

when reading chapter 12.2, the current 0.5.0 first formula is 12.13. what about (not sure it&#x27;s possible in latex) renaming 12.13 to 12.2.1?</div>
<div class='msg'><time>2024‑11‑15 10:09</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: gav: </div>
<div class='msg'><time>2024‑11‑15 10:09</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>:  * gav</div>
<div class='msg'><time>2024‑11‑15 10:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: No 0.5.0 has been released. </div>
<div class='msg'><time>2024‑11‑15 10:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * No 0.5.0 has been tagged or released. </div>
<div class='msg'><time>2024‑11‑15 10:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I’d avoid paying too much attention to the versions of main branch. </div>
<div class='msg'><time>2024‑11‑15 10:11</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: yeah i should have better explained myself. nevertheless what do you htink about changing the formula numbering a bit further?</div>
<div class='msg'><time>2024‑11‑15 10:12</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: i think it would be beneficial to encode the subsection in the formula numbering as well</div>
<div class='msg'><time>2024‑11‑15 10:25</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: Is there any particular reason why `lower` and `higher` bits of the two U64s are in a different order in registers than in case of `new` and `transfer`? My OCD is killing me:
https://graypaper.fluffylabs.dev/#/364735a/2e0d032e0d03</div>
<div class='msg'><time>2024‑11‑15 11:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; since 0.5.0 is merged do you think it would be better to have formula numbers follow the subchapters as well? ex...
&gt; 
&gt; when reading chapter 12.2, the current 0.5.0 first formula is 12.13. what about (not sure it&#x27;s possible in latex) renaming 12.13 to 12.2.1?

To be honest, the bigger size of formula numbers is already screwing up the layouts. </div>
<div class='msg'><time>2024‑11‑15 11:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I don&#x27;t want to make it any worse that it needs to be.</div>
<div class='msg'><time>2024‑11‑15 11:57</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@tomusdrw:matrix.org&gt; Is there any particular reason why `lower` and `higher` bits of the two U64s are in a different order in registers than in case of `new` and `transfer`? My OCD is killing me:
&gt; https://graypaper.fluffylabs.dev/#/364735a/2e0d032e0d03

It&#x27;s not an issue in 0.5.0</div>
<div class='msg'><time>2024‑11‑15 19:56</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: Might be a dumb question, but shouldn&#x27;t creating a service with code larger than `W_C` be disallowed? AFAIU it will not run yielding `BIG`, but why allow `new` host call to succeed at all? https://graypaper.fluffylabs.dev/#/364735a/2e80022e8002</div>
<div class='msg'><time>2024‑11‑15 19:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It avoids the need for the code to be fetched (and fetchable) at time of service creation. </div>
<div class='msg'><time>2024‑11‑15 20:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It’s not like you can’t put a huge preimage into a service’s storage if you’re willing to pay. </div>
<div class='msg'><time>2024‑11‑15 20:01</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: &gt; &lt;@gav:polkadot.io&gt; It avoids the need for the code to be fetched (and fetchable) at time of service creation.

not sure I get it. If I understand correctly `l` is the code length, and the `new` host call could just end with some error code if `l &gt;= W_C`.</div>
<div class='msg'><time>2024‑11‑15 20:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: yes, there could be a check on `l`</div>
<div class='msg'><time>2024‑11‑15 20:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: But (assuming we keep the check where it’s actually used) then it’s one extra piece of math that’s not really needed</div>
<div class='msg'><time>2024‑11‑15 20:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I guess the check could be moved here though. </div>
<div class='msg'><time>2024‑11‑15 20:03</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: I see. I mean, you could still have some genesis services with code larger than `W_C` if it&#x27;s checked only in `new`.</div>
<div class='msg'><time>2024‑11‑15 20:03</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>:  * I see. Though, you could still have some genesis services with code larger than `W_C` if it&#x27;s checked only in `new`.</div>
<div class='msg'><time>2024‑11‑15 20:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yeah. Though then it’d be the chain publishers fault if it screwed the PVM</div>
<div class='msg'><time>2024‑11‑15 20:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Realistically implementations will likely need to limit the PVM code size so if the protocol theoretically supports unlimited blob sizes if they’re added in genesis it’s a bit problematic</div>
<div class='msg'><time>2024‑11‑15 20:06</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: Well, if it&#x27;s not explicit in GP it could lead to some cross-implementation issues. My curiosity is satisfied though. So up to you where the check should :)</div>
<div class='msg'><time>2024‑11‑15 20:06</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>:  * Well, if it&#x27;s not explicit in GP it could lead to some cross-implementation issues. My curiosity is satisfied though. So up to you where the check should be :)</div>
<div class='msg'><time>2024‑11‑17 11:16</time>&ensp;<span class='u' style='color:#dbc767'>stanleyli</span>: image.png</div>
<div class='msg'><time>2024‑11‑17 11:16</time>&ensp;<span class='u' style='color:#dbc767'>stanleyli</span>: Hello guys, I have a question about the pageproof, according to the definition in the GP, constructing a Merkle Tree appears to follow the diagram provided. In this context, B(1,2) represents the branch of leaf 1 and leaf 2, and its calculation method is described as H($node ⌢ N(v_{...|v|/2}, H) ⌢ N(v_{|v|/2...}, H)).</div>
<div class='msg'><time>2024‑11‑17 11:17</time>&ensp;<span class='u' style='color:#dbc767'>stanleyli</span>:  * Hello guys, I have a question about the pageproof, according to the definition in the GP, constructing a Merkle Tree appears to follow the diagram provided. In this context, B(1,2) represents the branch of leaf 1 and leaf 2, and its calculation method is described as H($node ⌢ N(v\_{...|v|/2}, H) ⌢ N(v\_{|v|/2...}, H)).https://graypaper.fluffylabs.dev/#/364735a/354e0135ac01</div>
<div class='msg'><time>2024‑11‑17 11:18</time>&ensp;<span class='u' style='color:#dbc767'>stanleyli</span>: Meanwhile, when calculating the Trace path, the method outlined in the GP is N(P(v, i), H).https://graypaper.fluffylabs.dev/#/364735a/364500360301</div>
<div class='msg'><time>2024‑11‑17 11:18</time>&ensp;<span class='u' style='color:#dbc767'>stanleyli</span>: This approach itself doesn’t seem problematic, but it leads to a final result formatted as [hash, hash ... hash, blob], where the earlier elements are hashes, but the last becomes a blob (length = G = 4104). This results in a significantly longer output length overall.

Would it make sense to modify the N() function so that it returns H(v) when |v|=1? This way, every node would consistently be a hash, and each element in the trace path would have a uniform length of hash.

Or perhaps I’ve misunderstood something?
</div>
<div class='msg'><time>2024‑11‑17 11:22</time>&ensp;<span class='u' style='color:#dbc767'>stanleyli</span>:  * The methos doesn&#x27;t have any problem, but it leads to a final result formatted as [hash, hash ... hash, blob], where the earlier elements are hashes, but the last becomes a blob (length = G = 4104). This results in a significantly longer output length overall.

Would it make sense to modify the N() function so that it returns H(v) when |v|=1? This way, every node would consistently be a hash, and each element in the trace path would have a uniform length of hash.

Or perhaps I’ve misunderstood something?
</div>
<div class='msg'><time>2024‑11‑18 08:57</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: https://graypaper.fluffylabs.dev/#/364735a/2cfc012cfc01

Here we are fetching 32 bytes preimage hash from memory and then hashing it again, is it right?</div>
<div class='msg'><time>2024‑11‑18 10:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@amritj:matrix.org&gt; https://graypaper.fluffylabs.dev/#/364735a/2cfc012cfc01
&gt; 
&gt; Here we are fetching 32 bytes preimage hash from memory and then hashing it again, is it right?

Correct.</div>
<div class='msg'><time>2024‑11‑18 11:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@stanleyli:matrix.org&gt; The methos doesn&#x27;t have any problem, but it leads to a final result formatted as [hash, hash ... hash, blob], where the earlier elements are hashes, but the last becomes a blob (length = G = 4104). This results in a significantly longer output length overall.
&gt; 
&gt; Would it make sense to modify the N() function so that it returns H(v) when |v|=1? This way, every node would consistently be a hash, and each element in the trace path would have a uniform length of hash.
&gt; 
&gt; Or perhaps I’ve misunderstood something?

The justification function curly-J uses the constancy function _C_, which basically hashes all data items before passing them in to the trace function _T_.</div>
<div class='msg'><time>2024‑11‑18 11:48</time>&ensp;<span class='u' style='color:#dbc767'>stanleyli</span>: Understand! Thanks a lot.</div>
<div class='msg'><time>2024‑11‑19 15:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Graypaper [version 0.5.0](https://github.com/gavofyork/graypaper/releases/tag/v0.5.0) is out. No vectors yet but they should be coming soon. There are several important changes, chiefly to the PVM, which is now 64-bit.</div>
<div class='msg'><time>2024‑11‑20 11:48</time>&ensp;<span class='u' style='color:#6ecf94'>qiwei</span>: In Appendix I, there is a `ZG = 2^14: The standard pvm program initialization page size. See section A.7.`, but A.7 is still using ZP, maybe need to update to use ZG?</div>
<div class='msg'><time>2024‑11‑20 14:38</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: </div>
<div class='msg'><time>2024‑11‑20 15:35</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: Is it correct to deduct that in order to complete Milestone 1 we need to wait 0.6? Or can we deliver an 0.5 implementation?</div>
<div class='msg'><time>2024‑11‑20 15:37</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>:  * Is it correct to deduct that in order to complete Milestone 1 of JAM prize we need to wait version 0.6 of the graypaper? Or can we deliver an 0.5 implementation?</div>
<div class='msg'><time>2024‑11‑20 15:45</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>:  * Is it correct to deduct that in order to complete Milestone 1 of JAM prize we need to wait version 1.0 of the graypaper? Or can we deliver an 0.5 implementation?</div>
<div class='msg'><time>2024‑11‑21 07:19</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Some candidate 32=&gt;64:
* service id might be 64-bit? https://graypaper.fluffylabs.dev/#/911af30/10da0010da00
thus new&#x27;s check/bump would need adjustment https://graypaper.fluffylabs.dev/#/911af30/30e00230e002
https://graypaper.fluffylabs.dev/#/911af30/2da2032da203
* invoke 60 byte is 8+13*8=125 byte with 4 =&gt; 8
https://graypaper.fluffylabs.dev/#/911af30/342a01342a01
https://graypaper.fluffylabs.dev/#/911af30/346101346101
</div>
<div class='msg'><time>2024‑11‑21 09:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Some candidate 32=&gt;64:
&gt; * service id might be 64-bit? https://graypaper.fluffylabs.dev/#/911af30/10da0010da00
&gt; thus new&#x27;s check/bump would need adjustment https://graypaper.fluffylabs.dev/#/911af30/30e00230e002
&gt; https://graypaper.fluffylabs.dev/#/911af30/2da2032da203
&gt; * invoke 60 byte is 8+13*8=125 byte with 4 =&gt; 8
&gt; https://graypaper.fluffylabs.dev/#/911af30/342a01342a01
&gt; https://graypaper.fluffylabs.dev/#/911af30/346101346101
&gt; 

Service ID remains 32-bit (for now)</div>
<div class='msg'><time>2024‑11‑21 09:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Invoke will be fixed in the next revision</div>
<div class='msg'><time>2024‑11‑21 09:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * [Invoke will be fixed in the next revision](https://github.com/gavofyork/graypaper/pull/150)</div>
<div class='msg'><time>2024‑11‑21 17:43</time>&ensp;<span class='u' style='color:#7875cf'>charliewinston14</span>: Good afternoon everyone. I was hoping someone could shed some light on how to generate the accumulate root thats in block history? It&#x27;s provided in the test vectors but would like to be able to generate it myself as well.</div>
<div class='msg'><time>2024‑11‑21 17:45</time>&ensp;<span class='u' style='color:#7875cf'>charliewinston14</span>:  * Good afternoon everyone. I was hoping someone could shed some light on how to generate the accumulate root thats in block history? Not sure how it differs from the mmr peaks I already generated in the history items.</div>
<div class='msg'><time>2024‑11‑21 22:28</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Some candidate 32=&gt;64:

- service id might be 64-bit? https://graypaper.fluffylabs.dev/#/911af30/10da0010da00
thus new&#x27;s check/bump would need adjustment https://graypaper.fluffylabs.dev/#/911af30/30e00230e002
https://graypaper.fluffylabs.dev/#/911af30/2da2032da203
- invoke 60 byte is 8+13\*8=112 byte with 4 =&gt; 8
https://graypaper.fluffylabs.dev/#/911af30/342a01342a01
https://graypaper.fluffylabs.dev/#/911af30/346101346101</div>
<div class='msg'><time>2024‑11‑22 13:52</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: A total of 5 suggested changes to Graypaper Appendix A regarding the change to 64bit.
Allowing up to 8 octets of input for the signed extension function. 
https://github.com/gavofyork/graypaper/pull/151</div>
<div class='msg'><time>2024‑11‑22 13:52</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>:  * A total of 5 suggested changes to Graypaper Appendix A regarding the change to 64bit.
Allowing up to 8 octets of input for the signed extension function. 
PR: https://github.com/gavofyork/graypaper/pull/151</div>
<div class='msg'><time>2024‑11‑23 06:58</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Small suggestion: the epoch marker here https://graypaper.fluffylabs.dev/#/911af30/0e52030e5203 may use $\eta_0$ and $\eta_1$ instead of $\eta_1&#x27;$ and $\eta_2&#x27;$ to keep the dependency graph here https://graypaper.fluffylabs.dev/#/911af30/098001098001 clean</div>
<div class='msg'><time>2024‑11‑23 07:25</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Small suggestion: the epoch marker here https://graypaper.fluffylabs.dev/#/911af30/0e52030e5203 may use $\\eta\_0$ and $\\eta\_1$ instead of $\\eta\_1&#x27;$ and $\\eta\_2&#x27;$ to keep the dependency graph here https://graypaper.fluffylabs.dev/#/911af30/098001098001 clean and easy to reason about -- its equivalent based on https://graypaper.fluffylabs.dev/#/911af30/0e57020e5702</div>
<div class='msg'><time>2024‑11‑24 14:44</time>&ensp;<span class='u' style='color:#788ad5'>yu2c</span>: https://graypaper.fluffylabs.dev/#/911af30/0d63000d7c00
Hello, (6.2) this R as remainder will strongly misunderstand by the constant R in Appendix. Is there any better expression for this equation?</div>
<div class='msg'><time>2024‑11‑24 15:41</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Hey guys, in the `refinement context` what&#x27;s the difference between the anchor (`a`) and the lookup-anchor (`l`) ?</div>
<div class='msg'><time>2024‑11‑24 17:19</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: Perhaps I&#x27;m missing something, but it&#x27;s not clear to me what should happen with memory cells between `l` and `|v|` in case `l &lt; |v|` in `import`. Should these be zeroed or just left as is?
https://graypaper.fluffylabs.dev/#/911af30/32e20232e202</div>
<div class='msg'><time>2024‑11‑24 17:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@yu2c:matrix.org&gt; https://graypaper.fluffylabs.dev/#/911af30/0d63000d7c00
&gt; Hello, (6.2) this R as remainder will strongly misunderstand by the constant R in Appendix. Is there any better expression for this equation?

It is pretty standard (e.g. [here](https://study.com/academy/lesson/remainder-in-math-definition-theorem-examples.html#:~:text=The%20expression%20for%20division%20is,long%20division%20method%20is%20used) ) But I can probably circle it or something to make it more explicit.</div>
<div class='msg'><time>2024‑11‑24 17:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@tomusdrw:matrix.org&gt; Perhaps I&#x27;m missing something, but it&#x27;s not clear to me what should happen with memory cells between `l` and `|v|` in case `l &lt; |v|` in `import`. Should these be zeroed or just left as is?
&gt; https://graypaper.fluffylabs.dev/#/911af30/32e20232e202

that should have bold `v` replaced with bold `v_...l`</div>
<div class='msg'><time>2024‑11‑24 17:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: So that memory would stay exactly as is</div>
<div class='msg'><time>2024‑11‑24 17:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * So that memory would stay unchanged</div>
<div class='msg'><time>2024‑11‑24 17:23</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>:  * Perhaps I&#x27;m missing something, but it&#x27;s not clear to me what should happen with memory cells between `|v|` and `l` in case `l &gt; |v|` in `import`. Should these be zeroed or just left as is?
https://graypaper.fluffylabs.dev/#/911af30/32e20232e202</div>
<div class='msg'><time>2024‑11‑24 17:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@celadari:matrix.org&gt; Hey guys, in the `refinement context` what&#x27;s the difference between the anchor (`a`) and the lookup-anchor (`l`) ?

In summary, anchor is used to anchor the WP (and thus WR) to a particular block which must (still) be in recent history when reported. Lookup-anchor need not be very recent at all (it can be quite old), but must be finalised.</div>
<div class='msg'><time>2024‑11‑24 17:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@celadari:matrix.org&gt; Hey guys, in the `refinement context` what&#x27;s the difference between the anchor (`a`) and the lookup-anchor (`l`) ?

 * In summary, anchor is used to anchor the WP (and thus WR) to a particular block which must (still) be in recent history when reported and ensures that the WP is recent. Lookup-anchor need not be very recent at all (it can be quite old), but must be finalised; this is used to ensure that the point at which the `historical_lookup` (in `refine`) is both finalised and within the amount of lookup-history which we maintain on-chain.</div>
<div class='msg'><time>2024‑11‑24 17:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: You can find out more by reading the section on Reporting (for anchor) and the `historical_lookup` and its dependent function (for lookup-anchor)</div>
<div class='msg'><time>2024‑11‑24 17:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Small suggestion: the epoch marker here https://graypaper.fluffylabs.dev/#/911af30/0e52030e5203 may use $\\eta\_0$ and $\\eta\_1$ instead of $\\eta\_1&#x27;$ and $\\eta\_2&#x27;$ to keep the dependency graph here https://graypaper.fluffylabs.dev/#/911af30/098001098001 clean and easy to reason about -- its equivalent based on https://graypaper.fluffylabs.dev/#/911af30/0e57020e5702

Feel free to make a PR.</div>
<div class='msg reply'><time>2024‑11‑25 00:14</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Sure -- https://github.com/gavofyork/graypaper/pull/154</div>
<div class='msg'><time>2024‑11‑24 18:16</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>:  * Perhaps I&#x27;m missing something, but it&#x27;s not clear to me what should happen with memory cells between `l` and `|v|` in case `l &lt; |v|` in `import`. Should these be zeroed or just left as is?
https://graypaper.fluffylabs.dev/#/911af30/32e20232e202</div>
<div class='msg'><time>2024‑11‑24 18:42</time>&ensp;<span class='u' style='color:#788ad5'>yu2c</span>:  * https://graypaper.fluffylabs.dev/#/911af30/0d63000d7c00
Hello, (6.2) this R as remainder will strongly misunderstand by the constant R in Appendix. While the equation itself appears valid, it could lead to misunderstanding when reading the entire GP. Is there a better way to express this equation to avoid ambiguity&quot;</div>
<div class='msg'><time>2024‑11‑25 08:02</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: could someone clarify please

in chapter 4 we have PVM memory with page size of 2^12 https://graypaper.fluffylabs.dev/#/911af30/2b94002b9400

in appendix A, in (A.31) (A.34) we have page size of 2^14 https://graypaper.fluffylabs.dev/#/911af30/2afe022afe02
which one is it?

thanks




</div>
<div class='msg'><time>2024‑11‑25 08:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@luke_fishman:matrix.org&gt; could someone clarify please
&gt; 
&gt; in chapter 4 we have PVM memory with page size of 2^12 https://graypaper.fluffylabs.dev/#/911af30/2b94002b9400
&gt; 
&gt; in appendix A, in (A.31) (A.34) we have page size of 2^14 https://graypaper.fluffylabs.dev/#/911af30/2afe022afe02
&gt; which one is it?
&gt; 
&gt; thanks

Some of those instances of Z_P should have been renamed to Z_G. Will be [fixed](https://github.com/gavofyork/graypaper/pull/150/commits/10e09e6d1bfb0e3ec37e8007ee9deef850059abd) in 0.5.1</div>
<div class='msg'><time>2024‑11‑25 08:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There is only one PVM page size (2^12)</div>
<div class='msg'><time>2024‑11‑25 08:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: However specifically for standard memory initialization, we use an additional two initialization &quot;page&quot; sizes (2^14 and 2^16)</div>
<div class='msg'><time>2024‑11‑25 08:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * However specifically for standard memory initialization, we use an additional two initialization &quot;page&quot; sizes (2^14 and 2^16) in the math.</div>
<div class='msg'><time>2024‑11‑25 08:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * However specifically and only for standard memory initialization, we use an additional two initialization &quot;page&quot; sizes (2^14 and 2^16) in the math.</div>
<div class='msg'><time>2024‑11‑25 08:15</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: ok. Thank you Gav. </div>
<div class='msg'><time>2024‑11‑25 08:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I cleaned up the wording further in an additional commit. </div>
<div class='msg'><time>2024‑11‑25 12:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@luke_fishman:matrix.org&gt; ok. Thank you Gav.

Further simplifications are incoming here: Simplify initialization memory layout.</div>
<div class='msg'><time>2024‑11‑25 12:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@luke_fishman:matrix.org&gt; ok. Thank you Gav.

 * Further simplifications are incoming here: [Simplify initialization memory layout.](https://github.com/gavofyork/graypaper/pull/150/commits/1648b20a3cf4b1c730083c8033f649306d4d17a5)</div>
<div class='msg'><time>2024‑11‑25 16:24</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: davyx raised a dilemma over gas constants; if `G_T` is `the total gas allocated across all cores for accumulation`, and `G_A` is `the total gass allocated to a core for accumulation`, should `G_A` be `G_T / C`?

https://graypaper.fluffylabs.dev/#/911af30/3f43003f5200</div>
<div class='msg'><time>2024‑11‑25 16:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dakkk:matrix.org&gt; davyx raised a dilemma over gas constants; if `G_T` is `the total gas allocated across all cores for accumulation`, and `G_A` is `the total gass allocated to a core for accumulation`, should `G_A` be `G_T / C`?
&gt; 
&gt; https://graypaper.fluffylabs.dev/#/911af30/3f43003f5200

No not any more</div>
<div class='msg'><time>2024‑11‑25 16:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Because there is queuing and always accumulate services</div>
<div class='msg'><time>2024‑11‑25 16:40</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: &gt; &lt;@gav:polkadot.io&gt; Because there is queuing and always accumulate services

Got it; so the always accumulated services and queuing would have the majority of the available gas, 314000000 - (341*100000) = 279900000 (~89%); is it the correct order of magnitude?</div>
<div class='msg'><time>2024‑11‑25 16:45</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: &gt; &lt;@gav:polkadot.io&gt; Because there is queuing and always accumulate services

 * Got it; so the always accumulated services and queuing would have the majority of the available gas, 341000000 - (341\*100000) = 306900000 (~90%); is it the correct order of magnitude?</div>
<div class='msg'><time>2024‑11‑25 17:54</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: The doubt is mostly about the big 🍰 reserved for queued and always accumulate services</div>
<div class='msg'><time>2024‑11‑25 18:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@dakkk:matrix.org&gt; Got it; so the always accumulated services and queuing would have the majority of the available gas, 341000000 - (341\*100000) = 306900000 (~90%); is it the correct order of magnitude?

Well no not necessarily but the fact that always-accumulate exists at all means they can’t necessarily be equivalent. </div>
<div class='msg'><time>2024‑11‑26 00:22</time>&ensp;<span class='u' style='color:#c377dd'>mkchung</span>: https://graypaper.fluffylabs.dev/#/911af30/36cb02362803

Can state-key constructor functions C be enhanced with a &quot;type&quot; identifier? something like: 

```
(i ∈ N28, t ∈ N2) ↦ [i, t, 0, 0, . . . ]
(i, s ∈ NS, t ∈ N2) ↦ [i, t, n0, 0, n1, 0, n2, 0, n3, 0, 0, . . . ] where n = E4(s) 
(s, h, t) ↦ [t, n0, h0, n1, h1, n2, h2, n3, h3, h4, h5, . . . , h26] where n = E4(s)
```
so that we can determine the expected type (δ, a_s, a_p, a_l) from the C key alone?</div>
<div class='msg'><time>2024‑11‑26 00:34</time>&ensp;<span class='u' style='color:#c377dd'>mkchung</span>:  * https://graypaper.fluffylabs.dev/#/911af30/36cb02362803

Can state-key constructor functions C be enhanced with a &quot;type&quot; identifier? something like:

```
(i ∈ N28, t ∈ N2) ↦ [i, 0, 0, . . . ,t]
(i, s ∈ NS, t ∈ N2) ↦ [i, n0, 0, n1, 0, n2, 0, n3, 0, 0, . . . ,t] where n = E4(s) 
(s, h, t) ↦ [n0, h0, n1, h1, n2, h2, n3, h3, h4, h5, . . . , h26, t] where n = E4(s)
```

so that we can determine the expected type (δ, a\_s, a\_p, a\_l) from the C key alone?</div>
<div class='msg'><time>2024‑11‑26 05:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: t is Boolean? I’m not sure what’s going on here</div>
<div class='msg'><time>2024‑11‑26 06:49</time>&ensp;<span class='u' style='color:#c377dd'>mkchung</span>: &quot;T&quot; is intended to be a type identifier (octet) so that it can potentially support up to 255 different types in state merklelization. 

C1-C15 and account related states (i.e., δ, a_s, a_p, a_l) are all different types. I think it&#x27;s probably beneficial to have one octet from C key as a way to &quot;validate&quot; what encoded struct we are expecting? </div>
<div class='msg'><time>2024‑11‑26 06:55</time>&ensp;<span class='u' style='color:#c377dd'>mkchung</span>: Right now it&#x27;s quite difficult to differentiate account related states (i.e., δ, a_s, a_p, a_l) from C key alone without this &quot;type identifier&quot;.  </div>
<div class='msg'><time>2024‑11‑26 06:55</time>&ensp;<span class='u' style='color:#c377dd'>mkchung</span>: * &quot;T&quot; is intended to be a type identifier (octet) so that it can potentially support up to 255 different types in state merklelization.
C1-C15 and account related states (i.e., δ, a_s, a_p, a_l) are all different types. I think it&#x27;s probably beneficial to have one octet from C key as a way to &quot;validate&quot; what encoded struct we are expecting (if collision is not a concern)?</div>
<div class='msg'><time>2024‑11‑26 07:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The first two key compositions should be easy to spot given the zeroes. The last one is harder, sure because of the information density, but precisely because of this we can’t really afford to waste a byte as that would further reduce the cryptographic security. </div>
<div class='msg'><time>2024‑11‑26 17:41</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: For general fuzz testing of JAM implementers STF in a &quot;jamblocks&quot; tester, we would like to represent 4 components (i.e., δ, a_s, a_p, a_l) of service state, expanding from this starting point

https://github.com/davxy/jam-test-vectors/blob/d4a7c879f54166ba9e505e2440f0b9b99c1dd9b8/reports/tiny/bad_service_id-1.json#L256-L268

</div>
<div class='msg'><time>2024‑11‑26 17:46</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: to include the original inputs
(a) s for δ https://graypaper.fluffylabs.dev/#/911af30/371402371402
(b) k (original 32-bit) for a_s https://graypaper.fluffylabs.dev/#/911af30/372a02372a02
(c) h (original 32-bit) for a_p
(d) (h, l) for a_l

This would require that implementers keep all the metadata { s, k, h, l } for all of (a)-(d), and is useful for implementers to debug in M1-M4.  May I suggest that we have a nice human reasonable JSON format and a matching state trie dump codec  test vector that is not just raw key-vals but organized by serviceID complete with this additional metadata { k, h, l }.   </div>
<div class='msg'><time>2024‑11‑26 17:58</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: This would be better than 
https://github.com/jam-duna/jamtestnet/blob/main/traces/assurances/jam_duna/traces/395473_011.json
and I would suggest motivate a meaningful improvement to CE129 https://github.com/zdave-parity/jam-np/issues/1
which I believe is only for debugging purposes.  
</div>
<div class='msg reply'><time>2024‑11‑26 21:31</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: I&#x27;ve replied to the issue in the `jam-np` repo</div>
<div class='msg reply'><time>2024‑11‑26 21:35</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: FWIW it is possible for a node to maintain the &quot;original&quot; state keys if it executes every block from genesis, but in the case of warp sync this is _not_ possible because not all bits of the original state keys influence the state root and so they cannot all be proven</div>
<div class='msg reply'><time>2024‑11‑26 21:37</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: One further issue is that in the case of the preimage lookup dictionary l, the key transformation involves a hash and so cannot be reversed</div>
<div class='msg reply'><time>2024‑11‑26 21:39</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: In that case you could track the original key and prove this, but if we really want to address this issue I think the simpler solution is to simply include the original key in the transformed value</div>
<div class='msg reply'><time>2024‑11‑26 21:43</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: We could possibly do a similar thing for the discarded key bits</div>
<div class='msg reply'><time>2024‑11‑26 21:43</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Of course this adds complexity, which I think is the reason Gav hasn&#x27;t done it (not that I can speak for him)</div>
<div class='msg reply'><time>2024‑11‑26 23:04</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: there is no reason why we can&#x27;t have an extra aux store to store the preimages / hash mappings to support reverse lookup. this is something like archive node feature that&#x27;s optional but nice to have thing. I don&#x27;t think it needs be spec&#x27;ed</div>
<div class='msg reply'><time>2024‑11‑27 01:36</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Since CE129 is not intended for debug purposes but for warp-sync, this issue is not relevant, thank you.  But the general need for a state representation for STF testing is still there.

For the syncing problem, we do need a clear understanding of how implementations should do the warp sync with CE129 and how AuditDA (1 hour) and ImportDA (28 days) should work at similar timescales, right? We imagine syncing could be skipped for AuditDA but ImportDA cannot.  We doubt teams need to implement it until getting through M1+M2, right?

We should spec out the RPC endpoints (with JSON request/responses) to cover the debugging case of state sharing without regard </div>
<div class='msg reply'><time>2024‑11‑27 01:46</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Don&#x27;t understand what you mean by skipping sync for DA? Could you elaborate?</div>
<div class='msg reply'><time>2024‑11‑27 03:35</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: A new validator who joins a JAM network has to get all chunks associated with its validator index -- for both AuditDA (1 hour) and ImportDA (28 days).  For Audit DA, if there is some upper bound on how many new validators can join (not sure about where this will happen) then within an hour of participating its up to date -- so a new validator could &quot;skip&quot; this Audit DA syncing operation since there is so much redundancy.    Or it could look through the last hours worth of work reports and ask the guarantors for its chunks.

But for Import DA, the new validator should have some fast way of getting all the chunks its responsible for holding.  It could look through the last 28 days of work reports and ask the guarantors for its chunks .. but I am not sure that it can.</div>
<div class='msg reply'><time>2024‑11‑27 09:16</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Where did you get that from? Once enough validators claim receipt of their shards I do not believe there is any requirement for the guarantors of a report to send out more shards. There is also no mechanism for validators to report that they have obtained the shards after this point, although you could argue that isn&#x27;t really necessary.</div>
<div class='msg reply'><time>2024‑11‑27 16:47</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Consider the situation where on Dec 1 there is a segment exported in a V=1024 network.  Under normal conditions, up to 2/3 of the network can be dead and the segment will be available in ImportDA.

BUT if every day from Dec 1 to 11, 100 validators leave and 100 new join to take their place, in such a way that the entire network has been completely replaced, but 
(a) no one has the data to reconstruct the segment
(b) no one in the new set has used any JAMNP method to fetch their chunk from the guarantor, 
what happens?  

I think the present answer is &quot;there is no plan&quot;?  

Is the solution to this problem 28 day unbonding periods?  What happens with unbonding queues that are way shorter than that?

</div>
<div class='msg reply'><time>2024‑11‑27 16:49</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: https://github.com/polkadot-fellows/RFCs/blob/main/text/0097-unbonding_queue.md</div>
<div class='msg reply'><time>2024‑11‑27 16:54</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: There is a question of whether there are sufficient incentives for old validators to maintain import DA data and make it available to the current validator set for the full 28 days. I don&#x27;t know the answer to that.</div>
<div class='msg reply'><time>2024‑11‑27 16:56</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: AFAIK though there is no mechanism to &quot;hand over&quot; import DA data to new validators</div>
<div class='msg'><time>2024‑11‑26 18:01</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * to include the original inputs
(a) s for δ https://graypaper.fluffylabs.dev/#/911af30/371402371402
(b) k (original 32-bit) for a\_s https://graypaper.fluffylabs.dev/#/911af30/372a02372a02
(c) h (original 32-bit) for a\_p https://graypaper.fluffylabs.dev/#/911af30/373d02373d02
(d) (h, l) for [a\_l](https://graypaper.fluffylabs.dev/#/911af30/375002375002)

This would require that implementers keep all the metadata { s, k, h, l } for all of (a)-(d), and is useful for implementers to debug in M1-M4.  May I suggest that we have a nice human reasonable JSON format and a matching state trie dump codec  test vector that is not just raw key-vals but organized by serviceID complete with this additional metadata { k, h, l }.   </div>
<div class='msg'><time>2024‑11‑26 18:01</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * to include the original inputs to C
(a) s for [δ](https://graypaper.fluffylabs.dev/#/911af30/371402371402)
(b) k (original 32-bit) for [a\_s]( https://graypaper.fluffylabs.dev/#/911af30/372a02372a02)
(c) h (original 32-bit) for [a\_p]( https://graypaper.fluffylabs.dev/#/911af30/373d02373d02)
(d) (h, l) for [a\_l](https://graypaper.fluffylabs.dev/#/911af30/375002375002)

This would require that implementers keep all the metadata { s, k, h, l } for all of (a)-(d), and is useful for implementers to debug in M1-M4.  May I suggest that we have a nice human reasonable JSON format and a matching state trie dump codec  test vector that is not just raw key-vals but organized by serviceID complete with this additional metadata { k, h, l }.</div>
<div class='msg'><time>2024‑11‑26 18:04</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * By making the state trie JSON+codec representation non-lossy (at the cost of making JAM implementers have slightly more bookkeeping) This would be better than 
https://github.com/jam-duna/jamtestnet/blob/main/traces/assurances/jam\_duna/traces/395473\_011.json
and I would suggest motivate a meaningful improvement to CE129 https://github.com/zdave-parity/jam-np/issues/1
which I believe is only for debugging purposes.  I claim that the additional cost of bookkeeping by JAM implementers will be happily borne to save tons of debugging time later.  Do you agree?  If not, why not?</div>
<div class='msg'><time>2024‑11‑26 18:11</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * By making the state trie JSON+codec representation non-lossy in having the original inputs for C that decide the keys (at the cost of making JAM implementers have slightly more bookkeeping), we have something better than the raw key-vals 
https://github.com/jam-duna/jamtestnet/blob/main/traces/assurances/jam\_duna/traces/395473\_011.json
requiring a bunch of guesswork.   I would further suggest that this motivates a meaningful improvement to CE129
 https://github.com/zdave-parity/jam-np/issues/1
which I believe is only for debugging purposes (confirm?). 

I claim that the additional cost of bookkeeping by JAM implementers will be happily borne to save tons of debugging time later.  

Do you agree?  If not, why not?</div>
<div class='msg'><time>2024‑11‑27 01:37</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Since CE129 is not intended for debug purposes but for warp-sync, this issue is not relevant, thank you.  But the general need for a state representation for STF testing is still there.  Closed the issue =)

For the syncing problem, we do need a clear understanding of how implementations should do the warp sync with CE129 and how AuditDA (1 hour) and ImportDA (28 days) should work at similar timescales, right? We imagine syncing could be skipped for AuditDA but ImportDA cannot.  We doubt teams need to implement it until getting through M1+M2, right?

We should spec out the RPC endpoints (with JSON request/responses) to cover the debugging case of state sharing without regard </div>
<div class='msg'><time>2024‑11‑27 01:37</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Since CE129 is not intended for debug purposes but for warp-sync, this issue is not relevant, thank you.  Closed the issue =). But the general need for a state representation for STF testing (and debugging state) is still there.  

For the syncing problem, we do need a clear understanding of how implementations should do the warp sync with CE129 and how AuditDA (1 hour) and ImportDA (28 days) should work at similar timescales, right? We imagine syncing could be skipped for AuditDA but ImportDA cannot.  We doubt teams need to implement it until getting through M1+M2, right?

We should spec out the RPC endpoints (with JSON request/responses) to cover the debugging case of state sharing without regard</div>
<div class='msg'><time>2024‑11‑27 01:37</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Since CE129 is not intended for debug purposes but for warp-sync, this issue is not relevant, thank you.  Closed the issue =). But the general need for a state representation for STF testing (and debugging state) is still there.

For the syncing problem, we do need a clear understanding of how implementations should do the warp sync with CE129 and how AuditDA (1 hour) and ImportDA (28 days) should work at similar timescales, right? We imagine syncing could be skipped for AuditDA but ImportDA cannot.  We doubt teams need to implement it until getting through M1+M2, right?

We should spec out the RPC endpoints (with JSON request/responses) to cover the debugging case of state sharing without regard to CE 129 warp syncing.</div>
<div class='msg'><time>2024‑11‑27 01:42</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Since CE129 is not intended for debug purposes but for warp-sync, this issue is not relevant, thank you.  Closed the issue =). But the general need for a state representation for STF testing (and debugging state) is still there.

For the syncing problem, we do need a clear understanding of how implementations should do the warp sync with CE129 and how AuditDA (1 hour) and ImportDA (28 days) should work at similar timescales, right? We imagine syncing could be skipped for AuditDA but ImportDA cannot.  We doubt teams need to implement it until getting through M1+M2, right?

We should spec out the RPC endpoints (with JSON request/responses) to cover the debugging case of state sharing without regard to CE 129 warp syncing... and the top 10 others.  </div>
<div class='msg'><time>2024‑11‑27 16:51</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Consider the situation where on Dec 1 there is a segment exported in a V=1024 network.  Under normal conditions, up to 2/3 of the network can be dead and the segment will be available in ImportDA.

BUT if every day from Dec 1 to 11, 100 validators leave and 100 new join to take their place, in such a way that the entire network has been completely replaced, but 
(a) no one has the data to reconstruct the segment
(b) no one in the new set has used any JAMNP method to fetch their chunk from the guarantor, 
what happens?  

I think the present answer is &quot;there is no plan&quot;.

If the plan is &quot;oh we have 28 day unbonding periods&quot;, what happens with unbonding queues that are way shorter than that?

This sets my expectation that we need a way to have ImportDA syncs for a changing of the guard, where one validator takes the place of another at a specific validator index.  </div>
<div class='msg'><time>2024‑11‑27 16:57</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Indeed there is not. Thus far the assumption is that it doesn’t matter. </div>
<div class='msg'><time>2024‑11‑27 16:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (Ie churn will be sufficiently small)</div>
<div class='msg'><time>2024‑11‑27 17:06</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Concerning the accumulation queue, we are struggling to come up with a test case where we have 12.3 https://graypaper.fluffylabs.dev/#/911af30/167100167100 filled with anything because 11.38 https://graypaper.fluffylabs.dev/#/911af30/156001156001 makes it difficult to impossible to do so.   

Concretely, if package M has package F as a prerequisite, because of 11.38 requirement, M can&#x27;t even get a work report in for 12.3 to matter.   Put another way, 11.38 has prereqs constraining refine of M before 12.3 accumulation can matter.  
How can we get a good test case for accumulation queue then?  

We must be misunderstanding something here.</div>
<div class='msg'><time>2024‑11‑27 17:09</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: AIUI the dependencies stuff in the backend is to deal with availability of work reports happening out of order</div>
<div class='msg'><time>2024‑11‑27 17:09</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Or not happening at all</div>
<div class='msg'><time>2024‑11‑27 17:10</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: So say you have two WPs A and B, with B depending on A. A and B can be reported in the same block. If B becomes available before A then it will enter the &quot;ready&quot; queue but must wait for A to be accumulated before it can be.</div>
<div class='msg'><time>2024‑11‑27 17:11</time>&ensp;<span class='u' style='color:#c65779'>dave</span>:  * So say you have two WPs A and B, with B depending on A. A and B can be reported in the same block. If B becomes available before A then it will enter the &quot;ready&quot; queue but must wait for A to be made available and accumulated before it can be.</div>
<div class='msg'><time>2024‑11‑27 17:11</time>&ensp;<span class='u' style='color:#c65779'>dave</span>:  * So say you have two WPs A and B, with B depending on A. A and B can be reported in the same block. If B becomes available before A then it will enter the &quot;ready&quot; queue but must wait for A to be made available and accumulated before it can be accumulated itself.</div>
<div class='msg'><time>2024‑11‑27 17:14</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Here is the thing -- by 11.38 B cannot become available before A because of this requirement https://graypaper.fluffylabs.dev/#/911af30/156001156001</div>
<div class='msg'><time>2024‑11‑27 17:15</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: That&#x27;s a requirement for reporting. Availability happens after this</div>
<div class='msg'><time>2024‑11‑27 17:17</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: If B doesn&#x27;t get reported, there is no way for B to become available?</div>
<div class='msg'><time>2024‑11‑27 17:17</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * If B doesn&#x27;t get reported until A is reported, there is no way for B to become available before A, right?  </div>
<div class='msg'><time>2024‑11‑27 17:18</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * If B doesn&#x27;t get reported until A is reported, there is no way for B to become available before A, right?  No &quot;If B becomes available before A&quot; possibility exists then.</div>
<div class='msg'><time>2024‑11‑27 17:19</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * If B doesn&#x27;t get reported until A is reported, there is no way for B to become available before A, right?  No &quot;If B becomes available before A&quot; possibility exists then, thus no way for the accumulation queue to be filled with B.  </div>
<div class='msg'><time>2024‑11‑27 17:19</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Why do you say that? The availability of the two packages is pretty independent</div>
<div class='msg'><time>2024‑11‑27 17:20</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: For one if the guarantors for A go offline then A just won&#x27;t become available at all</div>
<div class='msg'><time>2024‑11‑27 17:31</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: 1. For guarantors, they can assure the data as soon as they generated the work report.
2. For non-guarantors, they will only be able to assure the data based on observing a guarantee extrinsic that includes a work report.  
The majority of the network (all but 2 or 3 validators out of V) is in 2.  

So for the B-depends-on-A:
* By 11.38 requirement on reporting/guarantees, there is no way to generate a work report for B until A has a work report
* Because of 2, the majority of the network cannot provide an assurance
* Because the above &quot;the majority of the network cannot provide an assurance&quot;, we are having difficulty generating any situation where 12.3 accumulation queue is filled with anything.

What are we getting wrong in the above chain of logic?  Is there a test case where 12.3 accumulation queue is filled with anything?

Note that we ARE able to generate a test case like this:
(1) |E_G|=2, where refine of A+B are executed _in the same slot_ 
(2) |E_A|=V, where all V validators assure both A+B and then due to the &quot;B depending on A&quot; first A is accumulated (having no dependencies) then B (having a dependency on A)</div>
<div class='msg'><time>2024‑11‑27 17:35</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: and what we have to do to get a test case working is:
(1) |E_G|=2, where refine of A+B are executed in the same slot (that is, 11.38 is NOT a problem)
then simulate a forced delay of assurances in order to get our accumulation queue filled.  Is this the only way?</div>
<div class='msg'><time>2024‑11‑27 17:36</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: What do you mean by &quot;Because of 2, the majority of the network cannot provide an assurance&quot;</div>
<div class='msg'><time>2024‑11‑27 17:39</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: If in your test case all reports are assured immediately then no you probably won&#x27;t get anything in the queue. So yes your test needs to simulate assurances being delayed. Not sure why this is impossible?</div>
<div class='msg'><time>2024‑11‑27 17:40</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Not impossible -- but our belief is that this is the only way.  Can you think of another?</div>
<div class='msg'><time>2024‑11‑27 17:41</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: &gt; &lt;@dave:parity.io&gt; AIUI the dependencies stuff in the backend is to deal with availability of work reports happening out of order

Not aware of one. As I said, I believe the entire point of the dependencies stuff is to deal with this happening.</div>
<div class='msg'><time>2024‑11‑27 17:41</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: ok, great, we don&#x27;t have a misconception, thank you!</div>
<div class='msg'><time>2024‑11‑29 05:31</time>&ensp;<span class='u' style='color:#4068cd'>0xjunha</span>: https://graypaper.fluffylabs.dev/#/911af30/162e02162f02
Potential typo: &quot;the queue of work-reports&quot; should be &quot;the queue of authorizers&quot;?</div>
<div class='msg'><time>2024‑11‑29 08:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Correct! Will be fixed in next revision. </div>
<div class='msg'><time>2024‑11‑29 13:05</time>&ensp;<span class='u' style='color:#4068cd'>0xjunha</span>: https://graypaper.fluffylabs.dev/#/911af30/2af3002a0801
https://graypaper.fluffylabs.dev/#/911af30/23b20123c401
^ It seems type for the instruction counter is missing in these definitions

https://graypaper.fluffylabs.dev/#/911af30/2bd8012bd801
^ And type for the instruction could be `N_R`, it is currently marked as `N`.</div>
<div class='msg'><time>2024‑11‑29 15:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@0xjunha:matrix.org&gt; https://graypaper.fluffylabs.dev/#/911af30/2af3002a0801
&gt; https://graypaper.fluffylabs.dev/#/911af30/23b20123c401
&gt; ^ It seems type for the instruction counter is missing in these definitions
&gt; 
&gt; https://graypaper.fluffylabs.dev/#/911af30/2bd8012bd801
&gt; ^ And type for the instruction could be `N_R`, it is currently marked as `N`.

Will be corrected in 0.5.1: PVM: Don&#x27;t forget the instruction counter in prototype</div>
<div class='msg'><time>2024‑11‑29 15:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Will be corrected in 0.5.1: PVM: [Don&#x27;t forget the instruction counter in prototype](https://github.com/gavofyork/graypaper/pull/150/commits/6ad68fe00c8800c750118574ea6e5bc901530bba)</div>
<div class='msg'><time>2024‑11‑29 16:02</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: Hi, this Disputes test https://github.com/davxy/jam-test-vectors/blob/disputes/disputes/tiny/progress_with_culprits-7.json fails because there is an offender relative to a not present verdict. Where is especified in the GP that offenders must be relative a present verdict? An offender cannot be new to be subsequently added to the verdicts?</div>
<div class='msg'><time>2024‑11‑29 16:27</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: &gt; &lt;@vinsystems:matrix.org&gt; Hi, this Disputes test https://github.com/davxy/jam-test-vectors/blob/disputes/disputes/tiny/progress_with_culprits-7.json fails because there is an offender relative to a not present verdict. Where is especified in the GP that offenders must be relative a present verdict? An offender cannot be new to be subsequently added to the verdicts?

the test fails because the culprit target is not in the bad set (equation 10.5)</div>
<div class='msg'><time>2024‑11‑30 13:28</time>&ensp;<span class='u' style='color:#4068cd'>0xjunha</span>: Another small correction for consistency: wrapping the `(x_s)_l` with `\keys{}` here
https://graypaper.fluffylabs.dev/#/911af30/31b30231b302
</div>
<div class='msg'><time>2024‑12‑02 08:54</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: </div>
<div class='msg'><time>2024‑12‑03 07:14</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * Is it possible to have different epoch judgments in the same dispute extrinsic? </div>
<div class='msg'><time>2024‑12‑05 11:05</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: Hello, guess i am missing something.
in [Refine Invocation](https://graypaper.fluffylabs.dev/#/911af30/2c5b012c5b01) we only ever call the Argument Invocation with x = (∅, [])
this then passes on through ΨM and ΨH and eventually one of the Omegas in [B.8](https://graypaper.fluffylabs.dev/#/911af30/322101322101) is getting called with this pair as an argument

so if we only ever pass &quot;empty&quot; pair, how will the internal Omegas ever operate on non empty argument?
</div>
<div class='msg'><time>2024‑12‑05 11:05</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>:  * Hello, guess i am missing something.
in [Refine Invocation](https://graypaper.fluffylabs.dev/#/911af30/2c5b012c5b01) we only ever call the Argument Invocation with **x = (∅, \[\])**
this then passes on through ΨM and ΨH and eventually one of the Omegas in [B.8](https://graypaper.fluffylabs.dev/#/911af30/322101322101) is getting called with this pair as an argument

so if we only ever pass &quot;empty&quot; pair, how will the internal Omegas ever operate on non empty argument?</div>
<div class='msg'><time>2024‑12‑05 11:17</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: ok i think i can answer myself (sorry for the spam)
by using a series of host calls i can progressively  &quot;fill up&quot; the context pair
for example i could use machine =&gt; poke =&gt; peek in order to
create a machine in the **m** dictionary, write some program into it then verify it is there using peek</div>
<div class='msg'><time>2024‑12‑05 13:05</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: When we are building paged proof, we will use the paged proof 64 hashed segments data for building segment justification.

The export root is built with a constancy preprocessor that prepends &quot;$leaf&quot; to the data.

Shouldn&#x27;t we also prepend &quot;$leaf&quot; here?

https://graypaper.fluffylabs.dev/#/911af30/1a18011a1f01</div>
<div class='msg'><time>2024‑12‑06 03:38</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * We use the paged proof hashed segments for building segment justification.

The segment root is built with a constancy preprocessor that prepends &quot;$leaf&quot; to the data.

Shouldn&#x27;t we also prepend &quot;$leaf&quot; here?

https://graypaper.fluffylabs.dev/#/911af30/1a18011a1f01</div>
<div class='msg'><time>2024‑12‑06 08:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@amritj:matrix.org&gt; We use the paged proof hashed segments for building segment justification.
&gt; 
&gt; The segment root is built with a constancy preprocessor that prepends &quot;$leaf&quot; to the data.
&gt; 
&gt; Shouldn&#x27;t we also prepend &quot;$leaf&quot; here?
&gt; 
&gt; https://graypaper.fluffylabs.dev/#/911af30/1a18011a1f01

Yes in the present system it would be needed. I might alter things so that for the pages proofs tree we don’t bother with the leaf/node prefixes at all since they’re redundant here. </div>
<div class='msg'><time>2024‑12‑06 08:10</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: Gotcha, thanks!</div>
<div class='msg'><time>2024‑12‑06 11:14</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@amritj:matrix.org&gt; Gotcha, thanks!

https://github.com/gavofyork/graypaper/pull/150/commits/9b6ca3aac5a90b40fefa6449c238b0ff9bd3b3cb</div>
<div class='msg'><time>2024‑12‑06 15:05</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: One more suggestions, I think we should also check the export count in the work package items to be equal to the length of the actually exported segments.

Otherwise, work item can export more segments than Wm (2**11) and I think may even overwrite index of the export segment of next work item as node might calculate the next work item export start using the export_count variable

https://graypaper.fluffylabs.dev/#/911af30/1a0c021a0c02</div>
<div class='msg'><time>2024‑12‑06 15:06</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: </div>
<div class='msg'><time>2024‑12‑06 15:06</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Also, I can find any such constant named Wx, I think it should be Wm

https://graypaper.fluffylabs.dev/#/911af30/33ae0033ae00</div>
<div class='msg'><time>2024‑12‑06 15:06</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * One more suggestion, I think we should also check the export count in the work package items to be equal to the length of the actually exported segments.

Otherwise, work item can export more segments than Wm (2\*\*11) and I think may even overwrite index of the export segment of next work item as node might calculate the next work item export start using the export\_count variable

https://graypaper.fluffylabs.dev/#/911af30/1a0c021a0c02</div>
<div class='msg'><time>2024‑12‑06 15:35</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * One more suggestion, I think we should also check the export count in the work package items to be equal to the length of the actually exported segments.

Otherwise, work item can export more segments than Wm (2\*\*11) and I think may even overwrite index of the export segment of next work item

https://graypaper.fluffylabs.dev/#/911af30/1a0c021a0c02</div>
<div class='msg'><time>2024‑12‑06 16:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@amritj:matrix.org&gt; One more suggestion, I think we should also check the export count in the work package items to be equal to the length of the actually exported segments.
&gt; 
&gt; Otherwise, work item can export more segments than Wm (2\*\*11) and I think may even overwrite index of the export segment of next work item
&gt; 
&gt; https://graypaper.fluffylabs.dev/#/911af30/1a0c021a0c02

It&#x27;s technically impossible to validly export more items than W_M already due to the condition in the `export` host-call (the only way to validly append an export)</div>
<div class='msg'><time>2024‑12‑06 16:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: But in any case, there&#x27;s a required limitation placed on work-packages here: https://graypaper.fluffylabs.dev/#/911af30/19f500190501</div>
<div class='msg'><time>2024‑12‑06 16:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: @room [0.5.2](https://github.com/gavofyork/graypaper/releases/tag/v0.5.2) is out, with all of the various corrections from the past two weeks including those in [0.5.1](https://github.com/gavofyork/graypaper/releases/tag/v0.5.1), as well as some quite important tweaks:
- Change blocks to be audited by their prior validator set
- PVM: Simplify initialization memory layout
- WP&amp;WRs: Maximum size includes encoded size of Work Package
- BEEFY: Use a more optimal BEEFY MMR commitment format</div>
<div class='msg'><time>2024‑12‑06 17:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * @room [0.5.2](https://github.com/gavofyork/graypaper/releases/tag/v0.5.2) is out, with all of the various corrections from the past two weeks including those in [0.5.1](https://github.com/gavofyork/graypaper/releases/tag/v0.5.1), as well as some quite important tweaks:

- Change blocks to be audited by their prior validator set
- PVM: Simplify initialization memory layout
- [WP&amp;WRs: Introduce second gas limit for Accumulate](https://github.com/gavofyork/graypaper/pull/150/commits/e691d2cc8d8d3cba049e8f6c02a11aa6e884799f)
- [WP&amp;WRs: More sensible Work Report size limit](https://github.com/gavofyork/graypaper/pull/150/commits/1f4c31976eb9242b74d18c7b57c7cd075cd6f371)
- BEEFY: Use a more optimal BEEFY MMR commitment format</div>
<div class='msg'><time>2024‑12‑06 17:06</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: Yes, we checking if the export segment list is full if the export segment offset + current work item export count is more than Wm, but the export segment offset is calculated by summing up the export count mentioned in the work package built by the builder

But we are not checking if the export count is equal no of segments actually exported by the work items.

Maybe I am missing something? </div>
<div class='msg'><time>2024‑12‑06 17:06</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yes, we are checking if the export segment list is full if the export segment offset + current work item export count is more than Wm, but the export segment offset is calculated by summing up the export count mentioned in the work package built by the builder

But we are not checking if the export count is equal no of segments actually exported by the work items.

Maybe I am missing something?</div>
<div class='msg'><time>2024‑12‑06 17:06</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yes, we are checking if the export segment list is full if the export segment offset + current work item export count is more than Wm (2**11) , but the export segment offset is calculated by summing up the export count mentioned in the work package built by the builder

But we are not checking if the export count is equal no of segments actually exported by the work items.

Maybe I am missing something?</div>
<div class='msg'><time>2024‑12‑06 17:07</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yes, we are checking if the export segment list is full if the export segment offset + current work item export count is more than Wm (2\*\*11) , but the export segment offset is calculated by summing up the export count mentioned in the work package built by the builder

But we are not validating if the export count is equal to no of segments actually exported by the work items after refine

Maybe I am missing something?</div>
<div class='msg'><time>2024‑12‑06 17:08</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yes, we are checking if the export segment list is full if the export segment offset + current work item export count is more than W_M (2\*\*11) , but the export segment offset is calculated by summing up the export count mentioned in the work package built by the builder

But we are not validating if the export count is equal to no of segments actually exported by the work items after refine

Maybe I am missing something?</div>
<div class='msg'><time>2024‑12‑06 17:08</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yes, we are checking if the export segment list is full if the export segment offset + current work item export count is more than W\_M (2\*\*11) , but the export segment offset is calculated by summing up the export counts of work items mentioned in the work package built by the builder

But we are not validating if the export count is equal to no of segments actually exported by the work items after refine

Maybe I am missing something?</div>
<div class='msg'><time>2024‑12‑06 17:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@amritj:matrix.org&gt; Yes, we are checking if the export segment list is full if the export segment offset + current work item export count is more than W\_M (2\*\*11) , but the export segment offset is calculated by summing up the export counts of work items mentioned in the work package built by the builder
&gt; 
&gt; But we are not validating if the export count is equal to no of segments actually exported by the work items after refine
&gt; 
&gt; Maybe I am missing something?

 https://github.com/gavofyork/graypaper/pull/160</div>
<div class='msg'><time>2024‑12‑06 17:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I&#x27;m not totally convinced that the builder can really break anything for anyone other than themselves by misreporting these counts.</div>
<div class='msg'><time>2024‑12‑06 17:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: But it&#x27;s probably sensible anyway.</div>
<div class='msg'><time>2024‑12‑06 17:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * I&#x27;m not (yet) totally convinced that the builder can really break anything for anyone other than themselves by misreporting these counts.</div>
<div class='msg'><time>2024‑12‑07 10:58</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: Question:

In auditing, we consider the report audited if the report have no negative judgement and there exists some tranche where all validators required to audit have positive judgement about the report.

In case some validator announced a audit but failed to deliver the judgement, and new audits are announced to cover that.

So, the new tranche A_n will be = old tranche auditors + new auditors just announced - auditors failed to deliver judgement ?
</div>
<div class='msg'><time>2024‑12‑07 10:58</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Question:

In auditing, we consider the report audited if the report have no negative judgement and there exists some tranche where all validators required to audit have positive judgement about the report.

In case some validator announced a audit but failed to deliver the judgement, and new audits are announced to cover that.

So, the new tranche A_n will be = old tranche auditors + new auditors just announced - auditors failed to deliver judgement ?

https://graypaper.fluffylabs.dev/#/911af30/1eab001eae00</div>
<div class='msg'><time>2024‑12‑07 11:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Once it has been determined by the auditor that they will audit the new tranche, the VRF is used to determine which cores (and thus which WRs) should be audited. These are announced and by doing so the node is obliged to publish a judgement. They receive corresponding announcements from other auditors and will audit a new tranche only if by the tranche&#x27;s time limit they have not received judgements on them.</div>
<div class='msg'><time>2024‑12‑07 11:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Once it has been determined by the auditor that they will audit the new tranche, the VRF is used to determine which cores (and thus which WRs) should be audited. These are announced and by doing so the node is obliged to publish a judgement. They receive corresponding announcements and, later, judgements, from other auditors and will audit a new tranche only if by the tranche&#x27;s time limit they have not received a judgement for every announcement.</div>
<div class='msg'><time>2024‑12‑07 11:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Once it has been determined by the auditor that they will audit the new tranche, the VRF is used to determine which cores (and thus which WRs) should be audited. These are announced and by doing so the node is obliged to publish a judgement. They receive corresponding announcements and, later, judgements, from other auditors and will audit a new tranche only if by the tranche&#x27;s time limit they have not received a judgement for each announcement.</div>
<div class='msg'><time>2024‑12‑07 11:37</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: </div>
<div class='msg'><time>2024‑12‑07 11:37</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * In new tranche, auditors will only audit reports that were announced to be audited in previous tranch but judgement no received, right?</div>
<div class='msg'><time>2024‑12‑07 11:46</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: Ahh, gotcha, the new audit tranche only contain reports that did not receive all judgement, other reports that did receive all judgements are excluded from the new tranche list because they are already validated, thanks!</div>
<div class='msg'><time>2024‑12‑07 11:47</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Ahh, gotcha, the new audit tranche only contain reports that did not receive all judgement, other reports that did receive all judgements are excluded from the new tranche list because they are already validated, thanks I got bit confused!</div>
<div class='msg'><time>2024‑12‑07 11:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The new audit tranche is determined solely by the VRF.</div>
<div class='msg'><time>2024‑12‑07 11:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: This is defined as (17.15) and (17.16)</div>
<div class='msg'><time>2024‑12‑07 11:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: So we perceive m_n missing audits at tranche n: those two formulae determine which of the work-reports (w) we will be required to audit this tranche.</div>
<div class='msg'><time>2024‑12‑07 11:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: As the number of perceived missing reports increases, we audit a greater selection.</div>
<div class='msg'><time>2024‑12‑07 11:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * For any tranche, as the number of perceived missing-judgements increases, we audit a greater selection.</div>
<div class='msg'><time>2024‑12‑07 11:59</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * For any tranche, as the number of perceived missing-judgements increases, we audit a greater selection of the overall work-reports.</div>
<div class='msg'><time>2024‑12‑07 11:59</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: We don&#x27;t (necessarily) audit the report(s) with the missing judgement.</div>
<div class='msg'><time>2024‑12‑07 11:59</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * We don&#x27;t (necessarily) audit the report(s) with the missing judgement(s).</div>
<div class='msg'><time>2024‑12‑07 12:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: And we *always* pass a judgement on any audits we have annouced ourselves.</div>
<div class='msg'><time>2024‑12‑07 12:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * And we _always_ pass a judgement on any audits we have announced ourselves.</div>
<div class='msg'><time>2024‑12‑07 12:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: This is described in the paragraph here: https://graypaper.fluffylabs.dev/#/911af30/1e18001e2000</div>
<div class='msg'><time>2024‑12‑07 12:03</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: Yes, thanks, I got confused about rechecking all previous tranche WR to be present in J_T to consider this WR audited, but as per eq 17.16 we only include those Work reports in new tranche that did not have all announced judgement, so no need to check them again</div>
<div class='msg'><time>2024‑12‑07 12:04</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yes, thanks, I got confused about rechecking all previous tranche WR to be present in J\_T to consider this WR audited, but as per eq 17.16 we only include those Work reports in new tranche that did not have all announced judgement, so no need to check Work reports that are not included in this tranche again</div>
<div class='msg'><time>2024‑12‑07 12:04</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yes, thanks, I got confused about rechecking all previous tranche WR to be present in J\_T to consider this WR audited, but as per eq 17.16 we only include those Work reports in new tranche that did not have all announced judgement, so no need to check work reports that are not included in this tranche again</div>
<div class='msg'><time>2024‑12‑07 12:04</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yes, thanks, I got confused about rechecking all previous tranche WR to be present in J\_T to consider this WR audited, but as per eq 17.16 we only include those Work reports in new tranche that did not have all announced judgement, so no need to check work reports that are not included in this tranche again!</div>
<div class='msg'><time>2024‑12‑07 12:04</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Thanks, I got confused about rechecking all previous tranche WR to be present in J\_T to consider this WR audited, but as per eq 17.16 we only include those Work reports in new tranche that did not have all announced judgement, so no need to check work reports that are not included in this tranche again!</div>
<div class='msg'><time>2024‑12‑07 12:09</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Thanks, I got confused about rechecking all previous tranche WR to be present in J\_T to consider this WR audited, but as per eq 17.16 we only include those Work reports in new tranche that did not have all announced judgement, so no need to check work reports that are not included in new tranche again!</div>
<div class='msg'><time>2024‑12‑07 12:09</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Thanks, I got confused about rechecking all previous tranche WR to be present in J\_T to consider this WR audited, but as per eq 17.16 we only include those Work reports in new tranche that did not have all announced judgement, so no need to check work reports that are not included in next tranche again!</div>
<div class='msg'><time>2024‑12‑07 19:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@amritj:matrix.org&gt; Yes, we are checking if the export segment list is full if the export segment offset + current work item export count is more than W\_M (2\*\*11) , but the export segment offset is calculated by summing up the export counts of work items mentioned in the work package built by the builder
&gt; 
&gt; But we are not validating if the export count is equal to no of segments actually exported by the work items after refine
&gt; 
&gt; Maybe I am missing something?

https://github.com/gavofyork/graypaper/pull/160/commits/184515d80354f96f0410b48cea950ed7c9e4f03f</div>
<div class='msg'><time>2024‑12‑07 19:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: This will be updated to a new system; WPs should not be invalidated by a bad export count.</div>
<div class='msg'><time>2024‑12‑08 03:47</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: I asked this question in Jam room, not solved there so asking here too:


Question:

The segments are erasure-coded and distributed to the validators. Each validator receives a single shard out of the 1,023 shards, determined by their validator index. Therefore, the shard index of the shard they receive equals to their validator index.

According to the JAMNP protocol, to fetch data from the assurers, we need to provide each assurer with the shard index we require from them.

The exported segments are expected to remain available for 28 days. During this period, it is assumed that more than 341 validators will remain consistent. However, there is still a significant likelihood that validator indexes may change during this time due to the addition or removal of validators.

I asked if we have to remember historical validator sets to know who to request shards from, which David Emett  confirmed

But we are not able to find any way to distribute this data to a new validator added to the network, and without this data he won&#x27;t be able to compute work reports.


I proposed to not require shard index in the request to fetch data from assurer but assurer himself give us the shard index which we can ofcourse verify is correct or not, so we only need the erasure root and segment index, but as some new validators added to the system if we randomly choose 342 assurers to request data from some of the responses will be empty so either we can request from ~400-500 validators (churn rate as confirmed by sourabhniyogi  is low, so we will most probably receive more than 342 shards) OR somehow store which validators were expected to be active in the requested WR segment epoch by storing status component like we do in preimages in the validator metadata which I am not much sure about 

Is this a good solution to the problem or is there a better answer we can&#x27;t see?</div>
<div class='msg'><time>2024‑12‑08 03:49</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * I asked this question in Jam room, not solved there so asking here too:

Question:

The segments are erasure-coded and distributed to the validators. Each validator receives a single shard out of the 1,023 shards, determined by their validator index. Therefore, the shard index of the shard they receive equals to their validator index.

According to the JAMNP protocol, to fetch data from the assurers, we need to provide each assurer with the shard index we require from them.

The exported segments are expected to remain available for 28 days. During this period, it is assumed that more than 341 validators will remain consistent. However, there is still a significant likelihood that validator indexes may change during this time due to the addition or removal of validators.

I asked if we have to remember historical validator sets to know who to request shards from, which David Emett  confirmed

But we are not able to find any way to distribute this data to a new validator added to the network, and without this data he won&#x27;t be able to compute work reports.

I proposed to not require shard index in the request to fetch data from assurer but assurer himself give us the shard index which we can ofcourse verify is correct or not, so we only need the erasure root and segment index, but as some new validators added to the system if we randomly choose 342 assurers to request data from some of the responses will be empty so either we can request from ~400-500 validators (churn rate as confirmed by sourabhniyogi  is low, so we will most probably receive more than 342 shards) OR somehow store which validators were expected to be active in the requested WR segment epoch by storing status component like we do in preimages in the validator metadata which I am not much sure about

The above solution is only for new validators, old validators will use the normal method as they know which validators have which shard

Is this a good solution to the problem or is there a better answer we can&#x27;t see?</div>
<div class='msg'><time>2024‑12‑08 04:54</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: Btw, a highly unlikely attack vector, but I&#x27;m still curious if it&#x27;s possible:

For a report to be marked valid, it goes through two checks: first, guaranteeing, and second, auditing.

To pass the guaranteeing stage, we need two guarantors to sign. To pass the auditing stage, we need all 10 randomly selected auditors to give a positive judgment about the report.

Let&#x27;s say one of the guarantors is a malicious actor and tries to bribe their fellow guarantor to sign an invalid report. The bribe would need to be large enough to offset the guarantor&#x27;s potential loss if they are found guilty. Since only one actor needs to accept the risk and the bribe, let&#x27;s assume the other guarantor accepts the bribe.

After guaranteeing, we have to somehow pass the auditing stage. To do this, the attacker sets up an off-chain bribe market offering auditors of this report a deal: if they don&#x27;t announce anything, prove they are auditors of the report, and the invalid report is marked valid, they will receive a huge sum of money.

The auditors face no risk even if they are the only one remaining silent, as they aren&#x27;t passing a positive judgment. If all 10 auditors agree to stay silent and no one announces anything, the report will automatically be marked valid.

What do you think?</div>
<div class='msg'><time>2024‑12‑08 04:55</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Btw, a highly unlikely attack vector, but I&#x27;m still curious if it&#x27;s possible:

For a report to be marked valid, it goes through two checks: first, guaranteeing, and second, auditing.

To pass the guaranteeing stage, we need two guarantors to sign. To pass the auditing stage, we need all 10 randomly selected auditors to give a positive judgment about the report.

Let&#x27;s say one of the guarantors is a malicious actor and tries to bribe their fellow guarantor to sign an invalid report. The bribe would need to be large enough to offset the guarantor&#x27;s potential loss if they are found guilty. Since only one more actor needs to accept the risk and the bribe, let&#x27;s assume the other guarantor accepts the bribe.

After guaranteeing, we have to somehow pass the auditing stage. To do this, the attacker sets up an off-chain bribe market offering auditors of this report a deal: if they don&#x27;t announce anything, prove they are auditors of the report, and the invalid report is marked valid, they will receive a huge sum of money.

The auditors face no risk even if they are the only one remaining silent, as they aren&#x27;t passing a positive judgment. If all 10 auditors agree to stay silent and no one announces anything, the report will automatically be marked valid.

What do you think?</div>
<div class='msg'><time>2024‑12‑08 04:56</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Btw, a highly unlikely attack vector, but I&#x27;m still curious if it&#x27;s possible:

For a report to be marked valid, it goes through two checks: first, guaranteeing, and second, auditing.

To pass the guaranteeing stage, we need two guarantors to sign. To pass the auditing stage, we need all 10 randomly selected auditors to give a positive judgment about the report.

Let&#x27;s say one of the guarantors is a malicious actor and tries to bribe their fellow guarantor to sign an invalid report. The bribe would need to be large enough to offset the guarantor&#x27;s potential loss if they are found guilty. Since only one more actor needs to accept the risk and the bribe, let&#x27;s assume the other guarantor accepts the bribe.

After guaranteeing, we have to somehow pass the auditing stage. To do this, the attacker sets up an off-chain bribe market offering auditors of this report a deal: if all them don&#x27;t announce anything, and prove they are auditors of the report after the invalid report is marked valid, they will receive a huge sum of money.

The auditors face no risk even if they are the only one remaining silent, as they aren&#x27;t passing a positive judgment. If all 10 auditors agree to stay silent and no one announces anything, the report will automatically be marked valid.

What do you think?</div>
<div class='msg'><time>2024‑12‑08 04:57</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Btw, a highly unlikely attack vector, but I&#x27;m still curious if it&#x27;s possible:

For a report to be marked valid, it goes through two checks: first, guaranteeing, and second, auditing.

To pass the guaranteeing stage, we need two guarantors to sign. To pass the auditing stage, we need all 10 randomly selected auditors to give a positive judgment about the report.

Let&#x27;s say one of the guarantors is a malicious actor and tries to bribe their fellow guarantor to sign an invalid report. The bribe would need to be large enough to offset the guarantor&#x27;s potential loss if they are found guilty. Since only one more actor needs to accept the risk and the bribe, let&#x27;s assume the other guarantor accepts the bribe.

After guaranteeing, we have to somehow pass the auditing stage. To do this, the attacker sets up an off-chain bribe market offering auditors of this report a deal: if all them don&#x27;t announce anything, and prove they are auditors of the report after the invalid report is marked valid, they will receive a huge sum of money.

The auditors face no risk even if they are the only one remaining silent, as they aren&#x27;t passing a positive judgment. If all 10 auditors stay silent and no one announces anything, the report will automatically be marked valid.

What do you think?</div>
<div class='msg'><time>2024‑12‑08 04:57</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Btw, a highly unlikely attack vector, but I&#x27;m still curious if it&#x27;s possible:

For a report to be marked valid, it goes through two checks: first, guaranteeing, and second, auditing.

To pass the guaranteeing stage, we need two guarantors to sign. To pass the auditing stage, we need all 10 randomly selected auditors to give a positive judgment about the report.

Let&#x27;s say one of the guarantors is a malicious actor and tries to bribe their fellow guarantor to sign an invalid report. The bribe would need to be large enough to offset the guarantor&#x27;s potential loss if they are found guilty. Since only one more actor needs to accept the risk and the bribe, let&#x27;s assume the other guarantor accepts the bribe.

After guaranteeing, we have to somehow pass the auditing stage. To do this, the attacker sets up an off-chain bribe market offering auditors of this report a deal: if all them don&#x27;t announce anything, and prove they are auditors of the report after the invalid report is marked valid, they will receive a huge sum of money.

The auditors face no risk even if they are the only one remaining silent, as they aren&#x27;t passing a positive judgment. If all 10 auditors stay silent and no one announces anything, the report will automatically be marked valid.

What do you guys think?</div>
<div class='msg'><time>2024‑12‑08 04:59</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Btw, a highly unlikely attack vector, but I&#x27;m still curious if it&#x27;s possible:

For a report to be marked valid, it goes through two checks: first, guaranteeing, and second, auditing.

To pass the guaranteeing stage, we need two guarantors to sign. To pass the auditing stage, we need all 10 randomly selected auditors to give a positive judgment about the report.

Let&#x27;s say one of the guarantors is a malicious actor and tries to bribe their fellow guarantor to sign an invalid report. The bribe would need to be large enough to offset the guarantor&#x27;s potential loss if they are found guilty. Since only one more actor needs to accept the risk and the bribe, let&#x27;s assume the other guarantor accepts the bribe.

After guaranteeing, we have to somehow pass the auditing stage. To do this, the attacker sets up an off-chain bribe market offering auditors of this report a deal: if all them don&#x27;t announce anything, and prove they are auditors of the report after the invalid report is marked valid, they will receive a huge sum of money.

The auditors face no risk even if they are the only one remaining silent, as they aren&#x27;t passing a positive judgment. If all 10 auditors stay silent and no one announces anything, the report will automatically be marked valid.

What do you think?</div>
<div class='msg'><time>2024‑12‑08 05:00</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Btw, a highly unlikely attack vector, but I&#x27;m still curious if it&#x27;s possible:

For a report to be marked valid, it goes through two checks: first, guaranteeing, and second, auditing.

To pass the guaranteeing stage, we need two guarantors to sign. To pass the auditing stage, we need all 10 randomly selected auditors to give a positive judgment about the report.

Let&#x27;s say one of the guarantors is a malicious actor and tries to bribe their fellow guarantor to sign an invalid report. The bribe would need to be large enough to offset the guarantor&#x27;s potential loss if they are found guilty. Since only one more actor needs to accept the risk and the bribe, let&#x27;s assume the other guarantor accepts the bribe.

After guaranteeing, we have to somehow pass the auditing stage. To do this, the attacker sets up an off-chain bribe market offering auditors of this report a deal: if all them don&#x27;t announce anything, and prove they are auditors of the report after the invalid report is marked valid, they will receive a huge sum of money.

The auditors face no risk even if they are the only one remaining silent, as they aren&#x27;t passing a positive judgment. If all 10 auditors stay silent and no one announces anything, the report will automatically be marked valid.
</div>
<div class='msg'><time>2024‑12‑08 05:30</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: A couple of bugs i found in 0.5.2:
- WorkItem new `a` field (accumultionGasLimit) is not taken care in the codec defined in C.26
- A.34 has been changed and `Q` fn in A.32 renamed to `Z` ... yet some parts of graypaper stil report old nomenclature. (paragraph after `sbrk` &amp; A.33)</div>
<div class='msg'><time>2024‑12‑08 08:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; A couple of bugs i found in 0.5.2:
&gt; - WorkItem new `a` field (accumultionGasLimit) is not taken care in the codec defined in C.26
&gt; - A.34 has been changed and `Q` fn in A.32 renamed to `Z` ... yet some parts of graypaper stil report old nomenclature. (paragraph after `sbrk` &amp; A.33)

Thanks will be fixed in next revision</div>
<div class='msg'><time>2024‑12‑08 08:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@amritj:matrix.org&gt; I asked this question in Jam room, not solved there so asking here too:
&gt; 
&gt; Question:
&gt; 
&gt; The segments are erasure-coded and distributed to the validators. Each validator receives a single shard out of the 1,023 shards, determined by their validator index. Therefore, the shard index of the shard they receive equals to their validator index.
&gt; 
&gt; According to the JAMNP protocol, to fetch data from the assurers, we need to provide each assurer with the shard index we require from them.
&gt; 
&gt; The exported segments are expected to remain available for 28 days. During this period, it is assumed that more than 341 validators will remain consistent. However, there is still a significant likelihood that validator indexes may change during this time due to the addition or removal of validators.
&gt; 
&gt; I asked if we have to remember historical validator sets to know who to request shards from, which David Emett  confirmed
&gt; 
&gt; But we are not able to find any way to distribute this data to a new validator added to the network, and without this data he won&#x27;t be able to compute work reports.
&gt; 
&gt; I proposed to not require shard index in the request to fetch data from assurer but assurer himself give us the shard index which we can ofcourse verify is correct or not, so we only need the erasure root and segment index, but as some new validators added to the system if we randomly choose 342 assurers to request data from some of the responses will be empty so either we can request from ~400-500 validators (churn rate as confirmed by sourabhniyogi  is low, so we will most probably receive more than 342 shards) OR somehow store which validators were expected to be active in the requested WR segment epoch by storing status component like we do in preimages in the validator metadata which I am not much sure about
&gt; 
&gt; The above solution is only for new validators, old validators will use the normal method as they know which validators have which shard
&gt; 
&gt; Is this a good solution to the problem or is there a better answer we can&#x27;t see?

We may consider storing historical (28 days worth) of validator keys in state. </div>
<div class='msg'><time>2024‑12‑08 08:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@amritj:matrix.org&gt; Btw, a highly unlikely attack vector, but I&#x27;m still curious if it&#x27;s possible:
&gt; 
&gt; For a report to be marked valid, it goes through two checks: first, guaranteeing, and second, auditing.
&gt; 
&gt; To pass the guaranteeing stage, we need two guarantors to sign. To pass the auditing stage, we need all 10 randomly selected auditors to give a positive judgment about the report.
&gt; 
&gt; Let&#x27;s say one of the guarantors is a malicious actor and tries to bribe their fellow guarantor to sign an invalid report. The bribe would need to be large enough to offset the guarantor&#x27;s potential loss if they are found guilty. Since only one more actor needs to accept the risk and the bribe, let&#x27;s assume the other guarantor accepts the bribe.
&gt; 
&gt; After guaranteeing, we have to somehow pass the auditing stage. To do this, the attacker sets up an off-chain bribe market offering auditors of this report a deal: if all them don&#x27;t announce anything, and prove they are auditors of the report after the invalid report is marked valid, they will receive a huge sum of money.
&gt; 
&gt; The auditors face no risk even if they are the only one remaining silent, as they aren&#x27;t passing a positive judgment. If all 10 auditors stay silent and no one announces anything, the report will automatically be marked valid.
&gt; 

Honest Non-auditors would see the bribe market and realise they can profit by speculatively evaluating the report, finding it is invalid and making the judgement. Once there is a single negative judgement in the system, all validators must audit. </div>
<div class='msg'><time>2024‑12‑08 08:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@amritj:matrix.org&gt; Btw, a highly unlikely attack vector, but I&#x27;m still curious if it&#x27;s possible:
&gt; 
&gt; For a report to be marked valid, it goes through two checks: first, guaranteeing, and second, auditing.
&gt; 
&gt; To pass the guaranteeing stage, we need two guarantors to sign. To pass the auditing stage, we need all 10 randomly selected auditors to give a positive judgment about the report.
&gt; 
&gt; Let&#x27;s say one of the guarantors is a malicious actor and tries to bribe their fellow guarantor to sign an invalid report. The bribe would need to be large enough to offset the guarantor&#x27;s potential loss if they are found guilty. Since only one actor needs to accept the risk and the bribe, let&#x27;s assume the other guarantor accepts the bribe.
&gt; 
&gt; After guaranteeing, we have to somehow pass the auditing stage. To do this, the attacker sets up an off-chain bribe market offering auditors of this report a deal: if they don&#x27;t announce anything, prove they are auditors of the report, and the invalid report is marked valid, they will receive a huge sum of money.
&gt; 
&gt; The auditors face no risk even if they are the only one remaining silent, as they aren&#x27;t passing a positive judgment. If all 10 auditors agree to stay silent and no one announces anything, the report will automatically be marked valid.
&gt; 
&gt; What do you think?

* Honest Non-auditors would see the bribe market and realise they can profit by speculatively evaluating the report, finding it is invalid and making the judgement (honest participants in a dispute get a small reward). Once there is a single negative judgement in the system, all validators must audit. </div>
<div class='msg'><time>2024‑12‑08 08:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@amritj:matrix.org&gt; Btw, a highly unlikely attack vector, but I&#x27;m still curious if it&#x27;s possible:
&gt; 
&gt; For a report to be marked valid, it goes through two checks: first, guaranteeing, and second, auditing.
&gt; 
&gt; To pass the guaranteeing stage, we need two guarantors to sign. To pass the auditing stage, we need all 10 randomly selected auditors to give a positive judgment about the report.
&gt; 
&gt; Let&#x27;s say one of the guarantors is a malicious actor and tries to bribe their fellow guarantor to sign an invalid report. The bribe would need to be large enough to offset the guarantor&#x27;s potential loss if they are found guilty. Since only one actor needs to accept the risk and the bribe, let&#x27;s assume the other guarantor accepts the bribe.
&gt; 
&gt; After guaranteeing, we have to somehow pass the auditing stage. To do this, the attacker sets up an off-chain bribe market offering auditors of this report a deal: if they don&#x27;t announce anything, prove they are auditors of the report, and the invalid report is marked valid, they will receive a huge sum of money.
&gt; 
&gt; The auditors face no risk even if they are the only one remaining silent, as they aren&#x27;t passing a positive judgment. If all 10 auditors agree to stay silent and no one announces anything, the report will automatically be marked valid.
&gt; 
&gt; What do you think?

* Honest Non-auditors would see the bribe market and realise they can profit by speculatively evaluating the report, finding it is invalid and making the judgement (honest participants in a dispute get a small reward). Once there is a single negative judgement in the system, all validators must audit. Expected loss of the guarantors is therefore huge, and it becomes unprofitable. </div>
<div class='msg'><time>2024‑12‑08 08:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@amritj:matrix.org&gt; Btw, a highly unlikely attack vector, but I&#x27;m still curious if it&#x27;s possible:
&gt; 
&gt; For a report to be marked valid, it goes through two checks: first, guaranteeing, and second, auditing.
&gt; 
&gt; To pass the guaranteeing stage, we need two guarantors to sign. To pass the auditing stage, we need all 10 randomly selected auditors to give a positive judgment about the report.
&gt; 
&gt; Let&#x27;s say one of the guarantors is a malicious actor and tries to bribe their fellow guarantor to sign an invalid report. The bribe would need to be large enough to offset the guarantor&#x27;s potential loss if they are found guilty. Since only one actor needs to accept the risk and the bribe, let&#x27;s assume the other guarantor accepts the bribe.
&gt; 
&gt; After guaranteeing, we have to somehow pass the auditing stage. To do this, the attacker sets up an off-chain bribe market offering auditors of this report a deal: if they don&#x27;t announce anything, prove they are auditors of the report, and the invalid report is marked valid, they will receive a huge sum of money.
&gt; 
&gt; The auditors face no risk even if they are the only one remaining silent, as they aren&#x27;t passing a positive judgment. If all 10 auditors agree to stay silent and no one announces anything, the report will automatically be marked valid.
&gt; 
&gt; What do you think?

* Honest Non-auditors would see the bribe market and realise they can profit by speculatively evaluating the report, finding it is invalid and making the judgement (honest participants in a dispute get a small reward). Once there is a single negative judgement in the system, all validators must audit. Expected loss of the guarantors is therefore huge and it becomes (wildly) unprofitable. </div>
<div class='msg'><time>2024‑12‑08 08:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@amritj:matrix.org&gt; Btw, a highly unlikely attack vector, but I&#x27;m still curious if it&#x27;s possible:
&gt; 
&gt; For a report to be marked valid, it goes through two checks: first, guaranteeing, and second, auditing.
&gt; 
&gt; To pass the guaranteeing stage, we need two guarantors to sign. To pass the auditing stage, we need all 10 randomly selected auditors to give a positive judgment about the report.
&gt; 
&gt; Let&#x27;s say one of the guarantors is a malicious actor and tries to bribe their fellow guarantor to sign an invalid report. The bribe would need to be large enough to offset the guarantor&#x27;s potential loss if they are found guilty. Since only one actor needs to accept the risk and the bribe, let&#x27;s assume the other guarantor accepts the bribe.
&gt; 
&gt; After guaranteeing, we have to somehow pass the auditing stage. To do this, the attacker sets up an off-chain bribe market offering auditors of this report a deal: if they don&#x27;t announce anything, prove they are auditors of the report, and the invalid report is marked valid, they will receive a huge sum of money.
&gt; 
&gt; The auditors face no risk even if they are the only one remaining silent, as they aren&#x27;t passing a positive judgment. If all 10 auditors agree to stay silent and no one announces anything, the report will automatically be marked valid.
&gt; 
&gt; What do you think?

* Honest Non-auditors would see the bribe market and realise they can profit by speculatively evaluating the report, finding it is invalid and making the judgement (honest participants in a dispute get a small reward). Once there is a single negative judgement in the system, all validators must audit. Expected loss of the guarantors is therefore huge and it becomes (wildly) unprofitable to attempt the attack. </div>
<div class='msg'><time>2024‑12‑08 09:48</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: Yeah, that&#x27;s the way I thought it will fail, but what if only the auditors of that work report know about the bribe.

One way is after the auditor announce that they are going to audit that report, the attacker may reach all 10 auditors to pass positive judgement.

But in this way, even if auditor is willing to accept the bribe he don&#x27;t know if other will do the same and have huge risk.

But if someone have built the logic to accept the bribe he is not a good auditor, and all these bad auditors can also before announcing everyone about which report they going to audit tell the bribe market about it and if bribe market found 10 such auditors working on same report he may ask them to not send this announcment to everyone and let the report to pass, otherwise everything goes normally, this could go on for years waiting for perfect moment.

Kinda filmy, and highly unlikely

</div>
<div class='msg'><time>2024‑12‑08 09:48</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yeah, that&#x27;s the way I thought it will fail, but what if only the auditors of that work report know about the bribe.

One way is after the auditor announce that they are going to audit that report, the attacker may reach all 10 auditors to pass positive judgement.

But in this way, even if auditor is willing to accept the bribe he don&#x27;t know if other will do the same and have huge risk.

But if someone have built the logic to accept the bribe he is not a good auditor, and all these bad auditors can also before announcing everyone about which report they going to audit tell the bribe market about it and if bribe market found 10 such auditors working on same report he may ask them to not send this announcment to everyone and let the report to pass, otherwise everything goes normally, this could go on for years waiting for perfect moment.

</div>
<div class='msg'><time>2024‑12‑08 09:49</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yeah, that&#x27;s the way I thought it will fail, but what if only the auditors of that work report know about the bribe.

One way is after the auditor announce that they are going to audit that report, the attacker may reach all 10 auditors to pass positive judgement.

But in this way, even if auditor is willing to accept the bribe he don&#x27;t know if other will do the same and have huge risk.

But if someone have built the logic to accept the bribe he is not a good auditor, and all these bad auditors can also before announcing everyone about which report they going to audit tell the bribe market about it and if bribe market found 10 such auditors working on same report he may ask them to not send this announcment to everyone and let the report to pass, otherwise everything goes normally, this could go on for years waiting for perfect moment.

Kinda filmy, and highly unlikely

</div>
<div class='msg'><time>2024‑12‑08 10:00</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: Their can be some hackers that in years injected this kind of virus in some of the validators machines that work in background without validators knowing waiting for perfect chance</div>
<div class='msg'><time>2024‑12‑08 10:02</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Their can be some hackers that in years injected this kind of virus in some of the validators machines that work in background without validators knowing about it, waiting for perfect chance</div>
<div class='msg'><time>2024‑12‑08 10:06</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Their can be some hacker group that in years injected this kind of virus in some of the validators machines that work in background without validators knowing about it, waiting for perfect chance</div>
<div class='msg'><time>2024‑12‑08 10:16</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yeah, that&#x27;s the way I thought it will fail, but what if only the auditors of that work report know about the bribe.

One way is after the auditor announce that they are going to audit that report, the attacker may reach all WR auditors to pass positive judgement.

But in this way, even if auditor is willing to accept the bribe he don&#x27;t know if other will do the same and have huge risk.

But if someone have built the logic to accept the bribe he is not a good auditor, and all these bad auditors can also before announcing everyone about which report they going to audit tell the bribe market about it and if bribe market found 10 such auditors working on same report he may ask them to not send this announcment to everyone and let the report to pass, otherwise everything goes normally, this could go on for years waiting for perfect moment.

Kinda filmy, and highly unlikely</div>
<div class='msg'><time>2024‑12‑08 10:16</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yeah, that&#x27;s the way I thought it will fail, but what if only the auditors of that work report know about the bribe.

One way is after the auditor announce that they are going to audit that report, the attacker may reach all WR auditors to pass positive judgement.

But in this way, even if auditor is willing to accept the bribe he don&#x27;t know if other will do the same and have huge risk.

But if someone have built the logic to accept the bribe he is not a good auditor, and all these bad auditors can also before announcing everyone about which report they going to audit tell the bribe market about it and if bribe market found 30 such auditors working on same report he may ask them to not send this announcment to everyone and let the report to pass, otherwise everything goes normally, this could go on for years waiting for perfect moment.

Kinda filmy, and highly unlikely</div>
<div class='msg'><time>2024‑12‑08 10:17</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yeah, that&#x27;s the way I thought it will fail, but what if only the auditors of that work report know about the bribe.

One way is after the auditor announce that they are going to audit that report, the attacker may reach all WR auditors to pass positive judgement.

But in this way, even if auditor is willing to accept the bribe he don&#x27;t know if other will do the same and have huge risk.

But if someone have built the logic to accept the bribe he is not a good auditor, and all these bad auditors can also before announcing everyone about which report they going to audit tell the bribe market about it and if bribe market found ~30 such auditors working on same report he may ask them to not send this announcment to everyone and let the report to pass, otherwise everything goes normally, this could go on for years waiting for perfect moment.

Kinda filmy, and highly unlikely</div>
<div class='msg'><time>2024‑12‑08 10:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@amritj:matrix.org&gt; Yeah, that&#x27;s the way I thought it will fail, but what if only the auditors of that work report know about the bribe.
&gt; 
&gt; One way is after the auditor announce that they are going to audit that report, the attacker may reach all 10 auditors to pass positive judgement.
&gt; 
&gt; But in this way, even if auditor is willing to accept the bribe he don&#x27;t know if other will do the same and have huge risk.
&gt; 
&gt; But if someone have built the logic to accept the bribe he is not a good auditor, and all these bad auditors can also before announcing everyone about which report they going to audit tell the bribe market about it and if bribe market found 10 such auditors working on same report he may ask them to not send this announcment to everyone and let the report to pass, otherwise everything goes normally, this could go on for years waiting for perfect moment.
&gt; 
&gt; 

It’s a VRF. There’s no way of knowing who is and is not going to announce before they do. </div>
<div class='msg'><time>2024‑12‑08 10:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: And once the announcement happens, then it’s over as the escalation will begin. </div>
<div class='msg'><time>2024‑12‑08 10:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: As the attacker, you would need to know that the auditors were all compromised before committing to guaranteeing the invalid report. And this is impossible as it comes from 1023 VRFs whose entropy is secret. </div>
<div class='msg'><time>2024‑12‑08 10:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * As the attacker, you would need to know that the auditors were all compromised before committing to guaranteeing the invalid report. And this is impossible as it comes from 1023 VRFs whose entropy is secret (because at lease some are not compromised). </div>
<div class='msg'><time>2024‑12‑08 10:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Of course if you knew enough (&gt; 90%) of the validator secret keys you might be able to pull this off with non-negative expected profit, but we already assume &lt;33% compromised nodes. </div>
<div class='msg'><time>2024‑12‑08 10:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@amritj:matrix.org&gt; Yeah, that&#x27;s the way I thought it will fail, but what if only the auditors of that work report know about the bribe.
&gt; 
&gt; One way is after the auditor announce that they are going to audit that report, the attacker may reach all 10 auditors to pass positive judgement.
&gt; 
&gt; But in this way, even if auditor is willing to accept the bribe he don&#x27;t know if other will do the same and have huge risk.
&gt; 
&gt; But if someone have built the logic to accept the bribe he is not a good auditor, and all these bad auditors can also before announcing everyone about which report they going to audit tell the bribe market about it and if bribe market found 10 such auditors working on same report he may ask them to not send this announcment to everyone and let the report to pass, otherwise everything goes normally, this could go on for years waiting for perfect moment.
&gt; 
&gt; Kinda filmy, and highly unlikely
&gt; 
&gt; 

* It’s an independent VRF per validator, stemming from both an on-chain seed and their secret key. There’s no way of knowing which validator will self-select before they announce. </div>
<div class='msg'><time>2024‑12‑08 10:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * And once the announcement happens, then it’s over as the escalation will begin if there’s no audit. </div>
<div class='msg'><time>2024‑12‑08 10:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * And once the announcement happens, then it’s over as the escalation will begin if there’s no judgement. </div>
<div class='msg'><time>2024‑12‑08 10:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Of course if you knew enough (&gt; 98%) of the validator secret keys you might be able to pull this off with non-negative expected profit, but we already assume &lt;33% compromised nodes. </div>
<div class='msg'><time>2024‑12‑08 10:52</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: Yeah, I did calculate the probability, and the chances of all 30 auditors being in the compromised set, even if 33% of the validators are compromised, is 2.01×10^-15.

That&#x27;s extremely low 😅

To have 50% chance 98% validators should be compromised, I think I must work on my math skils</div>
<div class='msg'><time>2024‑12‑08 10:53</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yeah, I did calculate the probability, and the chances of all 30 auditors being in the compromised set, even if 33% of the validators are compromised, is 2.01×10^-15.

That&#x27;s extremely low 

To have ~50% chance ~98% validators should be compromised

I think I must work on my math skils before asking these questions 😅</div>
<div class='msg'><time>2024‑12‑08 10:53</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yeah, I did calculate the probability, and the chances of all 30 auditors being in the compromised set, even if 33% of the validators are compromised, is 2.01×10^-15. That&#x27;s extremely low 

To have ~50% chance ~98% validators should be compromised

I think I must work on my math skils before asking these questions 😅</div>
<div class='msg'><time>2024‑12‑08 10:55</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yeah, I just calculated the probability, and the chances of all 30 auditors being in the compromised set, even if 33% of the validators are compromised, is 2.01×10^-15. That&#x27;s extremely low 

To have ~50% chance ~98% validators should be compromised

I think I must work on my math skils before asking these questions 😅</div>
<div class='msg'><time>2024‑12‑08 10:55</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * Yeah, I calculated the probability, and the chances of all 30 auditors being in the compromised set, even if 33% of the validators are compromised, is 2.01×10^-15. That&#x27;s extremely low 

To have ~50% chance ~98% validators should be compromised

I think I must work on my math skils before asking these questions 😅</div>
<div class='msg'><time>2024‑12‑08 11:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: You don&#x27;t even know how many it is.</div>
<div class='msg'><time>2024‑12‑08 11:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: All you know is that every (honest) validator has a roughly 1/100 chance of self-selecting.</div>
<div class='msg'><time>2024‑12‑08 11:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * All you know is that every (honest) validator has a roughly 1/100 chance of self-selecting for any given core/WR.</div>
<div class='msg'><time>2024‑12‑08 11:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: i.e. ~99% chance of not, so assume that you compromise the secret keys of &gt;90% of validators, that means there&#x27;s still ~100 validators who are honestly self-selecting.</div>
<div class='msg'><time>2024‑12‑08 11:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: the chance that none of them unexpectedly audits your bad WR is therefore 0.99^100</div>
<div class='msg'><time>2024‑12‑08 11:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * the chance that none of them unexpectedly audits your bad WR is therefore 0.99^100 = 36%, so you&#x27;ve around 2/3 chance of being discovered.</div>
<div class='msg'><time>2024‑12‑08 11:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Once discovered, we can expect even the self-interested nodes acting under bribes to act honestly unless they&#x27;re already bribed with the slash amount.</div>
<div class='msg'><time>2024‑12‑08 11:17</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: So you have to totally cover the slash of 2 guarantors (2x 100% stake), probably some of the third guarantor (who would have elevated chances of self-selecting out of spite of being left out of the guaranteeing process), and still have such a great hack that you compromise 90% of the secret keys (which in due course we can assume will be technically impractical owing to multiple implementations and hardware key support) or somehow bribe 90% to voluntarily give up their secret keys knowing that they could get slashed if the secret is misused (e.g. as a guarantor).</div>
<div class='msg'><time>2024‑12‑08 11:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: And even then your attack would need to give you *guaranteed* 2x on that total cost.</div>
<div class='msg'><time>2024‑12‑08 11:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * And even then your attack would need to give you _guaranteed_ 2x revenue on that total cost.</div>
<div class='msg'><time>2024‑12‑08 11:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * And even then your attack would need to give you _guaranteed_ 2x revenue on that total cost just for it to have expected break-even</div>
<div class='msg'><time>2024‑12‑08 11:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: And break-even isn&#x27;t really enough due to gamblers ruin.</div>
<div class='msg'><time>2024‑12‑08 11:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * And break-even isn&#x27;t really enough due to gambler&#x27;s ruin.</div>
<div class='msg'><time>2024‑12‑08 11:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Once discovered, we can expect even the self-interested nodes acting under bribes to act honestly unless they&#x27;re already bribed with the auditor slash amount (~10% of stake).</div>
<div class='msg'><time>2024‑12‑08 11:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * And break-even isn&#x27;t enough due to gambler&#x27;s ruin.</div>
<div class='msg'><time>2024‑12‑08 11:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: In any case I think all these arguments are made in a more rigourous format in the ELVES paper, in case you want to dive deeper into it</div>
<div class='msg'><time>2024‑12‑08 11:28</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: I understand it now, thanks man for answering my dumb questions with such great explanations, really appreciate it.

My mind was stuck that we only need to disrupt the network somehow at that exact time of audit announcement making A_n empty, and pass the audit test

But the amount of validtors required to pull this off is huge, and can only think of only one next to impossible case if more 95% of the validators use the same Internet Provider, and the provider performed a huge targeted attack on the jam protocol validators and stopped their communication at the exact time, not much sure about this too

(reading the ELVES paper now)</div>
<div class='msg'><time>2024‑12‑08 11:28</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * I understand it now, thanks man for answering my dumb questions with such great explanations, really appreciate it.

My mind was stuck that we only need to disrupt the network somehow at that exact time of audit announcement making A\_n empty, and pass the audit test

But the amount of validtors required to pull this off is huge, and can only think of only one next to impossible case if more 95% of the validators use the same Internet Provider, and the provider performed a huge targeted attack on the jam protocol validators and stopped their communication at the exact time, not much sure about this too

(reading the ELVES paper now)</div>
<div class='msg'><time>2024‑12‑08 11:29</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * I understand it now, thanks man for answering my dumb questions with such great explanations, really appreciate it.

My mind was stuck that we only need to disrupt the network between validators somehow at that exact time of audit announcement making A_n empty, and pass the audit test

But the amount of validators required to pull this off is huge, and can only think of only one next to impossible case if more 95% of the validators use the same Internet Provider, and the provider performed a huge targeted attack on the jam protocol validators and stopped their communication at the exact time, not much sure about this too

(reading the ELVES paper now)</div>
<div class='msg'><time>2024‑12‑08 11:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Good that there&#x27;s some effort to comprehend the underlying game theory! Less trust:)</div>
<div class='msg'><time>2024‑12‑08 18:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@amritj:matrix.org&gt; I asked this question in Jam room, not solved there so asking here too:
&gt; 
&gt; Question:
&gt; 
&gt; The segments are erasure-coded and distributed to the validators. Each validator receives a single shard out of the 1,023 shards, determined by their validator index. Therefore, the shard index of the shard they receive equals to their validator index.
&gt; 
&gt; According to the JAMNP protocol, to fetch data from the assurers, we need to provide each assurer with the shard index we require from them.
&gt; 
&gt; The exported segments are expected to remain available for 28 days. During this period, it is assumed that more than 341 validators will remain consistent. However, there is still a significant likelihood that validator indexes may change during this time due to the addition or removal of validators.
&gt; 
&gt; I asked if we have to remember historical validator sets to know who to request shards from, which David Emett  confirmed
&gt; 
&gt; But we are not able to find any way to distribute this data to a new validator added to the network, and without this data he won&#x27;t be able to compute work reports.
&gt; 
&gt; I proposed to not require shard index in the request to fetch data from assurer but assurer himself give us the shard index which we can ofcourse verify is correct or not, so we only need the erasure root and segment index, but as some new validators added to the system if we randomly choose 342 assurers to request data from some of the responses will be empty so either we can request from ~400-500 validators (churn rate as confirmed by sourabhniyogi  is low, so we will most probably receive more than 342 shards) OR somehow store which validators were expected to be active in the requested WR segment epoch by storing status component like we do in preimages in the validator metadata which I am not much sure about
&gt; 
&gt; The above solution is only for new validators, old validators will use the normal method as they know which validators have which shard
&gt; 
&gt; Is this a good solution to the problem or is there a better answer we can&#x27;t see?

David Emett: might have an opinion on this; personally I&#x27;d be tempted to store 28 days worth of historical validator key sets on-chain (full key 336 bytes, 10 validators change per epoch and 4 bytes to redirect to last change = 9 MB), as well as the 28 days of worth of entropy (32 bytes per 6 seconds = 13 MB)</div>
<div class='msg reply'><time>2024‑12‑09 13:24</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Is historical entropy needed? Not clear to me what for. Re historical validator info, my preference was to just expand the epoch mark to include Ed25519 keys and metadata, as this seems simpler (from a spec perspective at least) and the chain history will be required anyway to construct the SR-&gt;ER map</div>
<div class='msg'><time>2024‑12‑08 18:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Then, you can select the shards as desired and find (or cross-reference) the validator&#x27;s info fairly easily.</div>
<div class='msg'><time>2024‑12‑08 18:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; validator indexes may change during this time due to the addition or removal of validators

Index churn is somewhat problematic when considering our current EC reconstruction algorithms. The staking chain would need to be aware of this and enforce index/validator affinity.</div>
<div class='msg'><time>2024‑12‑08 18:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * &gt; validator indexes may change during this time due to the addition or removal of validators

Index churn is somewhat problematic when considering our current EC reconstruction algorithms. The staking chain would need to be aware of this and enforce index-validator affinity, so it wouldn&#x27;t assign a different index to the same validator from hour to hour without good cause.</div>
<div class='msg'><time>2024‑12‑08 19:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; old validators will use the normal method as they know which validators have which shard

Only as long as they know which era/block the segments-root belongs to?</div>
<div class='msg'><time>2024‑12‑08 19:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * &gt; old validators will use the normal method as they know which validators have which shard

Only as long as they know which era/block the segments-root belongs to and they know the validator indices for that time?</div>
<div class='msg'><time>2024‑12‑08 19:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * &gt; old validators will use the normal method as they know which validators have which shard

Only as long as they know which era/block the segments-root belongs to and they know the validator information for that time?</div>
<div class='msg'><time>2024‑12‑09 04:48</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: &gt; &lt;@gav:polkadot.io&gt; &gt; old validators will use the normal method as they know which validators have which shard
&gt; 
&gt; Only as long as they know which era/block the segments-root belongs to and they know the validator information for that time?

Yeah, old validators need to maintain a mapping for historical validators.

And new validators can easily too if they fetch historical validator set data from other nodes and verify it with epoch mark</div>
<div class='msg'><time>2024‑12‑09 04:48</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: * Yeah, old validators need to maintain a mapping for historical validators.
And new validators can now easily too if they can fetch historical validator set data from other nodes and verify it with epoch mark
</div>
<div class='msg'><time>2024‑12‑09 15:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yup sounds sensible. </div>
<div class='msg'><time>2024‑12‑10 16:37</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: </div>
<div class='msg'><time>2024‑12‑11 20:57</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: I have a doubt about this formula: 
(7.2) β† ≡ β except β†[|β| − 1]s = Hr

What is the correct interpretation:
1) β† is a copy of β except that in the last element of β† we replace s for the value of Hr
2) β† a copy of β only if the value of s in the last element is equal to Hr, otherwise β† is nil 


https://graypaper.fluffylabs.dev/#/5b732de/0fd5010fde01</div>
<div class='msg reply'><time>2024‑12‑11 20:58</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Choice 1 :) </div>
<div class='msg reply'><time>2024‑12‑11 20:58</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: 1</div>
<div class='msg reply'><time>2024‑12‑11 20:59</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: It&#x27;s just putting the correct state root in for the last block, which will be 0 in beta (prior state)</div>
<div class='msg reply'><time>2024‑12‑11 21:00</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: So, in this case, wouldn&#x27;t be more correct to put β†[|β| − 1]s ≡ Hr</div>
<div class='msg reply'><time>2024‑12‑11 21:02</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: and then comes another question: in report vectors, the prior_state_root (Hr) is not informed in the header, which means they are null. Should I replace the existing vale with null? Because the vectors post_state don&#x27;t do this</div>
<div class='msg reply'><time>2024‑12‑11 21:06</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: I don&#x27;t understand the second part of the question regarding reports. Can you tell which equations you&#x27;re refering to ?</div>
<div class='msg reply'><time>2024‑12‑11 21:11</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Eq. 7.2, 7.3 and 7.3
</div>
<div class='msg reply'><time>2024‑12‑11 21:11</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: more specifically 7.2</div>
<div class='msg reply'><time>2024‑12‑11 21:12</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: If I have to replace  β† last element, Hr should not be null in the vector. </div>
<div class='msg reply'><time>2024‑12‑11 21:14</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Hr is not null,
But beta[|beta|-1] is null (more specifically 32 bytes of zeros)</div>
<div class='msg reply'><time>2024‑12‑11 21:16</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: where is Hr informed in vector? </div>
<div class='msg reply'><time>2024‑12‑11 21:18</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: In vector ? Hr is a header</div>
<div class='msg reply'><time>2024‑12‑11 21:19</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: No, H is header.</div>
<div class='msg reply'><time>2024‑12‑11 21:19</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Hr is the header prior state root </div>
<div class='msg reply'><time>2024‑12‑11 21:29</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Yeah, I wasn&#x27;t super precise but yeah Hr is part of the header</div>
<div class='msg reply'><time>2024‑12‑11 21:29</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: My interpretation is:
1) take the last element of history and put the Hr on s (which was zero in the last iteration) (7.2)
2) create a new element for history (7.3)
3) add this newly created element in the end of the list, removing the first element if the list is bigger then Constant H
</div>
<div class='msg reply'><time>2024‑12‑11 21:30</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Yes that&#x27;s how we interpret it as well</div>
<div class='msg reply'><time>2024‑12‑11 21:32</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: actually, my main doubt is: are these vectors affecting the recent history state component? I think they are not</div>
<div class='msg reply'><time>2024‑12‑11 21:33</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: I have the same question for the authorizer pool (I think someone already asked this, I didn&#x27;t see the answer)</div>
<div class='msg reply'><time>2024‑12‑11 21:35</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: My local tests were not passing because I was trying to match my post state recent history with the ones in the vectors, which actually are not correct, they are supposed to be ignored in these tests</div>
<div class='msg reply'><time>2024‑12‑11 21:48</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@danicuki:matrix.org&gt; actually, my main doubt is: are these vectors affecting the recent history state component? I think they are not

No. Recent block hostory last block state root is mutated by the recent block history STF. </div>
<div class='msg reply'><time>2024‑12‑11 21:49</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@danicuki:matrix.org&gt; I have the same question for the authorizer pool (I think someone already asked this, I didn&#x27;t see the answer)

Authorizer pool is now mutated by the &quot;authorizers&quot; STF. Vectors not published yet. </div>
<div class='msg reply'><time>2024‑12‑11 21:50</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: But I see authorizers (alpha) being changed in reports vectors, no?</div>
<div class='msg'><time>2024‑12‑11 20:58</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>:  * I have a doubt about this formula:
(7.2) β† ≡ β except β†\[|β| − 1\]s = Hr

What is the correct interpretation:

1. β† is a copy of β except that in the last element of β† we replace s for the value of Hr
2. β† is a copy of β only if the value of s in the last element is equal to Hr, otherwise β† is nil

https://graypaper.fluffylabs.dev/#/5b732de/0fd5010fde01</div>
<div class='msg'><time>2024‑12‑11 21:00</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>:  * So, in this case, wouldn&#x27;t be more precise to put β†\[|β| − 1\]s ≡ Hr</div>
<div class='msg'><time>2024‑12‑11 21:29</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>:  * My interpretation is:

1. take the last element of history and put the Hr on s (which was zero in the last iteration) (7.2)
2. create a new element for history (7.3)
3. add this newly created element in the end of the list, removing the first element if the list is bigger then Constant H (7.3)</div>
<div class='msg'><time>2024‑12‑11 21:50</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: Not anymore</div>
<div class='msg'><time>2024‑12‑11 21:50</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: https://github.com/w3f/jamtestvectors/pull/28#issuecomment-2535451326</div>
<div class='msg'><time>2024‑12‑11 21:51</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: * No. Recent block history last block state root is mutated by the recent block history STF.</div>
<div class='msg'><time>2024‑12‑11 22:11</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: </div>
<div class='msg'><time>2024‑12‑11 22:12</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * I think the work report&#x27;s authoriser_hash is removed from the authoriser pool when it is placed on the core.</div>
<div class='msg'><time>2024‑12‑11 22:13</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * I think the work report&#x27;s authorizer_hashis removed from the authoriser pool when it is placed on the core.</div>
<div class='msg'><time>2024‑12‑11 22:13</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * I think the work report&#x27;s authorizer\_hash is removed from the authoriser pool when it is placed on the core.</div>
<div class='msg'><time>2024‑12‑11 22:16</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * I think the work report&#x27;s authorizer\_hash is removed from the authoriser pool when it is placed on the core. https://graypaper.fluffylabs.dev/#/911af30/10b50010ba00</div>
<div class='msg'><time>2024‑12‑11 22:17</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * The work report&#x27;s authorizer\_hash is removed from the authoriser pool when it is placed on the core. https://graypaper.fluffylabs.dev/#/911af30/10b50010ba00</div>
<div class='msg'><time>2024‑12‑11 22:17</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>:  * The work report&#x27;s authorizer\_hash is removed from the authorizer pool when it is placed on the core. https://graypaper.fluffylabs.dev/#/911af30/10b50010ba00</div>
<div class='msg'><time>2024‑12‑12 04:31</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: </div>
<div class='msg'><time>2024‑12‑15 18:20</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: We are removing the starting 1 bit from the left sub-trie identity

https://graypaper.fluffylabs.dev/#/5b732de/37ab0237af02

But as this is a hash, we don&#x27;t know exactly if the starting bit of the left sub-trie identity will be 0 or 1.

So, how do we decode this hash value? Maybe I am missing something here

</div>
<div class='msg reply'><time>2024‑12‑15 18:43</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Not sure what you mean by decode? This stuff is for calculating the state root from the state, which is a one-way operation</div>
<div class='msg reply'><time>2024‑12‑15 19:32</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: Ohk, clear!</div>
<div class='msg'><time>2024‑12‑15 18:20</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * We are removing the starting 1 bit from the left sub-trie identity

https://graypaper.fluffylabs.dev/#/5b732de/37ab0237af02

But as this is a hash, we don&#x27;t know exactly if the starting bit of the left sub-trie identity will be 0 or 1.

So, how do we decode this hash value? What am I missing something here?

</div>
<div class='msg'><time>2024‑12‑15 18:21</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>:  * We are removing the starting 1 bit from the left sub-trie identity

https://graypaper.fluffylabs.dev/#/5b732de/37ab0237af02

But as this is a hash, we don&#x27;t know exactly if the starting bit of the left sub-trie identity will be 0 or 1.

So, how do we decode this hash value? What am I missing here?

</div>
<div class='msg'><time>2024‑12‑16 21:50</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: Is there a target date for having version 1.0 of the GP ready?</div>
<div class='msg'><time>2024‑12‑16 22:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: April 14tg</div>
<div class='msg reply'><time>2024‑12‑16 22:22</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: Thank you. I’m assuming M1 submissions can’t be before this date then? Or will the conformance tool come before this?</div>
<div class='msg reply'><time>2024‑12‑16 22:40</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: We have moved onto M2 work for JavaJAM until then.</div>
<div class='msg reply'><time>2024‑12‑17 08:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@jaymansfield:matrix.org&gt; Thank you. I’m assuming M1 submissions can’t be before this date then? Or will the conformance tool come before this?

Correct. From the published rules:

&gt; Prizes are paid no earlier than the ratification by the Polkadot Fellowship of version 1.0 of the JAM protocol. Payment of the prize by the Web3.0 Foundation is conditional upon the successful completion of all KYC/AML processes</div>
<div class='msg'><time>2024‑12‑16 22:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * April 14th</div>
<div class='msg'><time>2024‑12‑16 23:05</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: Suggestion for an inconsistency fix in the designate host function.
PR: https://github.com/gavofyork/graypaper/pull/166
(GP: https://graypaper.fluffylabs.dev/#/5b732de/306401306401)
</div>
<div class='msg'><time>2024‑12‑17 20:27</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: Following my comment https://github.com/w3f/jamtestvectors/pull/14#issuecomment-2549423040 and discussion started in jam chat i think it would be better if `D.4` is being changed to take into account the last 6 digits of |v| instead of the first 6. </div>
<div class='msg'><time>2024‑12‑17 21:00</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: * Following my comment https://github.com/w3f/jamtestvectors/pull/14#issuecomment-2549423040 and discussion started in jam chat i think it would be better if `D.4` is being changed to take into account the last 6 bits of |v| instead of the first 6.</div>
<div class='msg'><time>2024‑12‑18 00:54</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I am a bit confused about what is a work package bundle. I can&#x27;t find a formal definition of it</div>
<div class='msg'><time>2024‑12‑18 00:54</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: </div>
<div class='msg'><time>2024‑12‑18 00:58</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: https://graypaper.fluffylabs.dev/#/5b732de/1b9d001b9f00 this have a description of it, but it leaves some ambiguity of the encoding format. e.g. how exactly are the extrinsic data and the proofs are encoded?</div>
<div class='msg reply'><time>2024‑12‑18 01:03</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: https://graypaper.fluffylabs.dev/#/5b732de/1b5d001b5d00</div>
<div class='msg reply'><time>2024‑12‑18 01:05</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: The bundle is the second argument to A</div>
<div class='msg reply'><time>2024‑12‑18 01:06</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I see. Thanks. It will be better if it is bit more explicit </div>
<div class='msg reply'><time>2024‑12‑18 01:07</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Agree that would be nice</div>
<div class='msg'><time>2024‑12‑18 14:58</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: davxy afk: since youre the bandernatch god :) I have a question... `Hs` has a direct dependency on `Hv` which is included in the `context` to sign includes `Hv` as last element. (6.16 and 6.15)

`Hv` seems to also depend on `Hs` well.. it depends on `Y(Hs)` (see 6.17) . While i know it needs to match the ticket in case we&#x27;re not in fallback mode, i believe there is some cryptography magic i didnt fully understand to know what `Y(Hs)` would be without really having Hs.... otherwise we would have a circular dependency </div>
<div class='msg'><time>2024‑12‑18 14:58</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: * davxy afk: since youre the bandernatch god :) I have a question... `Hs` has a direct dependency on `Hv` which is included in the `context` to sign includes `Hv` as last element. (6.16 and 6.15)

`Hv` seems to also depend on `Hs`.... well.. it depends on `Y(Hs)` (see 6.17) . While i know it needs to match the ticket in case we&#x27;re not in fallback mode, i believe there is some cryptography magic i didnt fully understand to know what `Y(Hs)` would be without really having Hs.... otherwise we would have a circular dependency</div>
<div class='msg'><time>2024‑12‑18 15:01</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: If i understand properly this magic should be using `G.4` with same message, privkey and empty context to get a RingVRF proof on which i could then apply G.5 and get the same result</div>
<div class='msg'><time>2024‑12‑18 15:02</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: * If i understand properly this magic should be using `G.4` with same message, privkey and **empty context** to get a RingVRF proof on which i could then apply G.5 and get the same result</div>
<div class='msg'><time>2024‑12‑18 15:10</time>&ensp;<span class='u' style='color:#79ca84'>alxmirap</span>: I may be able to answer that, I believe. The encoding in equations 6.15/6.16 uses the function \Epsilon_U(H), defined in Appendix C as being the full \Epsilon(H) without the H_s term (equations C.19 and C.20).

I believe this encoding function was created precisely for the case of omitting this field to avoid the circular dependency.</div>
<div class='msg'><time>2024‑12‑18 15:13</time>&ensp;<span class='u' style='color:#79ca84'>alxmirap</span>: This function is introduced in section 5, just before Eq 5.1.</div>
<div class='msg'><time>2024‑12‑18 15:20</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: The VRF output is independent of the additional context, so there isn&#x27;t really a circular dependency</div>
<div class='msg'><time>2024‑12‑18 15:21</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: i think i didnt explain myself

- \Epsilon_U(H) contains `Hv`
- `Hs` uses \Epsilon_U(H)
- `Hv` uses `Y(Hs)`

</div>
<div class='msg reply'><time>2024‑12‑18 17:37</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Not sure but this might help https://github.com/jam-duna/jamtestnet/issues/21</div>
<div class='msg'><time>2024‑12‑18 15:21</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: perfect</div>
<div class='msg'><time>2024‑12‑18 15:26</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: FWIW I just added this
https://github.com/davxy/bandersnatch-vrfs-spec/blob/bdd1f4b7ccbad9227dc28c72660d438cf00b1b33/assets/example/src/main.rs#L298-L300</div>
<div class='msg'><time>2024‑12‑18 15:27</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: But you&#x27;ve got already your answer ^</div>
<div class='msg'><time>2024‑12‑18 18:12</time>&ensp;<span class='u' style='color:#788ad5'>yu2c</span>: Hello, question here : 
[\mathbb{H}^0](https://graypaper.fluffylabs.dev/#/5b732de/377b02377c02)  = [0]_32 in Ch3.8.1 called &quot;zero-hash&quot;
However, [\mathbb{H}_0](https://graypaper.fluffylabs.dev/#/5b732de/391200391200) called &quot;zero hash&quot;
Is there any difference between these terms? 
Does &quot;zero hash&quot; also refer to [0]_32 or does it take 0 as input of hash func?</div>
<div class='msg'><time>2024‑12‑18 21:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: “Zero hash” just means [0,0,0,…]_{…32}</div>
<div class='msg'><time>2024‑12‑18 21:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Both terms are equivalent in meaning but one is a typo and will be corrected. </div>
<div class='msg'><time>2024‑12‑18 21:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Both terms are equivalent in meaning but one is a typo and will be corrected to the other. For now please treat them as equal. </div>
<div class='msg'><time>2024‑12‑18 22:55</time>&ensp;<span class='u' style='color:#bc4a3e'>basedafdev</span>: In appendix D.2, the state serialization spec for $ \pi $ is a bit ambiguous to me. \pi is defined as a tuple of prior stats for all validators, and current stats for all validators, how is E_4(\pi) possible? </div>
<div class='msg'><time>2024‑12‑19 00:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It just means that they should each be encoded with 4 bytes. </div>
<div class='msg'><time>2024‑12‑19 00:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: But yeah I can look into reformulating this as someone else had a similar query. </div>
<div class='msg'><time>2024‑12‑19 09:23</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: in accumulate host function (Appendix B), the transfer function:

https://graypaper.fluffylabs.dev/#/5b732de/311401311401


the &quot;otherwise if ϱ &lt; g &quot; branch
does the g here refer the g = value of register #9
or g = 10 + ω8 + 232 ⋅ ω9 the gas cost?
Thanks :)

</div>
<div class='msg'><time>2024‑12‑19 09:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It is the g of the same column. </div>
<div class='msg reply'><time>2024‑12‑19 13:29</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: OK then i must be missing something
g (of the same column) is w9
g (gas cost) = 10 + ω8 + 232 ⋅ ω9 (clearly bigger then w9)
so :
if Q &lt; w9 (the case to return HIGH) =&gt; Q &lt; g(gas cost) =&gt; not enough gas =&gt; fallback to Eq. B.20 =&gt; registers unchanged
so we can never get w7&#x27; = HIGH </div>
<div class='msg'><time>2024‑12‑19 13:30</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: * OK then i must be missing something
g (of the same column) is w9
g (gas cost) = 10 + ω8 + 2^32 ⋅ ω9 (clearly bigger then w9)
so :
if Q \&lt; w9 (the case to return HIGH) =&gt; Q \&lt; g(gas cost) =&gt; not enough gas =&gt; fallback to Eq. B.20 =&gt; registers unchanged
so we can never get w7&#x27; = HIGH </div>
<div class='msg'><time>2024‑12‑19 13:31</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: * OK then i must be missing something
g (of the same column) is w9

g (gas cost) = 10 + ω8 + 2^32 ⋅ ω9 (clearly bigger then w9)

so :
if Q &lt; w9 (the case to return HIGH) =&gt; Q &lt; g(gas cost) =&gt; not enough gas =&gt; fallback to Eq. B.20 =&gt; registers unchanged
so we can never get w7&#x27; = HIGH</div>
<div class='msg'><time>2024‑12‑19 19:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The gas cost for transfer is only a placeholder. I’ll make it more sensible soon. </div>
<div class='msg'><time>2024‑12‑19 19:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: But the g it is referring to is not the instruction gas cost on the left but the let expression above. </div>
<div class='msg'><time>2024‑12‑19 19:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I’ll also change the term used. </div>
<div class='msg'><time>2024‑12‑20 09:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: @room Version 0.5.3 is [released](https://github.com/gavofyork/graypaper/releases/tag/v0.5.3), containing quite a few corrections and clarifications.</div>
<div class='msg'><time>2024‑12‑20 09:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * @room Version 0.5.3 is [released](https://github.com/gavofyork/graypaper/releases/tag/v0.5.3), containing quite a few corrections and clarifications. No really major changes this time, though we now have *active removal of reports on timeout*.</div>
<div class='msg'><time>2024‑12‑21 18:53</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: Screenshot 2024-12-22 at 01.53.11.png</div>
<div class='msg'><time>2024‑12‑21 18:54</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: What about change the `a_l` here to `a_o`, it looks too similar to `a_\mathbf{l}`</div>
<div class='msg'><time>2024‑12‑21 18:55</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * 9.3 Account Footprint and Threshold Balance - formula (9.8)

What about change the `a_l` here to `a_o`, it looks too similar to `a_\mathbf{l}`</div>
<div class='msg'><time>2024‑12‑21 18:56</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * **9.3 Account Footprint and Threshold Balance - formula (9.8)**

What about change the `a_l` here to `a_o`, it looks too similar to `a_\mathbf{l}`</div>
<div class='msg'><time>2024‑12‑21 18:58</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * **9.3 Account Footprint and Threshold Balance - formula (9.8)**

What about changing the `a_l` here to `a_o`, it looks too similar to `a_\mathbf{l}`</div>
<div class='msg'><time>2024‑12‑21 19:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Feel free to make a PR :)</div>
<div class='msg'><time>2024‑12‑21 19:50</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: When we refer to JAM&#x27;s DA capabilities, does that refer to the preimages (supported by accumulate host functions solicit/forget) as well as the ImportDA + AuditDA (supported by refine host functions import/export), or only the latter?  

For rollups utilizing JAM to store blocks and headers, should they be using one or the other or both in design intended for max scalability for a whole ecosystem (e.g. OP Stack)?  </div>
<div class='msg'><time>2024‑12‑21 19:50</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * When we refer to JAM&#x27;s DA capabilities, does that refer to the preimages (supported by accumulate host functions solicit/forget) as well as the ImportDA + AuditDA (supported by refine host functions import/export), or only the latter?  

For rollups utilizing JAM to store blocks and headers, should they be using one or the other or both in designs intended for max scalability for a whole ecosystem (e.g. OP Stack)?  </div>
<div class='msg'><time>2024‑12‑21 20:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Only the latter. </div>
<div class='msg'><time>2024‑12‑22 08:57</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: https://github.com/gavofyork/graypaper/pull/174

please review</div>
<div class='msg'><time>2024‑12‑22 09:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Reviewed</div>
<div class='msg'><time>2024‑12‑22 17:05</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: &gt; &lt;@gav:polkadot.io&gt; Only the latter. 

Which system is core chains going to write blocks and headers to ?  </div>
<div class='msg'><time>2024‑12‑22 17:34</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: &gt; &lt;@gav:polkadot.io&gt; Only the latter. 

 * Which system is the CoreChains service going to write blocks and headers to ?</div>
<div class='msg'><time>2024‑12‑22 18:40</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Which system is the CoreChains service going to write blocks and headers to ?  For zk rollup ecosystems using JAM DA vs preimages, where should proofs be stored?</div>
<div class='msg'><time>2024‑12‑22 18:41</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>:  * Which system is the CoreChains service going to write blocks and headers to ?  For zk rollup ecosystems using JAM DA vs preimages, where should proofs be stored -- is there a design judgment on this that should emulate that of the CoreChains service?</div>
<div class='msg'><time>2024‑12‑22 20:05</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: If I am building it, blocks will just be the body of work item, headers stored in server storage, parachain code blob in preimage, chain state in DA</div>
<div class='msg'><time>2024‑12‑22 20:06</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: * If I am building it, blocks will just be the body of work item, headers stored in service storage, parachain code blob in preimage, chain state in DA</div>
<div class='msg'><time>2024‑12‑22 20:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; Which system is the CoreChains service going to write blocks and headers to ?  For zk rollup ecosystems using JAM DA vs preimages, where should proofs be stored -- is there a design judgment on this that should emulate that of the CoreChains service?

Feel free to design your services exactly as you want. </div>
<div class='msg'><time>2024‑12‑26 13:51</time>&ensp;<span class='u' style='color:#788ad5'>yu2c</span>: Hello, I have a question about the structure of recent history $beta$, in the GP [(7.1)](https://graypaper.fluffylabs.dev/#/5b732de/0fb6010fca01) is (header hash, accumulation-result MMR, state root, work-report dict.), however in [(7.3)](https://graypaper.fluffylabs.dev/#/5b732de/0f41020f6c02) the item $n$ is (work-report dict., header hash, accumulation-result MMR, state root).
The order seems inconsistent. Which one should I follow? I assume this is a tuple, so the order is important for implementation because they will concat. at the end</div>
<div class='msg'><time>2024‑12‑26 15:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Tuple item order is irrelevant. It only matters for serialisation and that it well-defined in the appendix. </div>
<div class='msg'><time>2024‑12‑26 16:19</time>&ensp;<span class='u' style='color:#788ad5'>yu2c</span>: Oh, I see~ Thank for reply</div>
<div class='msg'><time>2024‑12‑26 20:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Tuple item order is irrelevant. It only matters for serialisation and that is well-defined in the appendix. </div>
<div class='msg'><time>2024‑12‑28 18:56</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: Was it intentional that CE-130 was skipped in the networking specs?</div>
<div class='msg'><time>2024‑12‑29 07:06</time>&ensp;<span class='u' style='color:#d27e2d'>sisco0</span>: In the graypaper, it is stated that &quot;Size-Synchrony Antagonism&quot; is not a known concept under literature. However, the following concepts might be related: CAP Theorem, Blockchain Trilemma ([Link](https://www.mdpi.com/2076-3417/15/1/19)). Would not the &quot;Size-Synchrony Antagonism&quot; term be part of any of the cited ones?</div>
<div class='msg'><time>2024‑12‑29 07:15</time>&ensp;<span class='u' style='color:#d27e2d'>sisco0</span>: * In the graypaper, it is stated that &quot;Size-Synchrony Antagonism&quot; is not a known concept under literature. However, the following concepts might be related: CAP Theorem, Blockchain Trilemma ([Link](https://www.mdpi.com/2076-3417/15/1/19)). Would not the &quot;Size-Synchrony Antagonism&quot; term be part of any of the cited ones?

Citing the graypaper:
Size-coherency antagonism is a simple principle implying
 that as the state-space of information systems grow, then
 the system necessarily becomes less coherent.

Citing the Blockchain Trilemma research paper:
1. Adding more nodes increases communication overhead
2. As 𝑁 increases, 𝐿 grows at least logarithmically, potentially linearly or quadratically, depending on protocol specifics.</div>
<div class='msg'><time>2024‑12‑29 07:18</time>&ensp;<span class='u' style='color:#d27e2d'>sisco0</span>: * In the graypaper, it is stated that &quot;Size-Synchrony Antagonism&quot; is not a known concept under literature. However, the following concepts might be related: CAP Theorem, Blockchain Trilemma ([Link](https://www.mdpi.com/2076-3417/15/1/19)). Would not the &quot;Size-Synchrony Antagonism&quot; term be part of any of the cited ones?

Citing the Blockchain Trilemma research paper:

1. Adding more nodes increases communication overhead
2. As 𝑁 increases, 𝐿 grows at least logarithmically, potentially linearly or quadratically, depending on protocol specifics.</div>
<div class='msg'><time>2024‑12‑29 08:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: CAP theorem comes close since what it calls “consistency”is similar in nature to what i termed “coherency” however it doesn’t conceptualise the size of the system. </div>
<div class='msg'><time>2024‑12‑29 08:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The blockchain trilemma does conceptualise the size of the system but does not involve the coherency at all. </div>
<div class='msg'><time>2024‑12‑29 08:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * The blockchain trilemma does conceptualise the size of the system but does not involve the coherency at all. It simply states that as a system grows then it becomes either centralised or insecure. </div>
<div class='msg'><time>2024‑12‑29 08:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * The blockchain trilemma does conceptualise the size of the system but does not involve the coherency at all. It simply states that as a (blockchain) system grows then it becomes either centralised or insecure. </div>
<div class='msg'><time>2024‑12‑29 08:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * CAP theorem comes close since what it calls “consistency”is similar in nature to what i termed “coherency” however it doesn’t conceptualise the size of the system directly, instead going for antagonist concepts “availability” and “partition-tolerance”. As such I’d argue CAP theorem is a more concrete (and binary) trilemma on specifically replicated data systems.</div>
<div class='msg'><time>2024‑12‑29 08:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * The blockchain trilemma does conceptualise the size of the system but does not involve the coherency at all. It simply states that as a (blockchain) system scales then it becomes either centralised or insecure. This trilemma implicitly assumes total coherence. </div>
<div class='msg'><time>2024‑12‑29 08:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * CAP theorem comes closer since what it calls “consistency”is similar in nature to what i termed “coherency”. However each of its three concepts are binary conditions and the proof simply states that no system can fulfill all three. Furthermore it doesn’t conceptualise the size of the system directly (how could it under a binary condition?), instead going for antagonist concepts “availability” and “partition-tolerance”. As such I’d argue CAP theorem is a more concrete trilemma on specifically replicated data systems.</div>
<div class='msg'><time>2024‑12‑30 04:01</time>&ensp;<span class='u' style='color:#788ad5'>yu2c</span>: Sorry, I&#x27;m a bit confused about the definition of serialization of guarantee extrinsic $Eg$.
In GP [5.6](https://graypaper.fluffylabs.dev/#/6e1c0cd/0ce0000cf200), $\mathbf{g}$ is defined
However, in appendix [C.16](https://graypaper.fluffylabs.dev/#/6e1c0cd/36870036ab00), there&#x27;s already a definition for the serialization of $Eg$.
Is $\mathbf{g}$ specifically defined for $H_x$? Or which definition should we follow? Thanks</div>
<div class='msg'><time>2024‑12‑30 07:51</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: As of now 2 different serializations are needed in 2 different contexts </div>
<div class='msg'><time>2024‑12‑30 20:53</time>&ensp;<span class='u' style='color:#7875cf'>charliewinston14</span>: Question about CE-137. In the specs a bundle shard is defined as [u8]. Is there a fixed size for them? There is no reference to a &quot;bundle shard&quot; in the GP itself and not sure if it goes by a different name in it.</div>
<div class='msg reply'><time>2024‑12‑31 11:57</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: A bundle shard is one of the pieces you get back after erasure coding a WP bundle. Size is not fixed as it depends on the size of the original bundle</div>
<div class='msg'><time>2024‑12‑31 09:58</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: a doubt about the encoding of service storage and pre-image lookups in D.2:
https://graypaper.fluffylabs.dev/#/6e1c0cd/373302377802


if i am reading this correctly, after encoding it would be impossible to reconstruct the original hash keys when decoding


    ∀(s ↦ a) ∈ δ, (k ↦ v) ∈ as ∶ C(s, E4(232 − 1) ⌢ k0...28) ↦ v 


am i missing something?


thank you and a happy new year 


</div>
<div class='msg'><time>2024‑12‑31 10:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@luke_fishman:matrix.org&gt; a doubt about the encoding of service storage and pre-image lookups in D.2:
&gt; https://graypaper.fluffylabs.dev/#/6e1c0cd/373302377802
&gt; 
&gt; 
&gt; if i am reading this correctly, after encoding it would be impossible to reconstruct the original hash keys when decoding
&gt; 
&gt; 
&gt;     ∀(s ↦ a) ∈ δ, (k ↦ v) ∈ as ∶ C(s, E4(232 − 1) ⌢ k0...28) ↦ v 
&gt; 
&gt; 
&gt; am i missing something?
&gt; 
&gt; 
&gt; thank you and a happy new year 
&gt; 
&gt; 
&gt; 

You’re not missing anything. HNY:)</div>
<div class='msg'><time>2024‑12‑31 10:03</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: and this is intended? decode(encode(service_account) != service_account</div>
<div class='msg'><time>2024‑12‑31 10:04</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: * and this is intended? `decode(encode(service\_account) != service\_account`</div>
<div class='msg'><time>2024‑12‑31 10:04</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: * and this is intended? decode(encode(service\_account) != service\_account</div>
<div class='msg'><time>2024‑12‑31 10:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Are you implying you believe that is true?</div>
<div class='msg'><time>2024‑12‑31 10:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Obviously, since decode is defined only as the inverse of encode, that is not true unless service account has more degrees of freedom than its encoding. This should not be the case. </div>
<div class='msg'><time>2024‑12‑31 10:10</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: right, obviously should not be the case.
but you have confirmed above the i am not missing anything -&gt; impossible to reconstruct the hash keys of storage dictionary s, preimage lookup dictionaries p and l.

so... here i get stuck? where is the missing information to allow to reconstruct those hashes?</div>
<div class='msg'><time>2024‑12‑31 10:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: the mappings are not serialised directly. </div>
<div class='msg'><time>2024‑12‑31 10:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * the mappings are not serialised alongside the rest of the service account. </div>
<div class='msg'><time>2024‑12‑31 10:14</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: They’d be too big for that. </div>
<div class='msg'><time>2024‑12‑31 10:17</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The trie root is a commitment to them. In the protocol there’s no facility or direct need to enumerate the keys thus no need to actually store them, only to be able to query them. It’s basically up to the implementation exactly how they’re stored, but good ones will need to take into account the commitment scheme (ie trie) when designing for it. </div>
<div class='msg'><time>2024‑12‑31 10:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * The trie root is a commitment to them. In the protocol there’s no facility or direct need to enumerate the mappings’ keys thus no need to actually store them, only to be able to query them. It’s basically up to the implementation exactly how they’re stored, but good ones will need to take into account the commitment scheme (ie trie) when designing for it. </div>
<div class='msg'><time>2024‑12‑31 10:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: [@arkadiy:parity.io](https://matrix.to/#/@arkadiy:parity.io)might be able to offer more hints as to how implementers might approach the database/trie layer. </div>
<div class='msg'><time>2024‑12‑31 10:33</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: ok. Thank you Gavin. Happy New Year</div>
<div class='msg'><time>2025‑01‑02 05:31</time>&ensp;<span class='u' style='color:#30c84d'>clw0908</span>: some questions about the following opcodes:  
135:  
https://graypaper.fluffylabs.dev/#/6e1c0cd/27d70327e303  
Since **vx** belongs to **N64**, should **vx** be mod 2^32 to ensure the input of **X4** won&#x27;t overflow?  

136:  
https://graypaper.fluffylabs.dev/#/6e1c0cd/27f30327fc03  
Since **vx** belongs to **N64**, should **Z4(vx)** be replaced by **Z8(vx)**?  </div>
<div class='msg'><time>2025‑01‑02 10:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 135: v_x belongs to N_32 - it’s constructed from at most 4 octets from the instruction data. </div>
<div class='msg'><time>2025‑01‑02 10:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * v_x belongs to N_32 - it’s constructed from at most 4 octets from the instruction data. </div>
<div class='msg'><time>2025‑01‑02 10:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * v_x belongs to N_32 - it’s constructed from at most 4 octets from the instruction data. (l_x is `min(…, 4)`)</div>
<div class='msg'><time>2025‑01‑02 12:12</time>&ensp;<span class='u' style='color:#30c84d'>clw0908</span>: But the output of **X_lx**(**eq A.11**) belongs to **N_R** (**N_64**) 
https://graypaper.fluffylabs.dev/#/6e1c0cd/249501249601

Did I misunderstand something?</div>
<div class='msg'><time>2025‑01‑02 12:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: true - this is probably the correction needed, but checking with Jan Bujak also: https://github.com/gavofyork/graypaper/pull/178</div>
<div class='msg'><time>2025‑01‑02 12:37</time>&ensp;<span class='u' style='color:#30c84d'>clw0908</span>: &gt; &lt;@gav:polkadot.io&gt; true - this is probably the correction needed, but checking with Jan Bujak also: https://github.com/gavofyork/graypaper/pull/178

Alright, thanks for your clarification</div>
<div class='msg'><time>2025‑01‑02 19:56</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: I&#x27;m wondering about an edge case with arguments parsing in PVM. Some instructions simply use `ζı+1` (like [here](https://graypaper.fluffylabs.dev/#/6e1c0cd/26a60326a603)), but for immediates/offsets we use `ℓ` which is mask dependent (like [here](https://graypaper.fluffylabs.dev/#/6e1c0cd/262001262001)).

ζ is zero-padded so it&#x27;s fine if we go beyond the program length, but what if `ζı+1` is actually the next instruction?

AFAICT from GP we should treat the instruction byte as argument (and read registers from it) and in the next step just move according to the mask (i.e. execute that instruction).
Is that expected or should there be some special casing for that in the GP?</div>
<div class='msg'><time>2025‑01‑02 20:04</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: In an edge case to that edge case we may have a program that is just instructions (i.e. all bits in the mask are set), but we are still reading it correctly, because we read the next instruction bytes as arguments to the current instruction (or 0s in case we go beyond the program length). I just want to confirm that I&#x27;m understanding it correctly.</div>
<div class='msg'><time>2025‑01‑02 20:05</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: * In an edge case to that edge case we may have a program that is just instructions (i.e. all bits in the mask are set), but we are still executing every instruction correctly , because we read the next instruction bytes as arguments to the current instruction (or 0s in case we go beyond the program length). I just want to confirm that I&#x27;m understanding it correctly.</div>
<div class='msg'><time>2025‑01‑02 20:05</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: * In an edge case to that edge case we may have a program that is just instructions (i.e. all bits in the mask are set), but we are still executing every instruction correctly, because we read the next instruction bytes as arguments to the current instruction (or 0s in case we go beyond the program length). I just want to confirm that I&#x27;m understanding it correctly.</div>
<div class='msg'><time>2025‑01‑02 23:57</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>: Not sure if I&#x27;m correct, but I understand the definitions in the GP as how the program *must* be encoded. So if there is no argument present where one should be as per GP, then the program is incorrect and we need to `panic`.</div>
<div class='msg'><time>2025‑01‑03 00:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@tomusdrw:matrix.org&gt; I&#x27;m wondering about an edge case with arguments parsing in PVM. Some instructions simply use `ζı+1` (like [here](https://graypaper.fluffylabs.dev/#/6e1c0cd/26a60326a603)), but for immediates/offsets we use `ℓ` which is mask dependent (like [here](https://graypaper.fluffylabs.dev/#/6e1c0cd/262001262001)).
&gt; 
&gt; ζ is zero-padded so it&#x27;s fine if we go beyond the program length, but what if `ζı+1` is actually the next instruction?
&gt; 
&gt; AFAICT from GP we should treat the instruction byte as argument (and read registers from it) and in the next step just move according to the mask (i.e. execute that instruction).
&gt; Is that expected or should there be some special casing for that in the GP?

It’s perfectly fine to concoct programs which reuse a previous instruction’s argument as the next instruction’s opcode.  </div>
<div class='msg'><time>2025‑01‑03 00:55</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Basically what Gav said. The program code blob is just that, a blob of bytes. You have the instruction pointer which tells you at which position to decode an instruction, and you have the skip value which tells you how to increment the instruction pointer after that instruction is executed. And the skip value doesn&#x27;t necessarily have to be the same as the &quot;length&quot; of the instruction.</div>
<div class='msg'><time>2025‑01‑03 07:11</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: Perfect, thanks for the confirmation.</div>
<div class='msg'><time>2025‑01‑03 21:35</time>&ensp;<span class='u' style='color:#7875cf'>charliewinston14</span>: Hi. Question about block sealing (by ticket). Maybe I am missing something but tickets are generated using a ring signature so there doesn&#x27;t seem to be a way to determine which ring member created it. But then how do we validate that when a block is received that it was created by the correct author that matches the ticket? couldn&#x27;t any other member of the ring just create the same block and set themselves as the author?</div>
<div class='msg'><time>2025‑01‑03 21:36</time>&ensp;<span class='u' style='color:#7875cf'>charliewinston14</span>: * Hi. Question about block sealing (by ticket). Maybe I am missing something but tickets are generated using a ring signature so there doesn&#x27;t seem to be a way to determine which ring member created it. But then how do we validate that when a block is received that it was created by the correct author that matches the ticket? couldn&#x27;t any other member of the ring just create the same block and set themselves as the author (pretending the ticket was theirs)?</div>
<div class='msg'><time>2025‑01‑03 21:46</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@charliewinston14:matrix.org&gt; Hi. Question about block sealing (by ticket). Maybe I am missing something but tickets are generated using a ring signature so there doesn&#x27;t seem to be a way to determine which ring member created it. But then how do we validate that when a block is received that it was created by the correct author that matches the ticket? couldn&#x27;t any other member of the ring just create the same block and set themselves as the author (pretending the ticket was theirs)?

The block author signs the block header using a standard Bandersnatch VRF signature. The VRF output generated from this signature matches the Ring VRF output, which serves as the ticket ID. This proves the block author&#x27;s ownership of the ticket, as they are the only one capable of producing this specific output. For further details, please refer to the Bandersnatch VRF specification paper and examplea https://github.com/davxy/bandersnatch-vrfs-spec.
</div>
<div class='msg'><time>2025‑01‑03 21:51</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@charliewinston14:matrix.org&gt; Hi. Question about block sealing (by ticket). Maybe I am missing something but tickets are generated using a ring signature so there doesn&#x27;t seem to be a way to determine which ring member created it. But then how do we validate that when a block is received that it was created by the correct author that matches the ticket? couldn&#x27;t any other member of the ring just create the same block and set themselves as the author?

* The block author signs the block header using a standard Bandersnatch VRF signature. The VRF output generated from this signature matches the Ring VRF output, which serves as the ticket ID. This proves the block author&#x27;s ownership of the ticket, as they are the only one capable of producing this specific output. For further details, please refer to the Bandersnatch VRF specification paper and example https://github.com/davxy/bandersnatch-vrfs-spec.</div>
<div class='msg'><time>2025‑01‑04 07:35</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@charliewinston14:matrix.org&gt; Hi. Question about block sealing (by ticket). Maybe I am missing something but tickets are generated using a ring signature so there doesn&#x27;t seem to be a way to determine which ring member created it. But then how do we validate that when a block is received that it was created by the correct author that matches the ticket? couldn&#x27;t any other member of the ring just create the same block and set themselves as the author?

* The block author signs the block header using a &quot;standard&quot; Bandersnatch VRF signature. The VRF output generated from this signature matches the Ring VRF output, which serves as the ticket ID. This proves the block author&#x27;s ownership of the ticket, as they are the only one capable of producing this specific output. For further details, please refer to the Bandersnatch VRF specification paper and example https://github.com/davxy/bandersnatch-vrfs-spec.</div>
<div class='msg'><time>2025‑01‑05 09:10</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: couple of question please regarding chapter 14.4 (computation of work results)
1. in Eq. 14.11 =&gt; definition of I(p,j) =&gt; invocation of refine =&gt; the function [S](https://graypaper.fluffylabs.dev/#/6e1c0cd/1a87021a8702)(import segment data) is being called with two arguments, but in [14.14](https://graypaper.fluffylabs.dev/#/6e1c0cd/1b48001b4800) is defined only with single (work item) argument.
which one is it?
2. maybe related, who/what is the bold face **s** used by the functions J and S in 14.14? where does it come from?


Thank you</div>
<div class='msg'><time>2025‑01‑05 11:15</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 1. You can disregard the bold-l parameter; it is assumed to be “part of the environment” in each of the functions which utilise L. </div>
<div class='msg'><time>2025‑01‑05 11:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * 1. You can disregard the bold-l parameter; it is assumed to be “part of the environment” in each of the functions which utilise L and is not passed explicitly into it. </div>
<div class='msg'><time>2025‑01‑05 11:17</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 2. Bold-s is constrained as the correct operand to the merkle root equality. </div>
<div class='msg'><time>2025‑01‑05 11:29</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: understood, thank you.
follow up question, could you shed some light on how to tell the difference between H and h⊞?

i saw your answer in the other room about encoding in C.29 but that didn&#x27;t clear it up for me.
are they both Y_32 or is there any &quot;mark&quot; to tell them apart?</div>
<div class='msg'><time>2025‑01‑05 11:29</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: * understood, thank you.
follow up question, could you shed some light on how to tell the difference between H and H⊞?

i saw your answer in the other room about encoding in C.29 but that didn&#x27;t clear it up for me.
are they both Y\_32 or is there any &quot;mark&quot; to tell them apart?</div>
<div class='msg'><time>2025‑01‑05 11:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There’s a mark: it’s the little window thing. </div>
<div class='msg'><time>2025‑01‑05 11:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: One is drawn from the set Y_32 and the other from a bijective mapping, denoted by square-plus (that little window symbol) </div>
<div class='msg'><time>2025‑01‑05 11:52</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: yes indeed there is the window thingy mark. that&#x27;s not what i meant.
maybe it&#x27;s a silly question.
the intention was in code how do i tell them apart
if they are both a 32 octets long binary, how could i tell if i&#x27;m looking at an H or and H⊞?</div>
<div class='msg'><time>2025‑01‑05 11:56</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: * yes indeed there is the window thingy mark. that&#x27;s not what i meant.
maybe it&#x27;s a silly question.
the intention was in code how do i tell them apart
if they are both a 32 octets long binary, how could i tell if i&#x27;m looking at an H or an H⊞?</div>
<div class='msg'><time>2025‑01‑05 11:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Well that all depends on what language you’re using. In general, you’ll need to use some extra memory to store whether it’s with or without the mark. </div>
<div class='msg'><time>2025‑01‑05 11:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: In rust you’d probably use a tagged enum. </div>
<div class='msg'><time>2025‑01‑05 11:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * In rust you’d probably use a tagged union</div>
<div class='msg'><time>2025‑01‑05 13:09</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: Thank you Gav. I think I&#x27;ve got it</div>
<div class='msg'><time>2025‑01‑06 06:44</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: gav:  follow up question please.
about the construction of the  segment-root dictionary l.
initially we have:
[K(l) ≡ {h S w ∈ pw , (h⊞, n) ∈ wi} , SlS ≤ 8](https://graypaper.fluffylabs.dev/#/6e1c0cd/1af0011af601)

this is clear enough, from the work item in a work package we take up to 8 hashes, of the kind that is the work-package hash. okie dokie.

then we come to :
 ∃p, c ∈ P, NC ∶ H(p) = h in [14.13](https://graypaper.fluffylabs.dev/#/6e1c0cd/1ac7021aca02)

which means to me one of two things
1.  we have here knowledge of &quot;all&quot; the work packages (all in what scope?) or some subset/list of work packages and we go through it to find the work-pacakges that the work-items refers to
2.we only keep in the segment-root dictionary the hashes that refer to the work-pacakge paseed into work result computation function Ξ. but since [s](https://graypaper.fluffylabs.dev/#/6e1c0cd/1b6c001b6c00) as far as i can see is not dependent on the core index c. we would end up with  a dictionary of all identical key -&gt; value pairs


option2 doesn&#x27;t make much sense, which brings me back yo option 1, but i see no reference to any list or set of work-packages


</div>
<div class='msg'><time>2025‑01‑06 06:46</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: * gav:  follow up question please.
about the construction of the  segment-root dictionary l.
initially we have:
[K(l) ≡ {h S w ∈ pw , (h⊞, n) ∈ wi} , SlS ≤ 8](https://graypaper.fluffylabs.dev/#/6e1c0cd/1af0011af601)

this is clear enough, from the work item in a work package we take up to 8 hashes, of the kind that is the work-package hash. okie dokie.

then we come to :
∃p, c ∈ P, NC ∶ H(p) = h in [14.13](https://graypaper.fluffylabs.dev/#/6e1c0cd/1ac7021aca02)

which means to me one of two things

1. we have here knowledge of &quot;all&quot; the work packages (all in what scope?) or some subset/list of work packages and we go through it to find the work-pacakges that the work-items refers to

2. we only keep in the segment-root dictionary the hashes that refer to the work-pacakge paseed into work result computation function Ξ. so all the keys will be identical, H(p), but since [s](https://graypaper.fluffylabs.dev/#/6e1c0cd/1b6c001b6c00) as far as i can see is not dependent on the core index c. we would end up with  a dictionary of all identical key -&gt; value pairs

option 2 doesn&#x27;t make much sense, which brings me back yo option 1, but i see no reference to any list or set of work-packages</div>
<div class='msg'><time>2025‑01‑06 06:50</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: is there a video lecture of chapter 14 as part of the JAM tour? i could not find any</div>
<div class='msg'><time>2025‑01‑06 10:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Not yet. Expect one in two months</div>
<div class='msg'><time>2025‑01‑06 10:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes, as the guarantor you&#x27;ll need to have seen the WRs of any WP hashes mention in the </div>
<div class='msg'><time>2025‑01‑06 10:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Yes, as the guarantor you&#x27;ll need to have seen the WRs of any WP hashes mentioned in the SR Loookup.</div>
<div class='msg'><time>2025‑01‑06 10:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Yes, as the guarantor you&#x27;ll need to have seen the WRs of any WP hashes mentioned in the SR Lookup.</div>
<div class='msg'><time>2025‑01‑06 10:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Yes, as the guarantor you&#x27;ll need to have seen the WRs of any WP hashes mentioned in the SR Lookup, so you can be sure that it&#x27;s correct otherwise you might end up guaranteeing WP with a WR which won&#x27;t be accumulated.</div>
<div class='msg'><time>2025‑01‑06 10:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There only a limited about of WR history you&#x27;ll need have knowledge of: https://graypaper.fluffylabs.dev/#/6e1c0cd/15de01152d02</div>
<div class='msg'><time>2025‑01‑06 10:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Basically just what will be in the recent blocks by the time of entering accumulation.</div>
<div class='msg'><time>2025‑01‑06 10:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Basically just what will be in the recent blocks by the time of becoming available.</div>
<div class='msg'><time>2025‑01‑06 10:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: So that&#x27;s basically just U+H = 13.</div>
<div class='msg'><time>2025‑01‑06 10:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * So that&#x27;s basically just U+H = 13 slots.</div>
<div class='msg'><time>2025‑01‑06 10:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * So that&#x27;s basically just H = 8 slots</div>
<div class='msg'><time>2025‑01‑06 10:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: This mechanism is designed to allow pipelining when sequences of unidependent work packages are executed on the same core.</div>
<div class='msg'><time>2025‑01‑06 10:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Without it, it would be hard to reference data in the DA without figuring out the SR manually which may not necessarily be known at the time of authoring the importing package.</div>
<div class='msg'><time>2025‑01‑07 10:52</time>&ensp;<span class='u' style='color:#4068cd'>0xjunha</span>: I have a question regarding the leaf node encoding function (https://graypaper.fluffylabs.dev/#/911af30/37f402371103) for state merklization.

In a Merkle trie, a leaf node will be typically placed at a depth less than 256, implying that it should represent the remaining, unconsumed bits of the `state_key` after navigating to that point - so that we can guess which `state_key` that leaf node represents.

When considering what the leaf node holds as the encoded state key (`bits(k)...248`), should this refer to:

a) &quot;The first 248 bits of the full 256-bit state key&quot;? Or
b) &quot;The first 248 bits of the unconsumed path bits&quot;?

For example, let&#x27;s say we have a state key like `0b1101_1010_1001...` and a leaf node is at depth 10, meaning we&#x27;ve navigated the trie using the path `0b1101_1010_10` to reach this node, should the leaf node:

a) Store the first 248 bits of `0b1101_1010_1001...`? Or
b) Only store the first 248 bits of `0b01...`, skipping the first 10 bits, thus excluding the part already used for navigation (`0b1101_1010_10`)? Actually in this case the remaining part is only 246 bits, so we have 2 bits of free space.

From my interpretation of the formalism, it seems the encoding takes the &quot;first 248 bits of the full 256-bit state key&quot; regardless of the leaf node&#x27;s position (depth), so option a), but just wanted to confirm this understanding.</div>
<div class='msg reply'><time>2025‑01‑07 13:55</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Yes, (a) is correct</div>
<div class='msg reply'><time>2025‑01‑07 14:18</time>&ensp;<span class='u' style='color:#4068cd'>0xjunha</span>: David Emett: awesome, thanks for clarifying!</div>
<div class='msg'><time>2025‑01‑08 15:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: @room Version 0.5.4 [released](https://github.com/gavofyork/graypaper/releases/tag/v0.5.4) with some important protocol alterations.</div>
<div class='msg'><time>2025‑01‑08 15:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Significant alterations:
* PVM Host-calls: Host-call to inspect preimage request status by @gavofyork in https://github.com/gavofyork/graypaper/pull/177
* PVM Invocations: Yielding accumulation hash possible on OOG by @gavofyork in https://github.com/gavofyork/graypaper/pull/179
* PVM: Bit manipulation (Zbb-inspired) extensions by @gavofyork in https://github.com/gavofyork/graypaper/pull/176
* Accumulation &amp; PVM Invocations: Buddy ejects service to allow perfect service deletion by @gavofyork in https://github.com/gavofyork/graypaper/pull/182
</div>
<div class='msg'><time>2025‑01‑08 15:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I expect [one further substantial alteration](https://github.com/gavofyork/graypaper/issues/186) in the [0.5 series](https://github.com/gavofyork/graypaper/milestone/1) and after that I think we&#x27;ll be good until the 0.7/0.8 series.</div>
<div class='msg'><time>2025‑01‑08 19:54</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Getting back to an old question: I still didn&#x27;t figure out what C(p) means in this formula. Here:

d ↦ [join(c) ∣ c &lt;−T[C(p) ∣ p &lt;−unzip684(d)]]

d is a binary with size multiple of both k and 684
I unzip684 d, so I get k binaries p of size 684
then I take each one of this binaries p and apply C(p) - what is C(p) ?  </div>
<div class='msg'><time>2025‑01‑09 08:17</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: It is Reed-Solomon erasure coding Encoding function we are allowed to use external library for this, example - https://github.com/ordian/reed-solomon-simd/blob/7def877102661817b3c2d5bcfe85118ffb535245/README.md?plain=1#L94</div>
<div class='msg'><time>2025‑01‑10 18:08</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: I got it. Thanks for sharing this. I tried to use this library, but it accepts only shards with size that are multiple of 64 bytes. In case of JAM, shards are 684 bytes. Do you know how we could deal with this? 

Another question is:  684 / 1023 configuration would be for production network. What would be the testnet / tiny / small network configuration? </div>
<div class='msg'><time>2025‑01‑10 20:56</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: About the Erasure Code definition, if C ∶ ⟦Y2⟧342 → ⟦Y2⟧1023, and p ∈ ⟦Y684⟧, is there a formal specification missing in formula H.6 to transform p ∈ ⟦Y684⟧ into ⟦Y2⟧342 ? </div>
<div class='msg'><time>2025‑01‑11 03:40</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: I am also facing this problem right now. I have temporarily padded my data to support 64 bytes and will fix it later.

There is also some discussion about this issue on GitHub here: https://github.com/w3f/jamtestvectors/pull/4

Maybe someone else has a concrete solution.


I believe the configuration for testnet, tiny, or small networks will remain the same because the data size will still be 684k. In all these networks, the same validator holds multiple pieces of the 1023 chunks.</div>
<div class='msg'><time>2025‑01‑11 03:48</time>&ensp;<span class='u' style='color:#c86f85'>amritj</span>: * I am also facing this problem right now. I have temporarily padded my data to support 64 bytes and will fix it later.

There is also a discussion about this issue on GitHub here: https://github.com/w3f/jamtestvectors/pull/4

Maybe someone else has a concrete solution.


I believe the configuration for testnet, tiny, or small networks will remain the same because the data size will still be 684k. In all these networks, the same validator holds multiple pieces of the 1023 chunks.</div>
<div class='msg'><time>2025‑01‑11 17:32</time>&ensp;<span class='u' style='color:#6de2b4'>weigen</span>: Hi, I have a question about disputes. Based on my understanding, the faults (f) in the extrinsic include validators who issued invalid judgments on a work report. Since the work report is actually valid, it should belong to the good set (Psi_g).
This logic aligns with the behavior seen in this test vector (https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/disputes/tiny/progress_with_verdicts-4.json#L82, https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/disputes/tiny/progress_with_verdicts-4.json#L191), where work reports included in faults (f) are added to the good set of the posterior Psi. However, according to the Gray Paper (https://graypaper.fluffylabs.dev/#/579bd12/128a01128a01), the reports in faults (f) should instead be placed in the bad set (Psi_b) and not in the good set.

This creates a conflict: if the work reports in faults (f) are valid and should be part of the good set, why are they assigned to the bad set instead? My understanding is that validators who issued invalid judgments on these valid reports are placed in faults (f), but the reports themselves remain valid.

Am I interpreting this correctly, or have I missed something?</div>
<div class='msg'><time>2025‑01‑12 10:42</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: I think you are interpreting the GP incorrectly. The judgments included in faults can be either positive (ie claiming the WR is good) or negative (ie claiming it is bad). The requirement you linked (https://graypaper.fluffylabs.dev/#/579bd12/128a01128a01) just states that they must contradict a verdict</div>
<div class='msg reply'><time>2025‑01‑12 13:40</time>&ensp;<span class='u' style='color:#6de2b4'>weigen</span>: Thanks! I got it</div>
<div class='msg'><time>2025‑01‑12 10:44</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: So eg if a WR is found to be bad, then validators who supported the WR (ie produced a positive judgment) can be reported via faults</div>
<div class='msg'><time>2025‑01‑12 13:37</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: can&#x27;t we just use https://github.com/paritytech/erasure-coding/tree/main directly? for the testvector, I think it is incomplete or we&#x27;d better do it after the accumulation part, if I&#x27;m not mistaken, the testvectors required a log of external logic for assembling the chunks</div>
<div class='msg'><time>2025‑01‑12 13:37</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * can&#x27;t we just use https://github.com/paritytech/erasure-coding/tree/main directly? for the testvector, I think it is incomplete or we&#x27;d better do it after the accumulation part, if I&#x27;m not mistaken, the testvectors required a lot of external logic for assembling the chunks</div>
<div class='msg'><time>2025‑01‑12 13:39</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * can&#x27;t we just use https://github.com/paritytech/erasure-coding/tree/main directly? for the testvector, I think it is incomplete or we&#x27;d better do it after the accumulation part, if I&#x27;m not mistaken, the testvectors required a lot of external logic for assembling the data</div>
<div class='msg'><time>2025‑01‑12 13:40</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * can&#x27;t we just use https://github.com/paritytech/erasure-coding/tree/main directly? for the testvector, I think it is incomplete or we&#x27;d better do it after the accumulation part, if I&#x27;m not mistaken, the testvectors required a lot of external logic for assembling the chunks</div>
<div class='msg'><time>2025‑01‑13 07:43</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: &gt; &lt;@clearloop:matrix.org&gt; can&#x27;t we just use https://github.com/paritytech/erasure-coding/tree/main directly? for the testvector, I think it is incomplete or we&#x27;d better do it after the accumulation part, if I&#x27;m not mistaken, the testvectors required a lot of external logic for assembling the chunks

This parity example just takes a generic byte string and splits it into chunks. It still uses the Reed Solomon library, that only accepts strings with 64 bytes multiple size</div>
<div class='msg reply'><time>2025‑01‑16 05:02</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: thanks! I have skipped the types specified in erasure_coding after seeing `parity/erasure_coding` , will get it back these days!</div>
<div class='msg'><time>2025‑01‑13 10:29</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: In the INVOKE host-call (https://graypaper.fluffylabs.dev/#/579bd12/362401366b01) we are apparently setting to regs[7], both values of &quot;Host-call result constants&quot; (https://graypaper.fluffylabs.dev/#/579bd12/2c78022ca802) and values from &quot;inner pvm invocations result codes&quot; (https://graypaper.fluffylabs.dev/#/579bd12/2caa022cbd02). This would be incorrect in theory, and also in practice since the value &quot;0&quot; is associated to two different constants (Ok and Halt)</div>
<div class='msg'><time>2025‑01‑13 12:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: No it wouldn’t. </div>
<div class='msg'><time>2025‑01‑13 12:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The two tokens `OK` and `Halt` are each representations of zero. </div>
<div class='msg'><time>2025‑01‑13 12:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: If `invoke` returns zero in omega_7, then it unambiguously means `Halt`.</div>
<div class='msg'><time>2025‑01‑13 12:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: You’re probably trying to associate a _type_ with omega_7. This would be an incorrect approach. </div>
<div class='msg'><time>2025‑01‑13 12:30</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: yep, I was trying that. Thank you for clarification</div>
<div class='msg'><time>2025‑01‑13 16:56</time>&ensp;<span class='u' style='color:#817ecb'>ycc3741</span>: gav: 
Does the official source provide any test data for verifying whether each class has been correctly serialized according to the specifications in Appendix [C.2](https://graypaper.fluffylabs.dev/#/5b732de/361100361100) before performing the hash operation?</div>
<div class='msg'><time>2025‑01‑13 16:57</time>&ensp;<span class='u' style='color:#817ecb'>ycc3741</span>: We are currently encountering some issues and would like to verify whether the serialization is correct. Having the serialized results available would greatly facilitate development. Thank you!</div>
<div class='msg'><time>2025‑01‑13 17:08</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: &gt; &lt;@ycc3741:matrix.org&gt; We are currently encountering some issues and would like to verify whether the serialization is correct. Having the serialized results available would greatly facilitate development. Thank you!

Just a tip in the meantime until there are official full block/state serialization vectors.. I found switching to parsing all of the *.bin vectors rather than the json equivalents helped me catch a few encoding issues.</div>
<div class='msg'><time>2025‑01‑13 17:10</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: There are some serialization test vectors here: https://github.com/w3f/jamtestvectors/tree/master/codec</div>
<div class='msg'><time>2025‑01‑13 17:30</time>&ensp;<span class='u' style='color:#817ecb'>ycc3741</span>: Oh I got it thanks a lot </div>
<div class='msg'><time>2025‑01‑15 14:52</time>&ensp;<span class='u' style='color:#cb735c'>prasad-kumkar</span>: For state merklization, is there a recommended approach for data ordering before constructing the Merkle tree? While I noticed the state key construction function C appears to provide some ordering through key generation, I&#x27;m unsure if:

1. This is indeed meant to determine the ordering before Merkleization
2. If so, would service indices (s) create well-distributed keys since they are sparsely distributed 32-bit integers?

I initially thought of splitting data in half recursively (like traditional Merkle trees), but noticed JAM&#x27;s approach might be different.</div>
<div class='msg'><time>2025‑01‑15 16:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: This is a Merkle trie, so the keys (given by C) determine exactly the node structure of the tree. </div>
<div class='msg'><time>2025‑01‑15 16:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: You don’t get to decide. “Ordering” is moot as we never iterate. But if you really want an order (eg for RPC) then you can apply dictionary ordering to the keys. </div>
<div class='msg'><time>2025‑01‑15 16:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Service indices are sparse, as are keys generally: the function C is designed to be sparse and mostly uniform. The tree’s implied node structure (by virtue of the commitment scheme) should be able to manage this perfectly well. </div>
<div class='msg'><time>2025‑01‑15 16:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: One reasonable question might be whether (or to what degree) keys/values should be kept in-memory, and whether (or to what degree) the nodes of the tree should be persisted and whether that persistence should be in-memory or on-disk.  </div>
<div class='msg'><time>2025‑01‑15 16:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: For now I’d leave this for implementers to decide. I expect that getting to M4 or M5 will almost certainly need aggressive use of RAM to store/memoize one or both of these databases. </div>
<div class='msg'><time>2025‑01‑15 19:52</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: A suggestion for CE-132.. it might be a good idea to allow multiple tickets to be submitted by a proxy in a single stream. The current specification works good for the tiny chain spec but it may not be the best performance wise when using the full chain spec. The full chain spec will have 2046 tickets to be distributed to everyone within approx. 22 minutes (half of the lottery time and allowing 3 min for connectivity changes). This will result in 90+ incoming streams per minute for each validator just to consume tickets.</div>
<div class='msg'><time>2025‑01‑15 19:56</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Might happen for the full network protocol, don&#x27;t think it&#x27;s particularly important though</div>
<div class='msg'><time>2025‑01‑15 20:23</time>&ensp;<span class='u' style='color:#c377dd'>mkchung</span>: For CE-134 &quot;Work-package sharing&quot;, why is &quot;slot&quot; not included as part of the msg?
 

```
Guarantor -&gt; Guarantor

--&gt; Core Index ++ Segments-Root Mappings
--&gt; Work-Package Bundle
--&gt; FIN
&lt;-- Work-Report Hash ++ Ed25519 Signature
&lt;-- FIN
```

Perhaps this can be something like
```
--&gt; Core Index ++ slot ++ Segments-Root Mappings
```
? </div>
<div class='msg'><time>2025‑01‑15 21:27</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Not really necessary as it stands, the recipient can just accept or reject based on whether there is an appropriate core assignment or not. What an appropriate assignment is probably needs to be specified in more detail to ensure different implementations work well together, but will likely just be based on the current time and state at the head of the chain</div>
<div class='msg'><time>2025‑01‑17 16:29</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: If [this function](https://graypaper.fluffylabs.dev/#/579bd12/241901241b01) returns B_{8n}, shouldn&#x27;t it say &quot;forall i in N_{8n}&quot; instead of &quot;...in N_{2^{8n}}&quot;?</div>
<div class='msg'><time>2025‑01‑17 18:15</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@cisco:parity.io&gt; If [this function](https://graypaper.fluffylabs.dev/#/579bd12/241901241b01) returns B_{8n}, shouldn&#x27;t it say &quot;forall i in N_{8n}&quot; instead of &quot;...in N_{2^{8n}}&quot;?

Yes. Will be fixed in next revision</div>
<div class='msg'><time>2025‑01‑17 18:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: https://github.com/gavofyork/graypaper/pull/194</div>
<div class='msg'><time>2025‑01‑19 10:18</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: Question about the [schema.asn](https://github.com/subotic/polkavm/blob/subotic_add_64_bit_test_programs/tools/spectool/spec/schema.asn#L52) of PVM test programs: &quot;expected-status&quot; is described as &quot;the status code of the execution, i.e. the way the program is supposed to end&quot;. 

1.- Is this the GP exit reason? (halt, panic, out of gas, page fault, hostcall fault)
2.- If (1) is yes, should &quot;trap&quot; be swapped by &quot;panic&quot; and the other exit reasons added to &quot;expected-status&quot;?</div>
<div class='msg reply'><time>2025‑01‑20 05:50</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: 1. Yes.
2. &quot;trap&quot; is the same as  &quot;panic&quot;</div>
<div class='msg reply'><time>2025‑01‑20 09:57</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: It&#x27;s a bit confusing because &quot;trap&quot; is an instruction and &quot;panic&quot; is an exit reason.

What do you do when a page fault ocurrs? Do you store the lowest address to access in a status register before executing the trap instruction to switch from PVM mode to JAM kernel mode?</div>
<div class='msg reply'><time>2025‑01‑20 12:51</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: I will align the naming in the next version of the test vectors to make it less confusing.</div>
<div class='msg reply'><time>2025‑01‑20 12:55</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: For toplevel PVMs a page fault is no different than executing a &quot;trap&quot; instruction or any other condition which would result in a &quot;panic&quot; exit reason, and for those you don&#x27;t even need to know the address of the page that faulted.

For inner PVMs (those are PVMs triggered with the `invoke` hostcall) a page fault will interrupt the execution of the inner PVM and should return the address of the page which triggered the fault.</div>
<div class='msg reply'><time>2025‑01‑20 13:00</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: And in case you&#x27;re wondering, the store instructions are atomic, so for example if the inner PVM tries to write 4 bytes into the memory, and the first two bytes end up at the 2 last bytes of page N (which was already faulted) and the last two bytes end up at the 2 first bytes of page N +1 (which was not faulted) then such a write will *only* trigger a page fault with the address of the N + 1 page and memory will not be modified.</div>
<div class='msg'><time>2025‑01‑19 10:20</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: * Question about the [schema.asn](https://github.com/subotic/polkavm/blob/subotic_add_64_bit_test_programs/tools/spectool/spec/schema.asn#L52) of PVM test programs: &quot;expected-status&quot; is described as &quot;the status code of the execution, i.e. the way the program is supposed to end&quot;.

1.- Is this the GP exit reason? (halt, panic, out of gas, page fault, hostcall fault)
2.- If (1) is yes, should &quot;trap&quot; be replaced by &quot;panic&quot; and the other exit reasons added to &quot;expected-status&quot;?</div>
<div class='msg'><time>2025‑01‑19 10:21</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: * Question about the [schema.asn](https://github.com/subotic/polkavm/blob/subotic_add_64_bit_test_programs/tools/spectool/spec/schema.asn#L52) of PVM test programs: &quot;expected-status&quot; is described as &quot;the status code of the execution, i.e. the way the program is supposed to end&quot;.

1.- Is this the GP exit reason? (halt, panic, out of gas, page fault, hostcall fault)
2.- If (1) is yes, should &quot;trap&quot; be replaced by &quot;panic&quot; and the other exit reasons be added to &quot;expected-status&quot;?</div>
<div class='msg'><time>2025‑01‑20 18:01</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Small Clarification question about preimages included in the genesis state ([example](https://github.com/jam-duna/jamtestnet/blob/main/fallback/state_transitions/455223_000.json#L9C24-L9C90)):  To be conformant to GP, should it include a matching a_l?  Even though no preimage was ever &quot;requested&quot;?



</div>
<div class='msg'><time>2025‑01‑20 19:30</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * Small Clarification question about preimages included in the genesis state ([example](https://github.com/jam-duna/jamtestnet/blob/main/fallback/state_transitions/455223_000.json#L9C24-L9C90)):  To be conformant to GP, should it include a matching [a\_l](https://graypaper.fluffylabs.dev/#/579bd12/387003387003) in the state trie _even though no preimage was ever &quot;requested&quot;_?  If so, what would (9.7) [link](https://graypaper.fluffylabs.dev/#/579bd12/11aa0011aa00) prescribe as its  value?</div>
<div class='msg'><time>2025‑01‑20 19:31</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * Small Clarification question about preimages included in the genesis state ([example](https://github.com/jam-duna/jamtestnet/blob/main/fallback/state_transitions/455223_000.json#L9C24-L9C90)):  To be conformant to GP, should it include a matching [a\_l](https://graypaper.fluffylabs.dev/#/579bd12/387003387003) in the state trie _even though no preimage was ever &quot;requested&quot;_?  If so, what would (9.7) ([GP link](https://graypaper.fluffylabs.dev/#/579bd12/11aa0011aa00)) prescribe as its $[x]$ value?</div>
<div class='msg'><time>2025‑01‑20 22:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: [0] perhaps?</div>
<div class='msg'><time>2025‑01‑21 12:29</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Question on JAM DA throughput: How does the model referenced in [Sec 20](https://graypaper.fluffylabs.dev/#/579bd12/1f90011f9001) arrive at the distributed availability of 852MB/s?  Simplest model based on [W_B=12MB](https://graypaper.fluffylabs.dev/#/579bd12/418d00418d00) (max encoded work package size, derived from bandwidth considerations I think?) with 6s on guarantee and 6s on assurance yields 1MB/s per core x 341 cores = 341MB/s -- so what accounts for the difference?  </div>
<div class='msg'><time>2025‑01‑21 13:24</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: JAM is pipelined so peak throughput is 341 WPs per block, not per 2 blocks. Don&#x27;t know exactly where the 852MB/s number comes from, but the bundle size does not include exported segments so possibly that</div>
<div class='msg'><time>2025‑01‑21 13:24</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: * JAM is pipelined so peak throughput is 341 WPs per block, not per 2 blocks. Don&#x27;t know exactly where the 852MB/s number comes from, but the bundle size does not include exported segments so possibly that is the other missing bit</div>
<div class='msg'><time>2025‑01‑21 13:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: That’s an old figure even WPs could be 15 mb. </div>
<div class='msg'><time>2025‑01‑21 13:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Now that they’re 12, it’s 682MB/s</div>
<div class='msg'><time>2025‑01‑22 04:52</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Ok, got it -- this 2x pipelining &quot;easter egg&quot; is not obvious from GP or JAMNP.   We now see the conditions for it are carefully enabled through the ordering of assurances and guarantees on &quot;rho&quot;.   Is the idea that this performance optimization is optional for M3 &quot;Kusama performance&quot; but practically required  for M4 &quot;Polkadot performance&quot; -- yet not really part of the JAM protocol per se and thus outside of GP?  Does a hint in CE133/134 to achieve this factor of 2x make sense?</div>
<div class='msg'><time>2025‑01‑23 08:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Implementations are expected to author blocks in a reasonably efficient manner. Asynchrony which is possible should be exploited. This will likely be required as early as M2. </div>
<div class='msg'><time>2025‑01‑23 08:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: We will work to provide some basic M2 test vectors demonstrating this expectation. </div>
<div class='msg'><time>2025‑01‑23 08:52</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: If there will be a more detailed spec for async computation provided in M2 test vectors, as we can see in the dependency graph here https://graypaper.fluffylabs.dev/#/579bd12/091b00091b00, some of the state transition are just **assign** operations, that they are actually not need async </div>
<div class='msg'><time>2025‑01‑23 08:53</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * If there will be a more detailed spec for async computation provided in M2 test vectors, as we can see in the dependency graph here https://graypaper.fluffylabs.dev/#/579bd12/091b00091b00, some of the state transition are just **assign** operations, that they actually not need async</div>
<div class='msg'><time>2025‑01‑23 09:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The GP doesn&#x27;t specify block production.</div>
<div class='msg'><time>2025‑01‑23 09:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * For state transition, asynchrony is not so relevant.</div>
<div class='msg'><time>2025‑01‑23 09:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * For the inner aspects of state transition (block execution), asynchrony is not so relevant.</div>
<div class='msg'><time>2025‑01‑23 09:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There will likely need to be some to hit M3 and M4 (e.g. signature checking, inter-block Merkle root calculation).</div>
<div class='msg'><time>2025‑01‑23 09:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: But it&#x27;s up to teams how the optimise, given the correctness-constraints of the GP.</div>
<div class='msg'><time>2025‑01‑23 09:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: We won&#x27;t be holding anyone&#x27;s hand here.</div>
<div class='msg'><time>2025‑01‑23 09:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * For the inner aspects of state transition (block execution), asynchrony is perhaps not quite so relevant.</div>
<div class='msg'><time>2025‑01‑23 09:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * For the inner aspects of state transition (block execution), asynchrony is perhaps not quite so relevant as with block authoring.</div>
<div class='msg'><time>2025‑01‑23 09:14</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: For block authoring (M2), skipping a block for either guaranteeing or assuring will be considered incorrect behaviour.</div>
<div class='msg'><time>2025‑01‑23 09:14</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Nodes are expected to provide (and use) information in a timely fashion.</div>
<div class='msg'><time>2025‑01‑23 09:15</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Nodes are expected to provide (and use) information in a timely fashion; this goes for all aspects of block authoring and production.</div>
<div class='msg'><time>2025‑01‑23 09:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Updated my notes accordingly.</div>
<div class='msg'><time>2025‑01‑23 09:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Updated my notes with an according FAQ entry.</div>
<div class='msg'><time>2025‑01‑24 10:06</time>&ensp;<span class='u' style='color:#73caa8'>dvladco</span>: Hi, in the GP v0.5.4 the instructions `rot_l_32` and `rot_r_32` have 3 registers but `ω_B` is never used, is this a typo? and should we rotate by `ω_B` instead?</div>
<div class='msg reply'><time>2025‑01‑24 10:07</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Yes, it&#x27;s a typo.</div>
<div class='msg reply'><time>2025‑01‑24 10:08</time>&ensp;<span class='u' style='color:#6ecf94'>qiwei</span>: the fix is merged: https://github.com/gavofyork/graypaper/pull/193</div>
<div class='msg'><time>2025‑01‑25 13:18</time>&ensp;<span class='u' style='color:#6de2b4'>weigen</span>: Hi, I have a question about GP (https://graypaper.fluffylabs.dev/#/579bd12/131301131901). What is the expected range of n (segment-count)? When serializing a work report, should n be considered as 𝑛∈𝑁_32 or 𝑛∈𝑁_16? The choice would result in a difference in byte size.</div>
<div class='msg reply'><time>2025‑01‑25 14:48</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Serialisation is defined in appendix C. In particular, see C.22</div>
<div class='msg reply'><time>2025‑01‑26 12:07</time>&ensp;<span class='u' style='color:#6de2b4'>weigen</span>: Maybe the constraint of 𝑛∈𝑁_16 is needed, since in C.22 the input of ε_2 should be N_16</div>
<div class='msg'><time>2025‑01‑26 14:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It’s not strictly needed though if N \ N_{2^16} were ever fed into E_2 the result would be undefined.   </div>
<div class='msg'><time>2025‑01‑26 14:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Since it is deserialised with E_2 it will always be in range for correct reserialisation. And though your node could create a segment with an out of range value, it would only break you own node since it could not be encoded and this would be needed for it to be sent to another node. </div>
<div class='msg'><time>2025‑01‑26 14:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * It’s not strictly needed, though if N \ N_{2^16} were ever fed into E_2 the result would be undefined.   </div>
<div class='msg'><time>2025‑01‑26 14:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Since it is deserialised with E_2, any foreign-born availability specification will always be in range for correct reserialisation. And though your node could create an availablilty spec with an out of range value, it would only break your own node since it could not be encoded and this would be needed for it to be sent to another node. </div>
<div class='msg'><time>2025‑01‑26 16:52</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: The formula to encode guarantees on for Hx extrinsic hash 
(https://graypaper.fluffylabs.dev/#/579bd12/0ce0000cf200) differs from the formula for encoding guarantees for block encoding (https://graypaper.fluffylabs.dev/#/579bd12/375b01377f01). 

In the former calculates hash of work report. Is this correct? 

</div>
<div class='msg'><time>2025‑01‑26 17:09</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: * The formula to encode guarantees on for Hx extrinsic hash 
(https://graypaper.fluffylabs.dev/#/579bd12/0ce0000cf200) differs from the formula for encoding guarantees for block encoding (https://graypaper.fluffylabs.dev/#/579bd12/375b01377f01). 

In the former, it calculates hash of work report. Is this correct? 

</div>
<div class='msg'><time>2025‑01‑26 17:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes. </div>
<div class='msg'><time>2025‑01‑26 17:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It’s a bit fiddly but it’s so that they can be separately distributed. </div>
<div class='msg'><time>2025‑01‑26 17:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * It’s a bit fiddly but it’s so that they can be separately distributed and individual items concisely proven to be correct. </div>
<div class='msg'><time>2025‑01‑26 17:25</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: With `tiny` having `rotation_period: 4` (which is not all that different from `full` having `rotation_period: 10`) we have been finding in our &quot;run work packages back-to-back&quot; tests that work packages are reasonable for one validator to start towards the end of one rotation but by the time a guarantee is signable by one of the three, it is the case that one or two of them have rotated out of the core.  What is a good mode of operation for
(a) don&#x27;t start the work if you&#x27;re towards the end according to rule R, because you won&#x27;t be rewarded for it!
(b) finish it because you&#x27;ll be rewarded for it!
We do believe its valuable to have this rule R or reward process specified in more detail to ensure different implementations work well together -- can we come up with a good Schelling point at this point? 

Not getting the slot in the &quot;tiny&quot; network (where C is just 2, R is just 4) with &quot;big&quot; work packages (close to 12MB) makes this issue quite prominent in regression tests.  </div>
<div class='msg reply'><time>2025‑01‑26 18:40</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Agree this will probably need to be specified at some point for different impls to work well together. I think this rule will need to be informed by the performance characteristics of a full 1000-validator network though, with real builder nodes, and we aren&#x27;t in a position to run such a network yet. I can say that at the moment our node follows a pretty simple rule: as a validator, accept a package for core C if we will be &quot;assigned&quot; to that core in the next slot or the slot after that. Note that it is possible for block authors to include packages using assignments from the previous rotation, so there is quite a bit of leeway.</div>
<div class='msg reply'><time>2025‑01‑26 18:43</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Given this leeway perhaps a better rule would be to allow if we&#x27;re currently assigned or will be assigned in the next slot. In any case I would recommend making this sort of thing easy to tweak in your implementation!</div>
<div class='msg reply'><time>2025‑01‑26 18:46</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: The rule should also probably be a bit more lenient for work packages received indirectly from another guarantor on the same assignment, to avoid a situation where the &quot;primary&quot; guarantor _just_ accepts a package but the guarantors it then shares it with do not.</div>
<div class='msg reply'><time>2025‑01‑26 18:51</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Of course at the end of the day none of this behaviour will be required; nodes will be free to accept or reject packages however they think will maximise their profit. A specified rule seems like a good starting point though</div>
<div class='msg reply'><time>2025‑01‑26 22:45</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Alright - we&#x27;ll do &quot;to allow if we&#x27;re currently assigned or will be assigned in the next slot.&quot; for now sure thing thank you</div>
<div class='msg'><time>2025‑01‑26 17:26</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * With `tiny` having [`rotation_period: 4`](https://docs.jamcha.in/basics/chain-spec/tiny) (which is not all that different from `full` having [`rotation_period: 10`](https://docs.jamcha.in/basics/chain-spec/full)) we have found in our &quot;run ~12MB work packages back-to-back&quot; tests that work packages are reasonable for one validator to start towards the end of one rotation but by the time a guarantee is signable by one of the three, it is the case that one or two of them have rotated out of the core.  Ok, so ... what is a good mode of operation for
(a) don&#x27;t start the work if you&#x27;re towards the end according to rule R, because you won&#x27;t be rewarded for it!
(b) finish it because you&#x27;ll be rewarded for it!
We do believe its valuable to have this rule R or reward process specified in more detail to ensure different implementations work well together -- can we come up with a good Schelling point at this point?

Not getting the slot in the &quot;tiny&quot; network (where C is just 2, R is just 4) with &quot;big&quot; work packages (close to 12MB) makes this issue quite prominent in regression tests.</div>
<div class='msg'><time>2025‑01‑29 16:46</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: If a panic occurs when `80 -&gt; load_imm_jump` executes the [branch](https://graypaper.fluffylabs.dev/#/579bd12/26ef0226ef02) function, the &quot;ωA&quot; don&#x27;t should be changed, right?</div>
<div class='msg reply'><time>2025‑01‑29 16:49</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: It&#x27;s always changed, regardless of whether the jump fails or not.</div>
<div class='msg reply'><time>2025‑01‑29 16:49</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: (This is the equivalent to the RISC-V&#x27;s `call` instruction; the usual use of this instruction is to load the return address and jump to another function.)</div>
<div class='msg reply'><time>2025‑01‑29 16:52</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: Thanks! 🙂</div>
<div class='msg'><time>2025‑01‑29 16:50</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: * (This is the equivalent of RISC-V&#x27;s `call` instruction; the usual use of this instruction is to load the return address and jump to another function.)</div>
<div class='msg'><time>2025‑01‑30 10:08</time>&ensp;<span class='u' style='color:#c669dd'>carlos-romano</span>: Screenshot 2025-01-30 at 11.07.59.png</div>
<div class='msg'><time>2025‑01‑30 10:09</time>&ensp;<span class='u' style='color:#c669dd'>carlos-romano</span>: Regarding https://github.com/davxy/jam-test-vectors/tree/polkajam-vectors/reports :

 I can see there are test vectors where auth_pools are the same in both prestate and poststate, but given that we should remove the used authorizer from the pool, and that pending core authorizers are not provided by test vectors and should be empty, I don&#x27;t get why this is the case. 

Specific commit where this change was introduced: https://github.com/davxy/jam-test-vectors/commit/729592cf87eb09bc34555f846c5b19f5b1453c52 .

This is related to equation 8.2, GP 0.5.4

Thanks!

</div>
<div class='msg'><time>2025‑01‑30 13:18</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>: Regarding `page-fault` and this paragraph https://graypaper.fluffylabs.dev/#/579bd12/243c00245500, I understand that when trying to write to writable memory and I cannot, I emit a `page-fault`. What is not so clear to me based on this definition, that if I want to write to read-only memory, I should emit a `panic`. I only know that because of the test-vectors. Or did I miss a place in the GP where this is defined?</div>
<div class='msg'><time>2025‑01‑30 13:20</time>&ensp;<span class='u' style='color:#5e86de'>boymaas</span>: Maybe this helps: https://github.com/w3f/jamtestvectors/pull/3#issuecomment-2614547819</div>
<div class='msg reply'><time>2025‑01‑30 13:25</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>: Great, thanks for the link. As always, things are more complicated, then they seem.</div>
<div class='msg'><time>2025‑01‑30 14:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Version [0.6.0](https://github.com/gavofyork/graypaper/releases/tag/v0.6.0) is released!</div>
<div class='msg'><time>2025‑01‑30 14:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There&#x27;s a few changes in this from 0.5.4 all centred around the PVM</div>
<div class='msg'><time>2025‑01‑30 14:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: - `import` host call has been removed in favour of a new `fetch` hostcall; this reduces the amount of data placed in PVM memory up-front and provides a means of extracting data beyond just that concerning the current work-item but for other work-items too.
- All data providing host-calls now accept an offset parameter to allow any contiguous subportion of the data to be read.
- OOB has been (almost) removed. When the outer PVM has a host-call in which it is passed a memory address it cannot access, then it panics irrecoverably.
</div>
<div class='msg'><time>2025‑01‑30 14:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The page faulting specification has also been updated and formalised.</div>
<div class='msg'><time>2025‑01‑30 14:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: This release signals the end of the 0.5 series and, potentially (but probably not), the final protocol revision (not including the stuff which we know will need doing before the end such as gas pricing).</div>
<div class='msg'><time>2025‑01‑30 14:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * This release signals the end of the 0.5 series and, potentially (but probably not), the final protocol revision (not including the obvious stuff which we know will need doing before 1.0 such as gas pricing).</div>
<div class='msg'><time>2025‑01‑30 14:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 0.6 series should contain primarily cleanups, finesse, formatting, discussion and corrections.</div>
<div class='msg'><time>2025‑01‑30 14:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 0.7 and 0.8 will be any important tweaks or optimisations brought on through prototyping and Toaster-testing.</div>
<div class='msg'><time>2025‑01‑30 14:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * 0.7 and 0.8 will be any important tweaks or optimisations brought on through service-prototyping and Toaster-testing.</div>
<div class='msg'><time>2025‑01‑30 14:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 0.9 will be auditing fixes only.</div>
<div class='msg'><time>2025‑02‑02 11:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Version [0.6.1](https://github.com/gavofyork/graypaper/releases/tag/v0.6.1) is released.

This is just a few small corrections and the removal of one of the more complex parts of `fetch`.</div>
<div class='msg'><time>2025‑02‑02 11:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Version [0.6.1](https://github.com/gavofyork/graypaper/releases/tag/v0.6.1) is released.

This is just a few small corrections and a simplification of `fetch`.</div>
<div class='msg'><time>2025‑02‑03 06:12</time>&ensp;<span class='u' style='color:#30c84d'>clw0908</span>: Should **ω_A** be taken modulo **2^32** before being fed into **Χ_4**, since the input of **Χ_4** belongs to **N_32**?

https://graypaper.fluffylabs.dev/#/4bb8fd2/299c0329a303</div>
<div class='msg'><time>2025‑02‑03 08:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes, I expect so - [@jan:parity.io](https://matrix.to/#/@jan:parity.io)?</div>
<div class='msg'><time>2025‑02‑03 09:49</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Yes, since X_4 requires the input to be N_32 there should be a modulo there, otherwise the result would be undefined.

Side note, since I already had questions regarding this: you can think of every 32-bit instruction variant as *always* taking a modulo of its inputs, even though sometimes in the GP we omit this modulo to make the equations simpler if the result would be equivalent anyway, for example in case of `add_32` the result gets truncated anyway so truncating the inputs is unnecessary. The high-level intent is to allow every 32-bit instruction variant to be implemented as follows (to allow for an efficient recompiler implementation): 1) truncate all inputs to 32-bit, 2) do the operation, 3) sign-extend to 64-bit, so if any equation in the GP for 32-bit instruction variants would have given a result that doesn&#x27;t match this please ping me and we&#x27;ll correct it.</div>
<div class='msg'><time>2025‑02‑03 09:49</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: * Yes, since X\_4 requires the input to be N\_32 there should be a modulo there, otherwise the result would be undefined.

Side note, since I already had questions regarding this: you can think of every 32-bit instruction variant as _always_ taking a modulo of its inputs, even though sometimes in the GP we omit this modulo to make the equations simpler if the result would be equivalent anyway, for example in case of `add_32` the result gets truncated anyway so truncating the inputs is unnecessary. The high-level intent is to allow every 32-bit instruction variant to be implemented as follows (to allow for an efficient recompiler implementation): 1) truncate all inputs to 32-bit, 2) do the operation, 3) sign-extend to 64-bit, so if you find any equation in the GP for 32-bit instruction variants would have given a result that doesn&#x27;t match this please ping me and we&#x27;ll correct it.</div>
<div class='msg'><time>2025‑02‑03 11:11</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: Related to an issue we found in testvectors for PVM instruction 206.
Does GP allow for negative output of a modulo operation?
Since this is not explicitly mentioned in section 3, I assume the answer is no. 
If the answer is no, then PolkaVM probably has an incorrect implementation of GP.
https://github.com/gavofyork/graypaper/issues/222</div>
<div class='msg reply'><time>2025‑02‑03 12:04</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: I just replied in the issue: https://github.com/w3f/jamtestvectors/pull/3#issuecomment-2630744952

TLDR: the test vector is correct and what we want; GP might have to be tweaked to account for this</div>
<div class='msg'><time>2025‑02‑03 12:05</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: Yes in that case GP should be adjusted to remove any ambiguity.
GP should to explicitly state that the modulo operator on a negative number yields a negative number, and not a positive number as expected by &#x27;Maths&#x27;.</div>
<div class='msg'><time>2025‑02‑04 09:06</time>&ensp;<span class='u' style='color:#c669dd'>carlos-romano</span>: anyone please? 🙏</div>
<div class='msg'><time>2025‑02‑04 11:31</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@carlos-romano:matrix.org&gt; anyone please? 🙏

I&#x27;ll take a look. Could you please specify one particular test vector so I can review it directly?</div>
<div class='msg reply'><time>2025‑02‑04 12:44</time>&ensp;<span class='u' style='color:#c669dd'>carlos-romano</span>: thanks a lot! All the test vectors modified here:

https://github.com/davxy/jam-test-vectors/commit/729592cf87eb09bc34555f846c5b19f5b1453c52

For example:

reports/tiny/high_work_report_gas-1.json

Probably I am missing something, but for me the right test vectors should be how they were before that commit.</div>
<div class='msg reply'><time>2025‑02‑04 19:28</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@carlos-romano:matrix.org&gt; thanks a lot! All the test vectors modified here:
&gt; 
&gt; https://github.com/davxy/jam-test-vectors/commit/729592cf87eb09bc34555f846c5b19f5b1453c52
&gt; 
&gt; For example:
&gt; 
&gt; reports/tiny/high_work_report_gas-1.json
&gt; 
&gt; Probably I am missing something, but for me the right test vectors should be how they were before that commit.

IIRC this is a change applied after a discussion with a community member. The &quot;reports&quot; STF exercised by these vectors do not change the content of the auth queues. The content of the queues is changed by the &quot;authorizations&quot; test vectors. I&#x27;ll add a note to the readme to make this explicit</div>
<div class='msg reply'><time>2025‑02‑05 07:06</time>&ensp;<span class='u' style='color:#c669dd'>carlos-romano</span>: ahh ok thanks, so then we don&#x27;t need to check them against the STF test vectors post state right? Thanks a lot  🙏</div>
<div class='msg'><time>2025‑02‑04 12:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@emielsebastiaan:matrix.org&gt; Yes in that case GP should be adjusted to remove any ambiguity.
&gt; GP should to explicitly state that the modulo operator on a negative number yields a negative number, and not a positive number as expected by &#x27;Maths&#x27;.

This is corrected/clarified in main. </div>
<div class='msg'><time>2025‑02‑04 16:28</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: I&#x27;ve a question about 14.13. `bold_l` is being constructed by essentially ensuring that all the workpackagehashes (special hash) in the workItems import data segments `i` have a key in the bold_l (14.11) and that the &quot;pointing&quot; value in the `bold_l` dictionary is the previously computed &quot;segmentRoot&quot; of the AVailability specification (14.13).

 - If this is correct then it means guarantors need to maintain a Datastore containing a dictionary of Previously computed WorkResults corect?
 - I don&#x27;t see any limitation of imported segments referencing WorkPackage hashes which generated a report on the same core as the one we&#x27;re trying to compute. This means that a workpackage p could have work items `w` whose reference in its import-segments a workpackagehash w which was computed on another core   </div>
<div class='msg'><time>2025‑02‑04 16:28</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: (0.6.1)</div>
<div class='msg'><time>2025‑02‑04 16:29</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: * I&#x27;ve a question about 14.13. `bold_l` is being constructed by essentially ensuring that all the workpackagehashes (special hash) in the workItems import data segments `i` have a key in the bold\_l (14.11) and that the &quot;pointing&quot; value in the `bold_l` dictionary is the **previously** computed &quot;segmentRoot&quot; of the AVailability specification (14.13).

- If this is correct then it means guarantors need to maintain a Datastore containing a dictionary of Previously computed WorkResults corect?
- I don&#x27;t see any limitation of imported segments referencing WorkPackage hashes which generated a report on the same core as the one we&#x27;re trying to compute. This means that a workpackage p could have work items `w` whose reference in its import-segments a workpackagehash w which was computed on another core</div>
<div class='msg'><time>2025‑02‑04 19:29</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: * IIRC this is a change applied after a discussion with a community member. The &quot;reports&quot; STF exercised by these vectors do not change the content of the auth queues. The content of the queues is changed by the &quot;authorizations&quot; test vectors. I&#x27;ll add a note to the readme to make this explicit</div>
<div class='msg'><time>2025‑02‑04 19:31</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: * The &quot;reports&quot; STF exercised by these vectors do not change the content of the auth queues. The content of the queues is changed by the &quot;authorizations&quot; test vectors. I&#x27;ll add a note to the readme to make this explicit</div>
<div class='msg'><time>2025‑02‑04 19:32</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: * The &quot;reports&quot; STF exercised by these vectors has been modified to not change the content of the auth queues. The content of the queues is changed by the &quot;authorizations&quot; test vectors. I&#x27;ll add a note to the readme to make this explicit</div>
<div class='msg'><time>2025‑02‑05 09:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; I&#x27;ve a question about 14.13. `bold_l` is being constructed by essentially ensuring that all the workpackagehashes (special hash) in the workItems import data segments `i` have a key in the bold\_l (14.11) and that the &quot;pointing&quot; value in the `bold_l` dictionary is the **previously** computed &quot;segmentRoot&quot; of the AVailability specification (14.13).
&gt; 
&gt; - If this is correct then it means guarantors need to maintain a Datastore containing a dictionary of Previously computed WorkResults corect?
&gt; - I don&#x27;t see any limitation of imported segments referencing WorkPackage hashes which generated a report on the same core as the one we&#x27;re trying to compute. This means that a workpackage p could have work items `w` whose reference in its import-segments a workpackagehash w which was computed on another core

1. Correct

2. Nodes need only keep fairly recent WPH-&gt;SR history, since it is known that they must pass the on-chain WPH-&gt;SR lookup. Ultimately guarantors are free to ignore work packages whose imports they deem unreasonable, unknowable or unlikely to result in a profitable endeavour. </div>
<div class='msg'><time>2025‑02‑05 09:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; I&#x27;ve a question about 14.13. `bold_l` is being constructed by essentially ensuring that all the workpackagehashes (special hash) in the workItems import data segments `i` have a key in the bold_l (14.11) and that the &quot;pointing&quot; value in the `bold_l` dictionary is the previously computed &quot;segmentRoot&quot; of the AVailability specification (14.13).
&gt; 
&gt;  - If this is correct then it means guarantors need to maintain a Datastore containing a dictionary of Previously computed WorkResults corect?
&gt;  - I don&#x27;t see any limitation of imported segments referencing WorkPackage hashes which generated a report on the same core as the one we&#x27;re trying to compute. This means that a workpackage p could have work items `w` whose reference in its import-segments a workpackagehash w which was computed on another core   

* 1. Correct

2. Nodes need only keep fairly recent WPH-&gt;SR history, since it is known that the resultant report  must pass the on-chain WPH-&gt;SR lookup whose history is limited. Ultimately guarantors are free to ignore work packages whose imports they deem unreasonable, unknowable or unlikely to result in a profitable endeavour. </div>
<div class='msg'><time>2025‑02‑05 09:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; I&#x27;ve a question about 14.13. `bold_l` is being constructed by essentially ensuring that all the workpackagehashes (special hash) in the workItems import data segments `i` have a key in the bold_l (14.11) and that the &quot;pointing&quot; value in the `bold_l` dictionary is the previously computed &quot;segmentRoot&quot; of the AVailability specification (14.13).
&gt; 
&gt;  - If this is correct then it means guarantors need to maintain a Datastore containing a dictionary of Previously computed WorkResults corect?
&gt;  - I don&#x27;t see any limitation of imported segments referencing WorkPackage hashes which generated a report on the same core as the one we&#x27;re trying to compute. This means that a workpackage p could have work items `w` whose reference in its import-segments a workpackagehash w which was computed on another core   

* 1. Correct

2. Nodes need only keep fairly recent WPH-&gt;SR history, since it is known that the resultant report  must pass the on-chain WPH-&gt;SR lookup whose history is limited. Ultimately guarantors are free to ignore work packages whose imports they deem unreasonable, unknowable or unlikely to result in a profitable endeavour. To pass the conformance tests nodes need only be able to make guarantees under reasonable conditions.  </div>
<div class='msg'><time>2025‑02‑05 09:23</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: Thanks for this. Will it ever be specified in graypaper? Especially the &quot;fairly recent&quot; or &quot;reasonable conditions&quot;?</div>
<div class='msg'><time>2025‑02‑05 09:24</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: I think the same might be applied on 14.14 which basically is implying that there is a datastore from the MerkleTreeRoot and its &quot;preimage&quot;</div>
<div class='msg'><time>2025‑02‑05 09:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@prematurata:matrix.org&gt; Thanks for this. Will it ever be specified in graypaper? Especially the &quot;fairly recent&quot; or &quot;reasonable conditions&quot;?

Guaranteeing is a strategic endeavour, and the Gray Paper generally avoids dictating strategy. </div>
<div class='msg'><time>2025‑02‑05 09:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: However the aspect of “fairly recent” is well-specified in terms of on-chain behaviour. See equations 12.4-12.8</div>
<div class='msg'><time>2025‑02‑05 09:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Of course a guarantor would need to guess when their guaranteed work-report would likely make it to accumulation in order to apply this limit to the strategy of guaranteeing. </div>
<div class='msg'><time>2025‑02‑05 11:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: But given that guaranteers are responsible for the same core for 10 blocks at a time and receive all guarantees across (even across other cores), then it&#x27;s quite possible to make a pretty decent guess on the quality and size of the backlog and how long it might be before the new report would make it on-chain.</div>
<div class='msg'><time>2025‑02‑05 11:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * But given that guarantors are responsible for the same core for 10 blocks at a time and receive all guarantees across (even across other cores), then it&#x27;s quite possible to make a pretty decent guess on the quality and size of the backlog and how long it might be before the new report would make it on-chain.</div>
<div class='msg'><time>2025‑02‑05 11:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * But given that guarantors are responsible for the same core for 10 blocks at a time and receive all guarantees across (even across other cores), then it&#x27;s quite possible to make a pretty decent guess on the quality and size of the core&#x27;s backlog and how long it might be before the new report would make it on-chain.</div>
<div class='msg'><time>2025‑02‑05 11:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: See also 11.40/41: https://graypaper.fluffylabs.dev/#/4bb8fd2/150302152d02</div>
<div class='msg'><time>2025‑02‑05 14:17</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: Thanks gavin. I also have another question about the new fetch. Is it intended for μ′_{o⋅⋅⋅+l</div>
<div class='msg'><time>2025‑02‑05 14:19</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: * Thanks gavin. I also have another question about the new fetch. 

- Is it intended for μ′\_{o⋅⋅⋅+l} to be updated even in case of a panic? Ex when w9 is 5 and memory between w10 and +32 is readable.

- also what is bold x? </div>
<div class='msg'><time>2025‑02‑05 14:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: In the case of a panic, memory remains the same (though since panic at the top level is unrecoverable, it doesn’t really matter)</div>
<div class='msg'><time>2025‑02‑05 14:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There is a superfluous condition there - the additional omega_9 term for a panic. This will be removed in the next revision. This will then make it very clear that memory does not change in the case of a panic. </div>
<div class='msg'><time>2025‑02‑06 06:51</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: did you discovered what that bold x is? </div>
<div class='msg'><time>2025‑02‑06 08:42</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: no, I have no idea. my first guess would have been A.7 but according to that it seems bold x woudld then be a set containing numbers \in N_{2^32} and that would make no sense in the fetch definition</div>
<div class='msg'><time>2025‑02‑06 11:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: @room : [v0.6.2](https://github.com/gavofyork/graypaper/releases/tag/v0.6.2) is out - contains all the latest corrections.</div>
<div class='msg'><time>2025‑02‑06 11:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Bold x is any value which satisfies the various conditions. You&#x27;ll find that practically speaking, there&#x27;s only one which anyone could possibly know.</div>
<div class='msg'><time>2025‑02‑06 11:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Bold x is any value which satisfies the various conditions on it. You&#x27;ll find that practically speaking, there&#x27;s only one which anyone could possibly know.</div>
<div class='msg'><time>2025‑02‑06 11:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Bold x is any value which satisfies the various conditions on it. You&#x27;ll find that practically speaking, there&#x27;s only one which anyone could reasonably know.</div>
<div class='msg'><time>2025‑02‑06 11:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It&#x27;s used specifically for extrinsics, where an extrinsic is specified in the WP as a hash/len. We assert that we know the preimage since we would not get to this part of the guarantee pipeline without knowing.</div>
<div class='msg'><time>2025‑02‑06 11:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Alternatively it could have been made explicit with an additional term being passed in to the Refine function and its context, but that would have just complicated the formulation.</div>
<div class='msg'><time>2025‑02‑06 11:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The GP isn&#x27;t about describing a node&#x27;s internal _data-logistics_; that&#x27;s an implementation-specific consideration. It only concerns outward *behaviour*.</div>
<div class='msg'><time>2025‑02‑06 16:02</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: &gt; &lt;@gav:polkadot.io&gt; @room : [v0.6.2](https://github.com/gavofyork/graypaper/releases/tag/v0.6.2) is out - contains all the latest corrections.

3 PRs with pvm instruction modifications are pending review at your convenience. </div>
<div class='msg'><time>2025‑02‑06 16:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Merged one - will wait for Jan Bujak to take a look at the others.</div>
<div class='msg'><time>2025‑02‑06 16:09</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Yeah, since in the GP we &quot;store&quot; the values unsigned those were definitely missing the conversions back, LGTM.</div>
<div class='msg'><time>2025‑02‑06 16:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: All merged - will be in 0.6.3</div>
<div class='msg'><time>2025‑02‑06 16:41</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: I may have found one more for 0.6.3: https://github.com/gavofyork/graypaper/pull/231
Header / Bandersnatch related (`H_a`)</div>
<div class='msg'><time>2025‑02‑07 14:00</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: Should the zero host function have the same error condition as the void host function? The one about pages being inaccessible

https://graypaper.fluffylabs.dev/#/5f542d7/35a90235a902</div>
<div class='msg'><time>2025‑02‑07 14:30</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: The logic for getting the service in the read host function is very similar to the lookup host function: https://graypaper.fluffylabs.dev/#/5f542d7/305c00305c00

They could be unified to make it easier to read.</div>
<div class='msg'><time>2025‑02‑07 15:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: In the case of `void`, the pages must all be accessible because we&#x27;re making them inaccessible.</div>
<div class='msg'><time>2025‑02‑07 15:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: We wouldn&#x27;t want exactly that condition for `zero` whose job is to initialize pages to being accessible and zero.</div>
<div class='msg'><time>2025‑02‑07 15:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: We could introduce a condition to require them to be previously inaccessible, but currently we don&#x27;t. This was intented, but maybe it should be changed if requiring it bring us more performance impls ( Jan Bujak ?)</div>
<div class='msg'><time>2025‑02‑07 15:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Feel free to make a PR :P</div>
<div class='msg'><time>2025‑02‑07 15:12</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * PRs are considered :P</div>
<div class='msg'><time>2025‑02‑07 15:13</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: Will do</div>
<div class='msg'><time>2025‑02‑07 15:13</time>&ensp;<span class='u' style='color:#5cdeb7'>cisco</span>: * Will make a PR for that unification </div>
<div class='msg'><time>2025‑02‑07 15:30</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: The lack of requirement in `zero` that the pages are inaccessible is indeed intended so that e.g. this host call can be used to clear/reinitialize memory without first having to void it nor track what is already allocated. Requiring it wouldn&#x27;t really change anything performance-wise since you have to (or the OS has to) iterate over the page map to find the holes to fill anyway. (And in practice not requiring this check can make things simpler because you can just ask the OS to zero allocate an address range in bulk instead of having to do this yourself.)

Hm, but now that I think about it we probably should make `void` not require the pages to be accessible either, as that could simplify its usage in certain cases (and, same as with `zero`, the page map has to be iterated over anyway by the implementation, whether it returns an error or not). Basically have it take a range of pages we want it to free, and when it returns it&#x27;ll guarantee that the whole range is now free. So the `HUH` error branch could just be deleted altogether (since voiding the first 64k or out-of-bounds would be a no-op as there can&#x27;t never be anything allocated there anyway).</div>
<div class='msg'><time>2025‑02‑09 01:25</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: </div>
<div class='msg'><time>2025‑02‑09 02:00</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: Is anyone aware of any Go libraries which implement bandersnatch vrf signatures? Seems the main implementations are in Rust for now</div>
<div class='msg reply'><time>2025‑02‑09 17:08</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: Not aware of any other than davxys work on this. Have it on my list to investigate as a potential SPOF for the network.</div>
<div class='msg'><time>2025‑02‑09 03:02</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: * Is anyone aware of any non-rust libraries which implement bandersnatch vrf signatures? Seems the main implementations are in Rust for now</div>
<div class='msg'><time>2025‑02‑09 18:55</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@ascriv:matrix.org&gt; Is anyone aware of any non-rust libraries which implement bandersnatch vrf signatures? Seems the main implementations are in Rust for now

AFAIK, `arc-ec-vrfs` is currently the only implementation available. This is likely because the scheme is not standardized, thus any existing implementation should be tied to JAM.

For those interested in implementing it, the details of Bandersnatch VRFs are soecified here: https://github.com/davxy/bandersnatch-vrfs-spec. Implementing the &quot;plain&quot; VRF is **relatively** straightforward, especially with the support of a &quot;bigint&quot; library, making it a manageable task.

However, the complexity increases significantly when dealing with the ring-VRF variant. Even though it is thoroughly specified here: https://github.com/davxy/ring-proof-spec, implementing it requires a library that supports the underlying SNARK framework it relies on. Since there are no official standards (only de facto ones, at best), you’ll likely need to build many things from scratch. 

We have been using [arkworks](https://arkworks.rs/) for this, as it provides **most** of the tools necessary. That said, some additional components were developed by the W3F team and ourselves to fill in the gaps anyway.

In summary, if someone is inclined to implement any of these components (also by building over arkworks, for example), I’m available to provide some support. Additionally, test vectors are available for validating conformance.</div>
<div class='msg'><time>2025‑02‑09 19:20</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: Since implementing it from scratch is so challenging, it seems essentially everyone will rely on the one implementation that is available (using something like go’s FFI if they’re not implementing jam in rust), which becomes a redundancy and a failure point. It’s probably well audited and as a single point of failure still probably ok though.</div>
<div class='msg'><time>2025‑02‑09 19:21</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: I would love if people reimplement it of their own volition in their chosen language but I think we might need additional incentives if we do think relying on just this one implementation is in fact an issue </div>
<div class='msg'><time>2025‑02‑09 22:16</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@ascriv:matrix.org&gt; Is anyone aware of any Go libraries which implement bandersnatch vrf signatures? Seems the main implementations are in Rust for now

* AFAIK, `arc-ec-vrfs` is currently the only implementation available. This is likely because the scheme is not standardized, thus any existing implementation should be tied to JAM.

For those interested in implementing it, the details of Bandersnatch VRFs are soecified here: https://github.com/davxy/bandersnatch-vrfs-spec. Implementing the &quot;plain&quot; VRF is **relatively** straightforward, especially with the support of a &quot;bigint&quot; library, making it a manageable task.

However, the complexity increases significantly when dealing with the ring-VRF variant. Even though it is thoroughly specified here: https://github.com/davxy/ring-proof-spec , implementing it requires a library that supports the underlying SNARK framework it relies on. Since there are no official standards (only de facto ones, at best), you’ll likely need to build many things from scratch. 

We have been using [arkworks](https://arkworks.rs/) for this, as it provides **most** of the tools necessary. That said, some additional components were developed by the W3F team and ourselves to fill in the gaps anyway.

In summary, if someone is inclined to implement any of these components (also by building over arkworks, for example), I’m available to provide some support. Additionally, test vectors are available for validating conformance.</div>
<div class='msg'><time>2025‑02‑10 18:08</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: </div>
<div class='msg'><time>2025‑02‑10 18:35</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: In the preimages extrinsic:

1.- Do the service-data pairs have to be [ordered](https://graypaper.fluffylabs.dev/#/5f542d7/184800184800) *only* by service id? Or do we also have to consider the order of the data blob?
2.- The R function of the eq [(12.30)](https://graypaper.fluffylabs.dev/#/5f542d7/185e00185e00) is the same that the one defined in eq [(12.23)](https://graypaper.fluffylabs.dev/#/5f542d7/17ce0317ce03)?</div>
<div class='msg'><time>2025‑02‑10 18:35</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: * In the preimages extrinsic:

1.- Do the service-data pairs have to be [ordered](https://graypaper.fluffylabs.dev/#/5f542d7/184800184800) _only_ by service id? Or do we also have to consider the order of the data blob?
2.- The R function of the eq [(12.30)](https://graypaper.fluffylabs.dev/#/5f542d7/185e00185e00) is the one defined in eq [(12.23)](https://graypaper.fluffylabs.dev/#/5f542d7/17ce0317ce03)?</div>
<div class='msg'><time>2025‑02‑10 18:36</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: * In the preimages extrinsic:

1.- Do the service-data pairs have to be [ordered](https://graypaper.fluffylabs.dev/#/5f542d7/184800184800) _only_ by service id? Or do we also have to consider the order of the data blob?
2.- Is the R function of eq [(12.30)](https://graypaper.fluffylabs.dev/#/5f542d7/185e00185e00) the one defined in eq [(12.23)](https://graypaper.fluffylabs.dev/#/5f542d7/17ce0317ce03)?</div>
<div class='msg'><time>2025‑02‑10 18:40</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: * 1.- In the preimages extrinsic, do the service-data pairs have to be [ordered](https://graypaper.fluffylabs.dev/#/5f542d7/184800184800) _only_ by service id? Or do we also have to consider the order of the data blob?
2.- Is the R function of eq [(12.30)](https://graypaper.fluffylabs.dev/#/5f542d7/185e00185e00) the one defined in eq [(12.23)](https://graypaper.fluffylabs.dev/#/5f542d7/17ce0317ce03)?</div>
<div class='msg'><time>2025‑02‑10 19:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 1. Both, primarily service ID and then data blob. Same goes for any tuple. </div>
<div class='msg'><time>2025‑02‑10 19:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 2. No. R in 12.30 and 12.31 are the same. R in 12.23 and 2.24 are the same. I might rename one of them to avoid the confusion. </div>
<div class='msg'><time>2025‑02‑10 19:45</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: got it, thanks 👍️</div>
<div class='msg'><time>2025‑02‑10 19:58</time>&ensp;<span class='u' style='color:#de60df'>leonidas_m</span>: The GP assumes that we know the preimage data because there&#x27;s only one value that satisfies the necessary conditions. However, since the Refine function neither allows passing the preimage explicitly as a parameter nor permits querying the state, it&#x27;s unclear where this data should come from.

Should the preimage be retrieved from a node&#x27;s internal data store (local database), or is it expected to be fetched from an external source (e.g., network)?</div>
<div class='msg'><time>2025‑02‑10 21:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The latter. </div>
<div class='msg'><time>2025‑02‑10 21:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Validator nodes are expected to be sent preimages directly from external sources. </div>
<div class='msg'><time>2025‑02‑10 21:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Validator nodes are expected to be sent solicited preimages directly from external sources. </div>
<div class='msg'><time>2025‑02‑11 16:04</time>&ensp;<span class='u' style='color:#7178d3'>arjanz</span>: I believe to have corrected two small typos in appendix D, \H_0 should be \H^0: https://github.com/gavofyork/graypaper/pull/234</div>
<div class='msg'><time>2025‑02‑11 16:10</time>&ensp;<span class='u' style='color:#788ad5'>yu2c</span>: https://matrix.to/#/!ddsEwXlCWnreEGuqXZ:polkadot.io/$aFpJR-J3zqDbApsjZ3qMX-QjOVoZnYSYG2oTSPPCDB0?via=polkadot.io&amp;via=matrix.org&amp;via=parity.io</div>
<div class='msg'><time>2025‑02‑12 00:39</time>&ensp;<span class='u' style='color:#7875cf'>charliewinston14</span>: Hello I have a few questions I was hoping someone could help with.

1. Is there a formal definition of a work package bundle other than the textual description in 14.4.1? It mentions the attributes but not the data types of each attribute.
2. The extrinsic data in a work package bundle, is it a list of hashes and lengths? Or is this the full preimages themselves?
3. The exported segments in a work package bundle, or they the actual segments of length 4104? Or are they a list of root and indexes?
4. Is the extrinsic that’s passed in CE133 the same as what’s in a work package bundle? If so why is it included in CE133 if it can just be calculated based off the work package by the receiver using X(w) in 14.14
</div>
<div class='msg'><time>2025‑02‑12 13:38</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: Hello I thought about opening an issue on graypaper repo instead of reporting here as it was/is a bit complicated matter to write here
 https://github.com/gavofyork/graypaper/issues/239 </div>
<div class='msg'><time>2025‑02‑12 15:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@charliewinston14:matrix.org&gt; Hello I have a few questions I was hoping someone could help with.
&gt; 
&gt; 1. Is there a formal definition of a work package bundle other than the textual description in 14.4.1? It mentions the attributes but not the data types of each attribute.
&gt; 2. The extrinsic data in a work package bundle, is it a list of hashes and lengths? Or is this the full preimages themselves?
&gt; 3. The exported segments in a work package bundle, or they the actual segments of length 4104? Or are they a list of root and indexes?
&gt; 4. Is the extrinsic that’s passed in CE133 the same as what’s in a work package bundle? If so why is it included in CE133 if it can just be calculated based off the work package by the receiver using X(w) in 14.14
&gt; 

1. It is the second argument to A in 14.15</div>
<div class='msg'><time>2025‑02‑12 15:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 2. A bundle has the extrinsic data; see 14.14 X. </div>
<div class='msg'><time>2025‑02‑12 15:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 3. A bundle has the actual segments and justifications. See 14.14 S and J. </div>
<div class='msg'><time>2025‑02‑12 15:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 4. 14.14 X assumes knowledge of the relevant hash preimages. The receiver may not have such knowledge therefore it makes sense to provide it. Theoretically we could make it an on-demand thing later. </div>
<div class='msg'><time>2025‑02‑13 10:16</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: Add tau &amp; tau_prime as state transition input dependencyhttps://github.com/gavofyork/graypaper/pull/241</div>
<div class='msg'><time>2025‑02‑13 10:17</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: * Adds tau &amp; tau\_prime as state transition input dependency.

https://github.com/gavofyork/graypaper/pull/241</div>
<div class='msg'><time>2025‑02‑14 11:49</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Where does the odd number [81](https://graypaper.fluffylabs.dev/#/5f542d7/114c01114c01) from the `a_o` service storage size formula come from? </div>
<div class='msg'><time>2025‑02‑14 12:07</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * How is the strangely odd number [81](https://graypaper.fluffylabs.dev/#/5f542d7/114c01114c01) from the `a_o` service storage size formula derived?   The 32 within the same formula is the storage for key, but 81 is 17 more bytes than 64...</div>
<div class='msg'><time>2025‑02‑14 19:27</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: For initializing the ring context for bandersnatch ring vrf stuff, there must be a common seed we’ll all be using? So that it remains deterministic </div>
<div class='msg'><time>2025‑02‑14 19:33</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: I assume we use the parameters in 4.1 configuration in https://github.com/davxy/bandersnatch-vrfs-spec/blob/main/specification.pdf but wanted to confirm </div>
<div class='msg'><time>2025‑02‑14 21:58</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@ascriv:matrix.org&gt; I assume we use the parameters in 4.1 configuration in https://github.com/davxy/bandersnatch-vrfs-spec/blob/main/specification.pdf but wanted to confirm 

Correct. If and when anything changes, I&#x27;ll update the spec and notify all JAM channels.

</div>
<div class='msg'><time>2025‑02‑16 18:27</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: I think I have a correction for the state transition dependency graph: lambda prime needs to be added to the inputs for the state transition for the validator statistics, since we need to compute the reporters set which requires G* which requires lambda prime</div>
<div class='msg'><time>2025‑02‑17 08:36</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Hi everyone,

I have a question about accumulation regarding the call to the accumulate function.

We call Ψ_A in equation (12.19) [GP version 0.6.1] at the accumulation stage.
I&#x27;m following the formalism of the white paper.

Should this function call alter δ, or does it return a new account (like the Ω functions) that needs to be accumulated/saved later in equation (12.21)?

Am I clear? 😅</div>
<div class='msg'><time>2025‑02‑17 08:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The accumulate function is used in the final definition of posterior delta. It is up to implementations to determine at what point they alter any particular internal data structure(s).</div>
<div class='msg reply'><time>2025‑02‑17 08:49</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: thanks</div>
<div class='msg'><time>2025‑02‑17 08:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * The accumulate function is used in the final definition of posterior delta. It is up to implementations to determine at what point they alter any particular internal data structure(s) which may represent delta or some partial intermediate value of it. </div>
<div class='msg'><time>2025‑02‑17 08:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * The accumulate function is used in the final definition of posterior delta. It is up to implementations to determine at what point they alter any particular internal data structure(s) which may represent delta or some partial/intermediate value of it. </div>
<div class='msg'><time>2025‑02‑17 08:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: One thing which will be very helpful to know is that no two accumulate functions which both contribute to the same “wave” of accumulations will have contradictory changes. </div>
<div class='msg'><time>2025‑02‑17 21:31</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: </div>
<div class='msg'><time>2025‑02‑17 22:08</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: ignore previous message.. mistake on our end</div>
<div class='msg'><time>2025‑02‑17 22:19</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: apologies for the inconvenience Jan Bujak </div>
<div class='msg'><time>2025‑02‑18 04:38</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: We believe the notation ${\bf p}_{\bf c}$ used in Eq B.2 [here](https://graypaper.fluffylabs.dev/#/5f542d7/2cf8022cf802) needs to be adjusted to accommodate service $h$ and authorization code hash $u$ of 14.2 [here](https://graypaper.fluffylabs.dev/#/5f542d7/197900197900) -- that the preimage $u$ of service $h$ is the authorization code input to $\Psi_M$ of B.2.   Can something confirm this interpretation is correct?

Specifically, the genesis state with bootstrap service 0 will have a null authorizer code hash (say, 0x12344321...) and the very first work package ${\bf p}$ (to create a new service) will have $h=0$ and $u=0x12344321...$ to reference this null authorizer.

Does that make sense?</div>
<div class='msg'><time>2025‑02‑18 04:39</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * We believe the notation ${\\bf p}\_{\\bf c}$ used in Eq B.2 [here](https://graypaper.fluffylabs.dev/#/5f542d7/2cf8022cf802) needs to be adjusted to accommodate service $h$ and authorization code hash $u$ of 14.2 [here](https://graypaper.fluffylabs.dev/#/5f542d7/197900197900) -- that the preimage $u$ of service $h$ is the authorization code input to $\\Psi\_M$ of B.2.   Can someone confirm this interpretation is correct?

Specifically, the genesis state with bootstrap service 0 will have a null authorizer code hash (say, 0x12344321...) and the very first work package ${\\bf p}$ (to create a new service) will have $h=0$ and $u=0x12344321...$ to reference this null authorizer.

Does that make sense?</div>
<div class='msg'><time>2025‑02‑18 04:51</time>&ensp;<span class='u' style='color:#4068cd'>0xjunha</span>: Description of accumulate queue-editing function (*E*) seems outdated -  opened a PR to update it.
https://github.com/gavofyork/graypaper/pull/246</div>
<div class='msg'><time>2025‑02‑18 05:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; We believe the notation ${\\bf p}\_{\\bf c}$ used in Eq B.2 [here](https://graypaper.fluffylabs.dev/#/5f542d7/2cf8022cf802) needs to be adjusted to accommodate service $h$ and authorization code hash $u$ of 14.2 [here](https://graypaper.fluffylabs.dev/#/5f542d7/197900197900) -- that the preimage $u$ of service $h$ is the authorization code input to $\\Psi\_M$ of B.2.   Can someone confirm this interpretation is correct?
&gt; 
&gt; Specifically, the genesis state with bootstrap service 0 will have a null authorizer code hash (say, 0x12344321...) and the very first work package ${\\bf p}$ (to create a new service) will have $h=0$ and $u=0x12344321...$ to reference this null authorizer.
&gt; 
&gt; Does that make sense?

No</div>
<div class='msg'><time>2025‑02‑18 05:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * No - having trouble interpreting this</div>
<div class='msg'><time>2025‑02‑18 05:07</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Sorry -- how does Eq B.2&#x27;s first input of $\Psi_M$ ( which is ${\bf p}_{\bf c}$) get at a work package&#x27;s authorization code?  

</div>
<div class='msg'><time>2025‑02‑18 05:08</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * Sorry -- how does Eq B.1&#x27;s first input of $\\Psi\_M$ ( which is ${\\bf p}\_{\\bf c}$) get at a work package&#x27;s authorization code?</div>
<div class='msg'><time>2025‑02‑18 05:08</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * We believe the notation ${\\bf p}\_{\\bf c}$ used in Eq B.1 [here](https://graypaper.fluffylabs.dev/#/5f542d7/2cf8022cf802) needs to be adjusted to accommodate service $h$ and authorization code hash $u$ of 14.2 [here](https://graypaper.fluffylabs.dev/#/5f542d7/197900197900) -- that the preimage $u$ of service $h$ is the authorization code input to $\\Psi\_M$ of B.2.   Can someone confirm this interpretation is correct?

Specifically, the genesis state with bootstrap service 0 will have a null authorizer code hash (say, 0x12344321...) and the very first work package ${\\bf p}$ (to create a new service) will have $h=0$ and $u=0x12344321...$ to reference this null authorizer.

Does that make sense?</div>
<div class='msg'><time>2025‑02‑18 05:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: See 14.9</div>
<div class='msg'><time>2025‑02‑18 13:26</time>&ensp;<span class='u' style='color:#de60df'>leonidas_m</span>: Hey, I&#x27;ve noticed that some PVM tests (eg `inst_load_u8_nok`, `inst_store_u8_trap_inaccessible`) charge more than 1 extra gas when a page fault occurs even though only a single instruction is executed. In previous commits, similar tests were removed because the cost model was based on polkaVM and wasn&#x27;t specified in the GP. Are these tests facing the same issue now or am I misunderstanding something?</div>
<div class='msg reply'><time>2025‑02‑18 20:27</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Yes.</div>
<div class='msg reply'><time>2025‑02‑19 07:58</time>&ensp;<span class='u' style='color:#de60df'>leonidas_m</span>: Looks like the same issue also affects the following test vectors:
`inst_store_imm_indirect_u16_with_offset_nok` 
`inst_store_imm_indirect_u32_with_offset_nok`
`inst_store_imm_indirect_u64_with_offset_nok`
`inst_store_imm_indirect_u8_with_offset_nok`
`inst_store_imm_u8_trap_inaccessible`
`inst_store_indirect_u16_with_offset_nok`
`inst_store_indirect_u32_with_offset_nok`
`inst_store_indirect_u64_with_offset_nok`
`inst_store_indirect_u8_with_offset_nok`</div>
<div class='msg'><time>2025‑02‑19 12:37</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Hi guys,

Just some question related to safrole:

Equations (6.15), (6.16), (6.17), (6.18), (6.19), (6.20) - GP version 6.2 - refer to gamma_s&#x27; and eta_3&#x27; =&gt; so we should update gamma_s and eta_3 before ? Therefore, we should compute equations (6.23), (6.24) before checking equations (6.15), (6.16), (6.17), (6.18), (6.19), (6.20) ?</div>
<div class='msg reply'><time>2025‑02‑19 13:28</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: I had a similar Q and that is was i ended up doing. It seems that the gamma states cannot be updated at once anymore but need to be done in two steps</div>
<div class='msg reply'><time>2025‑02‑19 13:33</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Can you elaborate please ? 🙃
Should we update gamma then before making the header check of equation (6.15)-(6.20) ?</div>
<div class='msg reply'><time>2025‑02‑19 14:57</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: We first do gamma_k &amp; gamma_z, then check entropy marker H_e and then gamma_s &amp; gamma_a.  
Not sure if that is optimal, it was just what i coded up first 🤷</div>
<div class='msg'><time>2025‑02‑19 14:21</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: That’s how I interpret the equations, since they involve posterior variables, the posterior variables must be computed already </div>
<div class='msg'><time>2025‑02‑20 12:10</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: I want a JAM codec expression after [here](https://graypaper.fluffylabs.dev/#/5f542d7/381700381700) to fully detail [wrangled operand tuples](https://graypaper.fluffylabs.dev/#/5f542d7/17fa0117fa01) to support [the key input into single accumulate](https://graypaper.fluffylabs.dev/#/5f542d7/2e89002e8900) -- is this reasonable?</div>
<div class='msg'><time>2025‑02‑20 12:20</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * I want a JAM codec expression after [here](https://graypaper.fluffylabs.dev/#/5f542d7/381700381700) to fully detail [wrangled operand tuples](https://graypaper.fluffylabs.dev/#/5f542d7/17fa0117fa01) to support [this ${\bf o}$ input into single accumulate](https://graypaper.fluffylabs.dev/#/5f542d7/2e89002e8900) -- is this reasonable?</div>
<div class='msg'><time>2025‑02‑20 12:37</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Also, due to [GP Eq 4.7](https://graypaper.fluffylabs.dev/#/5f542d7/095f00095f00) it seems technically JAM departs from good old [GP Eq 4.1](https://graypaper.fluffylabs.dev/#/5f542d7/087a00087a00) in needing [accumulation result tree root $r$](https://graypaper.fluffylabs.dev/#/5f542d7/0fe4010fe401) summarizing ${\bf C}$ from the state before $\sigma$.</div>
<div class='msg'><time>2025‑02‑20 12:38</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * Also, due to [GP Eq 4.7](https://graypaper.fluffylabs.dev/#/5f542d7/095f00095f00) it seems technically JAM departs from good old [GP Eq 4.1](https://graypaper.fluffylabs.dev/#/5f542d7/087a00087a00) in needing [accumulation result tree root $r$](https://graypaper.fluffylabs.dev/#/5f542d7/0fe4010fe401) summarizing ${\\bf C}$ from the state before $\\sigma$.  So, a &quot;state_transition&quot; has to include $r$  (or ${\bf C}$) like [this](https://github.com/jam-duna/jamtestnet/blob/0.6.2.3/data/assurances/state_transitions/1_005.json#L289) -- yes?</div>
<div class='msg'><time>2025‑02‑20 12:42</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * Also, due to [GP Eq 4.7](https://graypaper.fluffylabs.dev/#/5f542d7/095f00095f00) it seems technically JAM departs from good old [GP Eq 4.1](https://graypaper.fluffylabs.dev/#/5f542d7/087a00087a00) in needing [accumulation result tree root $r$](https://graypaper.fluffylabs.dev/#/5f542d7/0fe4010fe401) summarizing ${\\bf C}$ from the state before $\\sigma$.  So, to verify a isolated JAM &quot;state\_transition&quot;, it has to not only include two states and block, but ALSO include this $r$  (or the _whole_ [Beefy commitment map ${\\bf C}$](https://graypaper.fluffylabs.dev/#/5f542d7/172a03172a03)) like [this](https://github.com/jam-duna/jamtestnet/blob/0.6.2.3/data/assurances/state_transitions/1_005.json#L289) -- can someone confirm this?</div>
<div class='msg'><time>2025‑02‑20 12:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; I want a JAM codec expression after [here](https://graypaper.fluffylabs.dev/#/5f542d7/381700381700) to fully detail [wrangled operand tuples](https://graypaper.fluffylabs.dev/#/5f542d7/17fa0117fa01) to support [this ${\bf o}$ input into single accumulate](https://graypaper.fluffylabs.dev/#/5f542d7/2e89002e8900) -- is this reasonable?

Not sure what you’re talking about. </div>
<div class='msg reply'><time>2025‑02‑20 14:23</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Will refine our guess --  https://hackmd.io/@sourabhniyogi/wrangledoperandtuples</div>
<div class='msg'><time>2025‑02‑20 12:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: O is defined properly. </div>
<div class='msg'><time>2025‑02‑20 12:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It can easily be fed into the serialization function. </div>
<div class='msg'><time>2025‑02‑20 12:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Its result can easily be fed into the serialization function. </div>
<div class='msg'><time>2025‑02‑20 12:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: As used in C.23</div>
<div class='msg'><time>2025‑02‑20 14:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: </div>
<div class='msg'><time>2025‑02‑20 14:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Cool - looks like you’ve already done most of the work for a PR to sort this - want to submit one?</div>
<div class='msg reply'><time>2025‑02‑20 18:09</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: If someone else gets our refine =&gt; accumulate, we will give it a shot!  </div>
<div class='msg'><time>2025‑02‑20 18:10</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * If someone else agrees with it, we will give it a shot!  </div>
<div class='msg'><time>2025‑02‑22 00:16</time>&ensp;<span class='u' style='color:#7875cf'>charliewinston14</span>: Hello.

I’m having some difficulty understanding the erasure root formula in the GP, specifically calculating “s♣” in 14.16.

Hoping someone can point me in the right direction. 

I had no problem calculating “b♣” and have my erasure coding function C and paged proof generation function P already.

The s♣ formula has C#6 (s⌢ P(s))), where S is an array and P(S) is an array as well. Does that mean to concatenate them both together and then pass to chunking function?  I think it’s the # that is confusing me as that normally means apply to each of the sub items. There is also a # on the binary merkle call so I’m assuming that I need to call the merkle function multiple times and not just once with the results of the erasure encoding but not understanding the formula at all. Can someone give me a tip of how to proceed with it?

https://graypaper.fluffylabs.dev/#/5f542d7/1b4c011b5701
</div>
<div class='msg'><time>2025‑02‑22 01:57</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: Is there a very rough estimate for v1.0.0? Trying to think if I can make milestone 1 by that time :v</div>
<div class='msg'><time>2025‑02‑22 02:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Latest estimate is by end of Q3. But will depend a lot on the outcome of Toaster and initial service development. </div>
<div class='msg'><time>2025‑02‑22 03:47</time>&ensp;<span class='u' style='color:#a977d7'>ymcsabo</span>: Hi, in the gray paper section 15.2, it mentions advanced nodes and naive nodes. What are some of the examples of those two types of nodes?</div>
<div class='msg'><time>2025‑02‑22 07:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There is no clear difference. It’s more about *strategy*. </div>
<div class='msg'><time>2025‑02‑22 07:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * There is no clear delineation. It’s about *strategy*. Some implementations (or node configurations) may use a more sophisticated strategy for predicting the best work package to execute and guarantee. </div>
<div class='msg'><time>2025‑02‑22 07:25</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: I need some clarification regarding the advancement  of the instruction counter i in the PVM

Reading [A.1](https://graypaper.fluffylabs.dev/#/5f542d7/23ec0023ec00) and [A.7](https://graypaper.fluffylabs.dev/#/5f542d7/246600246600)

I understand the counter i` will always advance to the next instruction unless the exit reason is panic or halts

so if we have program like
ecalli ..
op1 ...
op2 ...

host call fail =&gt; continue from op1
host call succeed =&gt; continue from op2 (due to the extra skip in [A.33] (https://graypaper.fluffylabs.dev/#/5f542d7/2b70012b7001)


However, reading the [text](https://graypaper.fluffylabs.dev/#/5f542d7/2b16022b1602) below A.34 i understand that

i&#x27; is:
exit reason == continue &gt; i + 1 +skip
out of gas =&gt; i
panic or halt =&gt; 0
page fault =&gt; i
host call =&gt; i


but this makes [A.33] (https://graypaper.fluffylabs.dev/#/5f542d7/2b70012b7001) not make sense
as now we will have

host call fail =&gt; counter stays =&gt; reinvoke into the failing host call
 
</div>
<div class='msg'><time>2025‑02‑22 07:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * There is no clear delineation. It’s about *strategy*. Some implementations (or node configurations) may use a more sophisticated strategy for predicting the best work package to execute and guarantee. This will allow their operators to take greater rewards under some circumstances. But again, this is strategy and therefore largely out of scope for the GP. </div>
<div class='msg'><time>2025‑02‑22 07:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: You seem to be confusing two different conditions. </div>
<div class='msg'><time>2025‑02‑22 07:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: If the hostcall succeeds (where you pointed) then i’’ is used which skips past the ecalli instruction. If the hostcall results in anything other than a continue (the last condition) then Phi_H is not invoked again anyway. </div>
<div class='msg'><time>2025‑02‑22 07:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * If the hostcall succeeds (where you pointed) then i’’ is used as the new instruction counter for the invocation of Phi_H which effectively skips past the ecalli instruction. If the hostcall results in anything other than a continue (the last condition) then Phi_H is not invoked again anyway. </div>
<div class='msg'><time>2025‑02‑22 07:43</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: right. my code does just that. no issue

so lets talk about the case where the host call succeeds

we start with phi_1 which returned ecalli, and i&#x27; = i +1 +skip (i.e point to instruction after the the ecalli)

and so we don&#x27;t need to advance again after the host call has succeeded. since we already point to the next instruction

or, the Phi_1 should not advance the counter on a ecalli exit reason, and after host call finishes with success the counter advances again

basically, why the text below A.34 says the i` point the the host call, when seems to me from A.7 that it has already progressed beyond






 </div>
<div class='msg'><time>2025‑02‑22 07:43</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: * right. my code does just that. no issue

so lets talk about the case where the host call succeeds

we start with phi\_1 which returned ecalli, and i&#x27; = i +1 +skip (i.e point to instruction after the the ecalli)

and so we don&#x27;t need to advance again after the host call has succeeded. since we already point to the next instruction

or, the Phi\_1 should not advance the counter on a ecalli exit reason, and after host call finishes with success the counter advances again

basically, why the text below A.34 says the i\` point the the host call, when seems to me from A.7 that it has already progressed beyond</div>
<div class='msg'><time>2025‑02‑22 07:44</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: * right. my code does just that. no issue

so lets talk about the case where the host call succeeds

we start with phi\_1 which returned ecalli, and i&#x27; = i +1 +skip (i.e point to instruction after the the ecalli)

and so we don&#x27;t need to advance again after the host call has succeeded. since we already point to the next instruction

or, the Phi\_1 should not advance the counter on a ecalli exit reason, and after host call finishes with success then the counter advances

basically, why the text below A.34 says the i\` point the the host call, when seems to me from A.7 that it has already progressed beyond</div>
<div class='msg'><time>2025‑02‑22 08:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I see your point, yes. i’’ needs not be defined; i’ should be used instead. Feel free to make a PR if i don’t get to it first. </div>
<div class='msg'><time>2025‑02‑22 08:07</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: yep. that&#x27;s what i thought , i&#x27;&#x27; is not needed
Thank you for confirming</div>
<div class='msg'><time>2025‑02‑22 11:48</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: regarding i in [B.9](https://graypaper.fluffylabs.dev/#/5f542d7/2e11012e1101)

```
i = check((E4−1 (H(E(s, η0′ , Ht ))) mod (232 − 29 )) + 28 )
```

does the decode_4 bytes imply that only the first(last?) bytes of the hash are to be taken?</div>
<div class='msg'><time>2025‑02‑22 11:48</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: * regarding i in [B.9](https://graypaper.fluffylabs.dev/#/5f542d7/2e11012e1101)

```
i = check((E4−1 (H(E(s, η0′ , Ht ))) mod (2^32 − 2^9 )) + 2^8 )
```

does the decode\_4 bytes imply that only the first(last?) bytes of the hash are to be taken?</div>
<div class='msg'><time>2025‑02‑22 11:48</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: * regarding `i` in [B.9](https://graypaper.fluffylabs.dev/#/5f542d7/2e11012e1101)

```
i = check((E4−1 (H(E(s, η0′ , Ht ))) mod (2^32 − 2^9 )) + 2^8 )
```

does the decode\_4 bytes imply that only the first(last?) bytes of the hash are to be taken?</div>
<div class='msg'><time>2025‑02‑22 13:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes</div>
<div class='msg'><time>2025‑02‑22 15:19</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Question on what the first value of a_t is in `new` [here](https://graypaper.fluffylabs.dev/#/293bf5a/2e81022e8102) which is defined in [9.8](https://graypaper.fluffylabs.dev/#/5f542d7/115f01115f01):

Assume the preimage of the code is 1149 bytes, and recall GP constants: B_S = 100, B_I = 10, B_L = 1

What is the value of a_i and a_o and thus a_t:

* (1): a_i = 0, a_o = 0 ==&gt; a_t = 100
* (2): a_i = 2, a_o = 81 + 1149 = 1230 ==&gt; a_t = 100 + 10 * 2 + 1 * 1230 = 1350

The order of operations in `new` is not clear, especially with the a_t and l &quot;happening in the same line&quot; here: https://graypaper.fluffylabs.dev/#/5f542d7/31b90231b902</div>
<div class='msg'><time>2025‑02‑22 15:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: a_t is determined through the non-negotiable definition of bold-l which is fully defined. </div>
<div class='msg'><time>2025‑02‑22 15:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * a_t is a dependent variable whose value is implied through the (non-negotiable) definition of bold-l which is fully defined. </div>
<div class='msg'><time>2025‑02‑22 15:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: balance is required to be equal to to this (dependent) variable. There exists only one solution to this statement. </div>
<div class='msg'><time>2025‑02‑22 15:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * balance is required to be equal to this (dependent) variable. There exists only one solution to this statement. </div>
<div class='msg'><time>2025‑02‑22 15:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * a_t is a dependent variable whose value is implied through the (non-negotiable) definition of bold-l, which is fully defined. </div>
<div class='msg'><time>2025‑02‑22 15:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: No order is needed. Ever. </div>
<div class='msg'><time>2025‑02‑22 15:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * No specific order is *needed*. Ever. </div>
<div class='msg'><time>2025‑02‑22 15:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: That’s a point of implementation strategy. </div>
<div class='msg'><time>2025‑02‑22 15:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Ordering is a point of implementation strategy, for implementation languages which require the practitioner to specify it (ie imperative ones). </div>
<div class='msg'><time>2025‑02‑22 15:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Plenty of languages, like formal logic, don’t generally insist on specifying a solution in terms of ordered mutations. </div>
<div class='msg'><time>2025‑02‑22 15:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: If this is a new concept, I’d suggest reading some undergrad computer science texts such as “structure and interpretation of computer languages”. </div>
<div class='msg'><time>2025‑02‑22 15:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * If this is a new concept, I’d suggest reading some undergrad computer science texts such as “structure and interpretation of computer programmes”. </div>
<div class='msg'><time>2025‑02‑22 15:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * a_t is a dependent variable whose value is implied through the (non-negotiable) definition of bold-l, which is fully defined as c and l are both fixed values. </div>
<div class='msg'><time>2025‑02‑23 03:51</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: </div>
<div class='msg'><time>2025‑02‑23 03:52</time>&ensp;<span class='u' style='color:#72c147'>luke_fishman</span>: * good morning everyone
very small specific question about encoding

looking at the encoding in the calculation of `i` in [B.9](https://graypaper.fluffylabs.dev/#/5f542d7/2ef9002ef900)

`E(s, η0′ , Ht )`

for me the symbol e means general encoding [C.6](https://graypaper.fluffylabs.dev/#/5f542d7/365702365702)

But the text under C.6 says
_&quot;Note that at present this is utilized only in encoding the length prefix of variable-length sequences.&quot;_

which would imply:

- service index is encoded as 4 bytes
(refs [9.1](https://graypaper.fluffylabs.dev/#/5f542d7/10e40010e400), [C.23](https://graypaper.fluffylabs.dev/#/5f542d7/377202377202))
- timeslot is encoded as 4 bytes as well (refs [I.1.1](https://graypaper.fluffylabs.dev/#/5f542d7/3e36003e3600), [C.16, C.20, C.22](https://graypaper.fluffylabs.dev/#/5f542d7/37e50037e500))</div>
<div class='msg'><time>2025‑02‑23 11:26</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: In eq [12.10](https://graypaper.fluffylabs.dev/#/5f542d7/16c90116d001), Does `m` should be `m&#x27;` since `Ht = tau&#x27;`?</div>
<div class='msg'><time>2025‑02‑23 12:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I generally prefer not using a prime unless the plain (non-prime) term is also used. </div>
<div class='msg'><time>2025‑02‑23 18:32</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: I assume that when inspecting memory during the sbrk instruction, this should not case a memory-access exception, right? Also, is it right to interpret the math as saying “find the earliest inaccessible contiguous memory segment starting at or above h of length wa, and set it as mutable”?</div>
<div class='msg'><time>2025‑02‑23 19:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: For sbrk, I’ll leave it in the hands of [@jan:parity.io](https://matrix.to/#/@jan:parity.io) - I’d personally quite like to get rid of it:))</div>
<div class='msg'><time>2025‑02‑23 20:49</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: neg_add_imm_64 has a +2^64 but then mods by 2^64 so this addition is the same as +0, so it’s redundant. Unless there’s a typo </div>
<div class='msg'><time>2025‑02‑23 21:06</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: rot_r_64_imm performs a left shift as written (ith bit of w’a = i+vx bit of wb), but the name suggests a right shift. Is this correct?</div>
<div class='msg'><time>2025‑02‑23 21:07</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: Similar for the next 3 instructions </div>
<div class='msg'><time>2025‑02‑23 23:09</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: ^similar for instructions 220-223</div>
<div class='msg'><time>2025‑02‑23 23:10</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: Also, shouldn’t we be doing Z inverse on the result of the max (227) and min (229) instructions? To convert back to unsigned before storing in the register </div>
<div class='msg'><time>2025‑02‑24 02:58</time>&ensp;<span class='u' style='color:#7875cf'>charliewinston14</span>: Morning all. Are the &quot;EC shards&quot; referenced in CE137 the same as the &quot;bundle shards&quot; referenced in CE138? What is the difference between these two APIs? Are they essentially the same except CE137 also returns segment shards?</div>
<div class='msg'><time>2025‑02‑24 11:57</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: Hi Dr.Wood
https://github.com/gavofyork/graypaper/pull/248
Can we use beta_dagga as the only reference(instead of beta+beta_dagga) for all processes in Section 11?
</div>
<div class='msg'><time>2025‑02‑24 12:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@shwchg:matrix.org&gt; Hi Dr.Wood
&gt; https://github.com/gavofyork/graypaper/pull/248
&gt; Can we use beta_dagga as the only reference(instead of beta+beta_dagga) for all processes in Section 11?
&gt; 

The two should give equal effects in Section 11 as the only difference is the placement of the beefy root. </div>
<div class='msg'><time>2025‑02‑24 12:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; neg_add_imm_64 has a +2^64 but then mods by 2^64 so this addition is the same as +0, so it’s redundant. Unless there’s a typo 

I don’t define negative modulo; this ensures the modulo is positive. </div>
<div class='msg'><time>2025‑02‑24 12:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; rot_r_64_imm performs a left shift as written (ith bit of w’a = i+vx bit of wb), but the name suggests a right shift. Is this correct?

It is correct. Check the implementation of caligraphic B. </div>
<div class='msg'><time>2025‑02‑24 12:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; rot_r_64_imm performs a left shift as written (ith bit of w’a = i+vx bit of wb), but the name suggests a right shift. Is this correct?

* It is correct. Check the definition of caligraphic B. </div>
<div class='msg'><time>2025‑02‑24 12:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; Also, shouldn’t we be doing Z inverse on the result of the max (227) and min (229) instructions? To convert back to unsigned before storing in the register 

Yes. If you’re in the mood feel free to submit a PR. </div>
<div class='msg'><time>2025‑02‑24 13:23</time>&ensp;<span class='u' style='color:#4068cd'>0xjunha</span>: &gt; &lt;@ascriv:matrix.org&gt; Also, shouldn’t we be doing Z inverse on the result of the max (227) and min (229) instructions? To convert back to unsigned before storing in the register 

Actually this change is merged into main - probably will be included in the next release? https://github.com/gavofyork/graypaper/pull/228</div>
<div class='msg'><time>2025‑02‑25 15:20</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: Hi team 👋 Quick question about the Merkle function in D.6-&gt; the branch splitting conditional implies that the key should be left shifted one bit before each recursion. Am I interpreting this correctly? The tests &amp; gh consensus suggests that the keys shouldn&#x27;t be rotated at each recursion, but rather that the $d&#x27;th bit should be used in the splitting conditional at recursion depth $d. I&#x27;m happy to open a PR to the GP repo if appropriate.

https://graypaper.fluffylabs.dev/#/5f542d7/391b01391c01</div>
<div class='msg'><time>2025‑02‑25 15:58</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: https://graypaper.fluffylabs.dev/#/5f542d7/10b00010b000
If the authorization pool is all the same hash, and there is a guarantee that using that hash as authorization, will it consume the entire pool? and will the queue then refill with eight more?</div>
<div class='msg reply'><time>2025‑02‑25 16:01</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Only one of the hashes should be consumed, see https://graypaper.fluffylabs.dev/#/5f542d7/07f70007fa00</div>
<div class='msg reply'><time>2025‑02‑25 16:10</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: ok I see!
thanks for reply</div>
<div class='msg'><time>2025‑02‑25 16:23</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: In order to compare large amounts of PVM traces between teams precisely, I would like a formula to hash the registers with the PVM paged memory for teams to know they ended up with same answer at the end, and if they did not, be able to quickly determine which line they differed in results.  

Its not hard to come up with a procedure, but does a ready made answer  exist within the PolkaVM repo or is there some public algorithm to do this kind of operation so we don&#x27;t reinvent the wheel needlessly?   </div>
<div class='msg'><time>2025‑02‑25 16:30</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * In order to compare large amounts of PVM traces between teams precisely, I would like a formula to hash the registers with the PVM paged memory for teams to know they ended up with same answer at the end, and if they did not, be able to quickly determine which line in some PVM trace of PC they differed in results.  

Its not hard to come up with a procedure, but does a ready made answer  exist within the PolkaVM repo or is there some public algorithm to do this kind of operation so we don&#x27;t reinvent the wheel needlessly?   </div>
<div class='msg'><time>2025‑02‑25 16:53</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: Hey! Hoping to get a clarification on the justifications for CE-138 (audit shard request). It mentions &quot;The assurer should construct this by appending the corresponding segment shard root to the justification received via CE 137.&quot;. 

What is the segment shard root corresponding too exactly? 

The justification in CE 137 calls trace which returns a list of hashed values (original value is lost since it prefixes with &#x27;node&#x27; and hashes)</div>
<div class='msg'><time>2025‑02‑25 17:19</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: * Hey! Hoping to get a clarification on the justifications for CE-138 (audit shard request). It mentions &quot;The assurer should construct this by appending the corresponding segment shard root to the justification received via CE 137.&quot;. 

What is the segment shard root corresponding too exactly when it&#x27;s a request about a work package shard?</div>
<div class='msg'><time>2025‑02‑25 21:26</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: The Parity Service trait definition for `accumulate` [here](https://docs.rs/jam-pvm-common/latest/jam_pvm_common/) returns an `Option&lt;Hash&gt;`

```
fn accumulate(_slot: Slot, _id: ServiceId, items: Vec&lt;AccumulateItem&gt;) -&gt; Option&lt;Hash&gt;
```

but it appears there are TWO ways to provide a `Some`  for `accumulate`:

(1) if $\omega_8=32$, then the [B.12 ${\bf o} \in \mathbb{H}$ condition applies](https://graypaper.fluffylabs.dev/#/5f542d7/2ee2022ee202) 

(2) the [`yield` host function](https://graypaper.fluffylabs.dev/#/5f542d7/337902337902) 

As B.12 is written, (1) takes precedence over (2), but  the new (2) `yield` is a cleaner solution otherwise why was it added?   Now that its been added, I believe we don&#x27;t need (1).  Having both is not *needed* since whatever 32-byte optional yield could go through output (1) OR (2), so perhaps we can eliminate (1).

Nitpick check: is $w8 = 32$ a sufficient criteria for (1) ?</div>
<div class='msg'><time>2025‑02‑26 01:08</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * The Parity Service trait definition for `accumulate` [here](https://docs.rs/jam-pvm-common/latest/jam_pvm_common/) returns an `Option&lt;Hash&gt;`

```
fn accumulate(_slot: Slot, _id: ServiceId, items: Vec&lt;AccumulateItem&gt;) -&gt; Option&lt;Hash&gt;
```

but it appears there are TWO ways to provide a `Some`  for `accumulate`:

(1) if $\\omega\_8=32$, then the [B.12 ${\\bf o} \\in \\mathbb{H}$ condition applies](https://graypaper.fluffylabs.dev/#/5f542d7/2ee2022ee202)

(2) the [`yield` host function](https://graypaper.fluffylabs.dev/#/5f542d7/337902337902)

As B.12 is written, (1) takes precedence over (2), but  the new (2) `yield` is a cleaner solution otherwise why was it added?   Now that its been added, I believe we don&#x27;t need (1).  Having both is not _needed_ since whatever 32-byte optional yield could go through output (1) OR (2), so perhaps we can eliminate (1).

Nitpick check: is $omega8 = 32$ a sufficient criteria for (1) to take precedence over (2) ?</div>
<div class='msg'><time>2025‑02‑26 01:53</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: Should (A.43) have x’ instead of x? For clarity that it’s the x after the host call</div>
<div class='msg'><time>2025‑02‑26 01:55</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: And should the type of the gas in the return for (A.42) be signed (Zg) to handle e.g. when the host call returns out of gas?</div>
<div class='msg'><time>2025‑02‑26 01:58</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * The Parity Service trait definition for `accumulate` [here](https://docs.rs/jam-pvm-common/latest/jam_pvm_common/) returns an `Option&lt;Hash&gt;`

```
fn accumulate(_slot: Slot, _id: ServiceId, items: Vec&lt;AccumulateItem&gt;) -&gt; Option&lt;Hash&gt;
```

but it appears there are TWO ways to provide a `Some`  for `accumulate`:

(1) if $\\omega\_8=32$, then the [B.12 ${\\bf o} \\in \\mathbb{H}$ condition applies](https://graypaper.fluffylabs.dev/#/5f542d7/2ee2022ee202)

(2) the [`yield` host function](https://graypaper.fluffylabs.dev/#/5f542d7/337902337902)

As B.12 is written, (1) takes precedence over (2), but  the new (2) `yield` is a cleaner solution otherwise why was it added?   Now that its been added, I believe we don&#x27;t need (1).  Having both is not _needed_ since whatever 32-byte optional yield could go through output (1) OR (2), so perhaps we can eliminate (1).

Nitpick check: is $omega8 = 32$ a sufficient criteria for (1) to take precedence over (2) ?  What if $omega8 &gt; 32$?  What if $omega8 &lt; 32$?  </div>
<div class='msg'><time>2025‑02‑26 03:47</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * The Parity Service trait definition for accumulate here returns an Option&lt;Hash&gt;
fn accumulate(_slot: Slot, _id: ServiceId, items: Vec&lt;AccumulateItem&gt;) -&gt; Option&lt;Hash&gt;
but it appears there are TWO ways to provide a Some for accumulate:
(1) if $\omega_8=32$, then the B.12 ${\bf o} \in \mathbb{H}$ condition applies
(2) the yield host function
As B.12 is written, (1) takes precedence over (2), but the new (2) yield is a cleaner solution otherwise why was it added? Now that its been added, I believe we don&#x27;t need (1). Having both is not needed since whatever 32-byte optional yield could go through output (1) OR (2), so perhaps we can eliminate (1).
Nitpick check: is $omega8 = 32$ a sufficient criteria for (1) to take precedence over (2) ? What if $omega8 &gt; 32$? What if $omega8 &lt; 32$?

Related nitpick check: is there a way to change the C notation in eq 4.7 vs 4.17 to eliminate the appearance of dependency loops.  We are pretty sure  the C in 4.7 is from the previous states  4.17 but seek confirmation? </div>
<div class='msg'><time>2025‑02‑26 13:44</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: Hey! Question about the state transition dependency graph 4.2.1. Should the calculation of β′ be moved further down since it depends on the commitment map C which doesn&#x27;t exist yet, or does it use the commitment map from the previous block?</div>
<div class='msg'><time>2025‑02‑26 13:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; In order to compare large amounts of PVM traces between teams precisely, I would like a formula to hash the registers with the PVM paged memory for teams to know they ended up with same answer at the end, and if they did not, be able to quickly determine which line in some PVM trace of PC they differed in results.  
&gt; 
&gt; Its not hard to come up with a procedure, but does a ready made answer  exist within the PolkaVM repo or is there some public algorithm to do this kind of operation so we don&#x27;t reinvent the wheel needlessly?   

No, there’s no canonical PVM state serialization. Registers are trivial, but for memory we would need to have some definition on how to encode the pages and their accessibility. </div>
<div class='msg reply'><time>2025‑02‑26 19:16</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: https://hackmd.io/@sourabhniyogi/pvmhash 
is a first try, hopefully a couple of us will try to converge on something as we get our host function implementations and PVM interpreter implementations correct.

I am wondering why R/W/A page accessibility came to your mind right away (as opposed to X/Y contexts which has most of the immediate debugging problems) -- I must  be missing something since any discrepancy in internal representations of page accessibility would be visible by some load/store instructions effect (or lack thereof) on a particular page -- encoding this page accessibility would be for 2 teams to reason about the contents of the memory after they saw the memory affected/not affected based on this bit.</div>
<div class='msg reply'><time>2025‑02‑27 04:59</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The context is not PVM state.</div>
<div class='msg reply'><time>2025‑02‑27 05:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Of course you&#x27;ll likely still want to test it, but I don&#x27;t think there&#x27;s any reason to check it before the context is collapsed into the final result from Phi_R</div>
<div class='msg reply'><time>2025‑02‑27 10:59</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Then the v2 &quot;hash&quot; intends to capture the PVM state AND both contexts so as to support debugging of incorrect host function implementations.  

Since a Phi_A may have many host function calls, we do have a reason the check this v2 &quot;hash&quot;.  Does that make sense?
</div>
<div class='msg'><time>2025‑02‑26 14:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; The Parity Service trait definition for accumulate here returns an Option&lt;Hash&gt;
&gt; fn accumulate(_slot: Slot, _id: ServiceId, items: Vec&lt;AccumulateItem&gt;) -&gt; Option&lt;Hash&gt;
&gt; but it appears there are TWO ways to provide a Some for accumulate:
&gt; (1) if $\omega_8=32$, then the B.12 ${\bf o} \in \mathbb{H}$ condition applies
&gt; (2) the yield host function
&gt; As B.12 is written, (1) takes precedence over (2), but the new (2) yield is a cleaner solution otherwise why was it added? Now that its been added, I believe we don&#x27;t need (1). Having both is not needed since whatever 32-byte optional yield could go through output (1) OR (2), so perhaps we can eliminate (1).
&gt; Nitpick check: is $omega8 = 32$ a sufficient criteria for (1) to take precedence over (2) ? What if $omega8 &gt; 32$? What if $omega8 &lt; 32$?
&gt; 
&gt; Related nitpick check: is there a way to change the C notation in eq 4.7 vs 4.17 to eliminate the appearance of dependency loops.  We are pretty sure  the C in 4.7 is from the previous states  4.17 but seek confirmation? 

We can consider removing (1) at a later stage. Host calls are not especially cheap and returning data is a more natural pattern than relying on the side-effect of a host call. </div>
<div class='msg'><time>2025‑02‑26 21:42</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * https://hackmd.io/@sourabhniyogi/pvmhash 
is a first try, hopefully a couple of us will try to converge on something as we get our host function implementations and PVM interpreter implementations correct.

I am wondering why R/W/0 page accessibility came to your mind right away (as opposed to X/Y contexts which has most of the immediate debugging problems) -- I must  be missing something since any discrepancy in internal representations of page accessibility would be visible by some load/store instructions effect (or lack thereof) on a particular page -- encoding this page accessibility would be for 2 teams to reason about the contents of the memory after they saw the memory affected/not affected based on R/W/0 page accessibility bits.</div>
<div class='msg'><time>2025‑02‑26 21:48</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * https://hackmd.io/@sourabhniyogi/pvmhash 
is a first try, hopefully a couple of us will try to converge on something as we get our host function implementations and PVM interpreter implementations correct.

I am wondering why R/W/0 page accessibility came to your mind right away (as opposed to X/Y contexts which has most of the immediate debugging problems) -- I must  be missing something since any discrepancy in internal representations of page accessibility would be visible by some load/store instructions effect (or lack thereof) on a particular page -- encoding this page accessibility would be for 2 teams to reason about the contents of the memory after they saw the memory affected/not affected based on R/W/0 page accessibility bits -- if you anticipate this to be quite important early, I would like to put it in early in a &quot;v1&quot; (like in a page) -- is it?

Related question maybe?:  Was the W_G=4104 segment size chosen for segments to match a 4096-page size and a specific 8-byte encoding of the page, a page number and some specific metadata, specifically the accessibility bits.  If so, we might as well get the &quot;dump a page&quot; to map into the 4104 encoding imagined for CoreVM service?  Just a guess.  </div>
<div class='msg'><time>2025‑02‑27 01:03</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * https://hackmd.io/@sourabhniyogi/pvmhash 
is a first try, hopefully a couple of us will try to converge on something as we get our host function implementations and PVM interpreter implementations correct.

I am wondering why R/W/0 page accessibility came to your mind right away (as opposed to X/Y contexts which has most of the immediate debugging problems) -- I must  be missing something since any discrepancy in internal representations of page accessibility would be visible by some load/store instructions effect (or lack thereof) on a particular page -- encoding this page accessibility would be for 2 teams to reason about the contents of the memory after they saw the memory affected/not affected based on R/W/0 page accessibility bits -- if you anticipate this to be quite important early, I would like to put it in early in a &quot;v1&quot; (like in a page) -- is it?

Related question maybe?:  Was the W\_G=4104 segment size chosen for segments to match a 4096-page size and a specific 8-byte encoding of the page, a page number and some specific metadata, specifically the accessibility bits.  If so, we might as well get the &quot;dump a page&quot; to map into the 4104 encoding imagined for CoreVM service with the desired 8-byte encoding for pages maybe?  </div>
<div class='msg'><time>2025‑02‑27 04:35</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; Should (A.43) have x’ instead of x? For clarity that it’s the x after the host call

Sure https://github.com/gavofyork/graypaper/pull/254</div>
<div class='msg'><time>2025‑02‑27 04:57</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; And should the type of the gas in the return for (A.42) be signed (Zg) to handle e.g. when the host call returns out of gas?

Yes indeed: https://github.com/gavofyork/graypaper/pull/255</div>
<div class='msg'><time>2025‑02‑27 04:59</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * The context is not PVM state - the whole point is that it&#x27;s external.</div>
<div class='msg'><time>2025‑02‑27 05:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Of course you&#x27;ll likely still want to test it, but I don&#x27;t think there&#x27;s any reason to check it before the context is collapsed into the final result from Phi\_A</div>
<div class='msg'><time>2025‑02‑27 05:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@jaymansfield:matrix.org&gt; Hey! Question about the state transition dependency graph 4.2.1. Should the calculation of β′ be moved further down since it depends on the commitment map C which doesn&#x27;t exist yet, or does it use the commitment map from the previous block?

I&#x27;m kept the (different variations of) the state components together rather than try to keep any &quot;execution order&quot;. Indeed rather the point of this dependency graph is to demonstrate that there exists no specific order since it&#x27;s a partially parallel rather than a fully serial system.</div>
<div class='msg reply'><time>2025‑02‑27 08:20</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Here is the context of this &quot;C&quot; and &quot;Beta&quot; dependency question: 
https://github.com/jam-duna/jamtestnet/issues/101

</div>
<div class='msg reply'><time>2025‑02‑27 08:28</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: &gt; &lt;@gav:polkadot.io&gt; I&#x27;m kept the (different variations of) the state components together rather than try to keep any &quot;execution order&quot;. Indeed rather the point of this dependency graph is to demonstrate that there exists no specific order since it&#x27;s a partially parallel rather than a fully serial system.

sourabhniyogi: I think this answered your doubt. C used by beta&#x27; is the result from accumulation process </div>
<div class='msg reply'><time>2025‑02‑27 08:53</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: I&#x27;d prefer we merge this:

https://github.com/gavofyork/graypaper/pull/253 

but we&#x27;ll consider this case closed =)</div>
<div class='msg'><time>2025‑02‑27 05:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; Nitpick check: is $omega8 = 32$ a sufficient criteria for (1) to take precedence over (2) ? What if $omega8 &gt; 32$? What if $omega8 &lt; 32$?

Not sure what you mean by $omega8, but assuming you mean selecting between that latter 2 variants of B.12, then it&#x27;s pretty clear: you use the returned value IFF it is a 32-byte sequence (blackboard H). If it&#x27;s anything other than this (e.g. 31 byte sequence or 33 byte sequence), then you fallback to the *otherwise* condition of using the (success) context.</div>
<div class='msg'><time>2025‑02‑27 05:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * &gt; Nitpick check: is $omega8 = 32$ a sufficient criteria for (1) to take precedence over (2) ? What if $omega8 &gt; 32$? What if $omega8 \&lt; 32$?

Not sure what you mean by $omega8, but assuming you mean selecting between that latter 2 variants of B.12, then it&#x27;s pretty clear: you use the returned value IFF it is a 32-byte sequence (blackboard H). If it&#x27;s anything other than this (e.g. 31 byte sequence or 33 byte sequence), then you fallback to the _otherwise_ condition of using the (success) context&#x27;s yield.</div>
<div class='msg'><time>2025‑02‑27 10:00</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * We&#x27;ll consider this case closed =)</div>
<div class='msg'><time>2025‑02‑27 11:24</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * Then the v2 &quot;hash&quot; intends to capture the PVM state AND both contexts so as to support debugging of incorrect host function implementations.  

Since a Phi\_A may have many host function calls, we do have a reason to check this v2 &quot;hash&quot;, to see if an intermediate value of the v2 &quot;hash&quot; from one implementation matches another, one of which is incorrect.  Does that make sense?
</div>
<div class='msg'><time>2025‑02‑27 11:28</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * Then the v2 &quot;hash&quot; intends to capture the PVM state AND both contexts so as to support debugging of incorrect host function implementations.

Since a Phi\_A may have many host function calls, we do have a reason to check this v2 &quot;hash&quot;, to see if an intermediate value of the v2 &quot;hash&quot; from one implementation matches another after some of those host function calls [which affect the X (or Y) context] complete, one (or maybe both) of which is incorrect.  Does that make sense?</div>
<div class='msg'><time>2025‑02‑27 11:58</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * Then the v2 &quot;hash&quot; intends to capture the PVM state AND both contexts so as to support debugging of incorrect host function implementations.  What should this be called?

Since a Phi\_A may have many host function calls, we do have a reason to check this v2 &quot;hash&quot;, to see if an intermediate value of the v2 &quot;hash&quot; from one implementation matches another after some of those host function calls \[which affect the X (or Y) context\] complete, one (or maybe both) of which is incorrect.  Does that make sense?</div>
<div class='msg'><time>2025‑02‑27 11:59</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * Then the v2 &quot;hash&quot; intends to capture the PVM state AND both contexts so as to support debugging of incorrect host function implementations.  What should this be called?

Since a Phi\_A result may have many host function calls to get at its result (with many intermediate X + Y contexts), we do have a reason to check this v2 &quot;hash&quot;, to see if an intermediate value of the v2 &quot;hash&quot; from one implementation matches another after some of those host function calls \[which affect the X (or Y) context\] complete, one (or maybe both) of which is incorrect.  Does that make sense?</div>
<div class='msg'><time>2025‑02‑27 23:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Sure. Then indeed you’ll want to serialise the context also. </div>
<div class='msg'><time>2025‑02‑28 02:43</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: I’m guessing in (B.1) p_c should be p_p?</div>
<div class='msg reply'><time>2025‑02‑28 03:03</time>&ensp;<span class='u' style='color:#6ecf94'>qiwei</span>: see 14.9, there is a authorization code</div>
<div class='msg'><time>2025‑02‑28 03:17</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: Thanks. Should the returned gas value in (A.34) be signed? </div>
<div class='msg'><time>2025‑02‑28 03:36</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: Jan Bujak: are you able to confirm if the rv test vectors are compliant with A.17? Based on my testing, I suspect they may be branching to the middle of basic blocks on passing tests. One example I found is the branch_eq opcode at pc 466 in rv64ui_add https://graypaper.fluffylabs.dev/#/5f542d7/24e40224e502</div>
<div class='msg'><time>2025‑02‑28 03:39</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * Jan Bujak: are you able to confirm if the rv test vectors are compliant with A.17? Based on my testing, I suspect they may be branching to the middle of basic blocks on passing tests. One example I found is the branch\_eq instruction at pc 466 in rv64ui\_add https://graypaper.fluffylabs.dev/#/5f542d7/24e40224e502</div>
<div class='msg'><time>2025‑02‑28 04:09</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: I&#x27;m confused. There&#x27;s nothing wrong with the branch_eq instruction at pc 466 in rv64ui_add test and it certainly doesn&#x27;t branch into the middle of a basic block?

```
   448: 01                       fallthrough
      :                          @20
   449: 33 00 0d                 r0 = 0xd
   452: 33 01 0b                 r1 = 0xb
   455: c8 10 0b                 r11 = r0 + r1
   458: 64 b3                    r3 = r11
   460: 95 aa 01                 r10 = r10 + 0x1
   463: 33 02 02                 r2 = 0x2
   466: ab 2a ef                 jump 449 if r10 != r2
```</div>
<div class='msg'><time>2025‑02‑28 04:21</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: You&#x27;re right, this is my mistake... embarrassingly small bug on my end, should have reviewed more thoroughly before posting 🤦‍♂️ Thanks for your response.</div>
<div class='msg'><time>2025‑02‑28 04:24</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * You&#x27;re right, this is my mistake... embarrassingly small bug on my end, should have reviewed the target more thoroughly before posting as well (different debugging scope) 🤦‍♂️ Thanks for your response.</div>
<div class='msg'><time>2025‑02‑28 08:27</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * You&#x27;re right, this is my mistake... embarrassingly small bug on my end, should have reviewed the target more thoroughly before posting as well (different debugging scope &amp; missed fallthrough is bb terminator) 🤦‍♂️ Thanks for your response.</div>
<div class='msg'><time>2025‑02‑28 10:30</time>&ensp;<span class='u' style='color:#4772c5'>faiz_871</span>: I am struggling to understand the meaning of t_t, t_l and t_i in info host call function that is defined here: https://graypaper.fluffylabs.dev/#/5f542d7/306802308802</div>
<div class='msg'><time>2025‑02‑28 10:44</time>&ensp;<span class='u' style='color:#48d03d'>tomusdrw</span>: Faiz Ahmad: This should help: https://graypaper.fluffylabs.dev/#/5f542d7/115c01115c01 (`t_t &amp; t_i`), https://graypaper.fluffylabs.dev/#/5f542d7/115400115700 (`t_l`)</div>
<div class='msg'><time>2025‑02‑28 19:03</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: </div>
<div class='msg'><time>2025‑02‑28 19:09</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * Are alterations to the PC as a result of a host call required to be the start of a basic block? Not sure if I&#x27;m interpreting &quot;call&quot; appropriately in this sentence in the GP.
https://graypaper.fluffylabs.dev/#/5f542d7/24e40224e402 

If so, does reinvoking with the same pc of the host call (in the case of a host call page fault) imply a strict requirement that the instruction prior to the host call is a block terminator?
https://graypaper.fluffylabs.dev/#/5f542d7/2b23022b2302</div>
<div class='msg'><time>2025‑03‑01 13:47</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Can a parent VM determine which PVM memory pages have been modified by an &quot;invoked&quot; child VM?

CoreVM-type services aim to extend JAM computation across multiple work packages by exporting PVM memory pages as segments at the end of a task and retrieving them at the start of the next.

While the [memcpy/memset host call](https://github.com/gavofyork/graypaper/issues/145) can support data transfer between parent and child VMs (an imported segment copied into some child VM page index), the parent needs a way to identify all mutated memory pages—not just those explicitly copied via memcpy—to ensure they are correctly included in the exported segments.

One approach could be extending [M](https://graypaper.fluffylabs.dev/#/5f542d7/2d22002d2200) to track modified page indexes and providing an explicit mechanism for the parent VM to access this set, supporting efficient page/segment export.

Is this a good idea or is there a better approach?</div>
<div class='msg'><time>2025‑03‑02 04:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; Thanks. Should the returned gas value in (A.34) be signed?

Yes. Already merged.</div>
<div class='msg'><time>2025‑03‑02 04:49</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: A lot of the host functions (eg solicit, forget, yield, etc) use Z_o…+32 (for example). I think these can never be negative since they’re register values? So N is a bit more clear</div>
<div class='msg'><time>2025‑03‑02 05:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; A lot of the host functions (eg solicit, forget, yield, etc) use Z_o…+32 (for example). I think these can never be negative since they’re register values? So N is a bit more clear

Yes, feel free to make a PR.</div>
<div class='msg'><time>2025‑03‑02 14:06</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: https://github.com/gavofyork/graypaper/pull/262</div>
<div class='msg'><time>2025‑03‑02 14:23</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: Is there always an implicit mod 2^32 when inspecting or mutating the ram given a register (64 bit unsigned)? we do this a lot and wondering how it should be handled </div>
<div class='msg'><time>2025‑03‑02 16:57</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: I have a doubt about the work package execution formula: https://graypaper.fluffylabs.dev/#/5f542d7/1a48021a5d02

it says that `I(p,j) = (r, e)` when `|e| = we`, but what if r is an error and the |e| = we? Shouldn&#x27;t be

- `(r, [G0, G0, ...) if r not binary` first 
- `(r, e) if |e| = we` second 

?</div>
<div class='msg'><time>2025‑03‑02 22:01</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: According to the gp, we only handle memory access/modification exceptions in the single step function, but presumably we’d want to catch such exceptions in , e.g host calls as well, no?</div>
<div class='msg'><time>2025‑03‑02 22:17</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: believe mem fault in nested pvm is returned to parent pvm instance for the pvm program to handle, someone correct me if I&#x27;m wrong here</div>
<div class='msg'><time>2025‑03‑02 22:21</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: https://graypaper.fluffylabs.dev/#/5f542d7/364401364d01</div>
<div class='msg'><time>2025‑03‑02 22:24</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: Yes, but if for example the 8th register is not a valid memory location, then when deserializing to construct g, we should fault, right? Before the pvm function is called </div>
<div class='msg'><time>2025‑03‑02 22:25</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: Similar for other host functions </div>
<div class='msg'><time>2025‑03‑02 22:29</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: </div>
<div class='msg'><time>2025‑03‑02 22:31</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * Good question. I would assume write to that location from an &#x27;outer-shell&#x27; implementation perspective, and if the pvm program attempts to access it, then it would trigger a page fault. Interested to hear other folks thoughts here.</div>
<div class='msg'><time>2025‑03‑02 22:31</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * Good question. I would assume write to that location from an &#x27;outer-shell&#x27; implementation perspective, and if the pvm program attempts to access it, then it would trigger a page fault. Interested to hear other folks thoughts on this though.</div>
<div class='msg'><time>2025‑03‑03 02:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; Is there always an implicit mod 2^32 when inspecting or mutating the ram given a register (64 bit unsigned)? we do this a lot and wondering how it should be handled 

No. Everything is explicit.</div>
<div class='msg'><time>2025‑03‑03 02:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; According to the gp, we only handle memory access/modification exceptions in the single step function, but presumably we’d want to catch such exceptions in , e.g host calls as well, no?

They are handled explicitly. </div>
<div class='msg'><time>2025‑03‑03 02:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; According to the gp, we only handle memory access/modification exceptions in the single step function, but presumably we’d want to catch such exceptions in , e.g host calls as well, no?

* They are handled explicitly. If you believe there is an instance where unarmed memory may be addressed, please report. </div>
<div class='msg'><time>2025‑03‑03 02:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; I have a doubt about the work package execution formula: https://graypaper.fluffylabs.dev/#/5f542d7/1a48021a5d02
&gt; 
&gt; it says that `I(p,j) = (r, e)` when `|e| = we`, but what if r is an error and the |e| = we? Shouldn&#x27;t be
&gt; 
&gt; - `(r, [G0, G0, ...) if r not binary` first 
&gt; - `(r, e) if |e| = we` second 
&gt; 
&gt; ?

No. GP is correct. </div>
<div class='msg'><time>2025‑03‑03 02:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; Yes, but if for example the 8th register is not a valid memory location, then when deserializing to construct g, we should fault, right? Before the pvm function is called 

See the second line there. The range beginning with o is ensured to be in the set of valid memory addresses. </div>
<div class='msg'><time>2025‑03‑03 04:53</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: In export, since we’re reading indices p…+z wrapped, should we also be checking if Np…+z (mod ram size) is in Vu ?</div>
<div class='msg'><time>2025‑03‑03 04:54</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: Similar for poke </div>
<div class='msg'><time>2025‑03‑03 08:11</time>&ensp;<span class='u' style='color:#4068cd'>0xjunha</span>: I have several questions/comments regarding the historical lookup and related constants:

1. The constant `D` has been updated from 28,800 slots (48 hrs) to 4,800 slots (8 hrs). I opened a PR to update it in appendix I too: https://github.com/gavofyork/graypaper/pull/260

2. Probably the constant value `L` should be reduced too? `D` seems to be introduced to prevent a preimage data from being removed while it still could be referenced during auditing. So `D` should be larger than `L`. However, current value of `L` is 14,400 (24 hrs): (https://graypaper.fluffylabs.dev/#/5f542d7/417000417000 and https://graypaper.fluffylabs.dev/#/5f542d7/0c9f000c9f00) which hasn&#x27;t been updated since the initial commit, while `D` was updated as mentioned above.

3. https://graypaper.fluffylabs.dev/#/5f542d7/113b00113b00 Regarding the brief definition of the historical lookup function, should the constant `C_D` be `D` instead? I wonder if this is a typo or I&#x27;m missing something. Also, while the function is designed to be called off-chain, should we interpret the `H_t` here as &quot;The timeslot index of the last finalized block header that an auditor sees at the point of auditing&quot;?</div>
<div class='msg'><time>2025‑03‑03 09:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@0xjunha:matrix.org&gt; I have several questions/comments regarding the historical lookup and related constants:
&gt; 
&gt; 1. The constant `D` has been updated from 28,800 slots (48 hrs) to 4,800 slots (8 hrs). I opened a PR to update it in appendix I too: https://github.com/gavofyork/graypaper/pull/260
&gt; 
&gt; 2. Probably the constant value `L` should be reduced too? `D` seems to be introduced to prevent a preimage data from being removed while it still could be referenced during auditing. So `D` should be larger than `L`. However, current value of `L` is 14,400 (24 hrs): (https://graypaper.fluffylabs.dev/#/5f542d7/417000417000 and https://graypaper.fluffylabs.dev/#/5f542d7/0c9f000c9f00) which hasn&#x27;t been updated since the initial commit, while `D` was updated as mentioned above.
&gt; 
&gt; 3. https://graypaper.fluffylabs.dev/#/5f542d7/113b00113b00 Regarding the brief definition of the historical lookup function, should the constant `C_D` be `D` instead? I wonder if this is a typo or I&#x27;m missing something. Also, while the function is designed to be called off-chain, should we interpret the `H_t` here as &quot;The timeslot index of the last finalized block header that an auditor sees at the point of auditing&quot;?

1. Yes there&#x27;s an issue for this now; the provided PR may not be quite right.</div>
<div class='msg'><time>2025‑03‑03 09:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 1./2. Yes there&#x27;s an issue for this now; the provided PR may not be quite right.</div>
<div class='msg'><time>2025‑03‑03 09:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 3. Ues indeed `C_D` should be `D`; will be fixed in 0.6.4.</div>
<div class='msg'><time>2025‑03‑03 09:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 3. Yes indeed `C_D` should be `D`; will be fixed in 0.6.4.</div>
<div class='msg'><time>2025‑03‑03 09:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: One may consider 9.5 as the &quot;on-chain&quot; function-contract.</div>
<div class='msg'><time>2025‑03‑03 09:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Big-Lambda is defined fully at 9.7 and this proper definition does not use `H_t`.</div>
<div class='msg'><time>2025‑03‑03 09:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 9.5 is only provided to help the read understand what problem the function is attempting to solve.</div>
<div class='msg'><time>2025‑03‑03 09:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: @room Grap Paper version 0.6.3 is released: https://github.com/gavofyork/graypaper/releases/tag/v0.6.3</div>
<div class='msg'><time>2025‑03‑03 09:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * @room Gray Paper version 0.6.3 is released: https://github.com/gavofyork/graypaper/releases/tag/v0.6.3</div>
<div class='msg'><time>2025‑03‑03 09:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: In addition to many corrections and clarifications, there are several important functional alterations; pay attention to the first 6 items in the changelog.</div>
<div class='msg'><time>2025‑03‑03 09:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * In addition to many corrections and clarifications, there are several small but important functional alterations; pay attention to the first 6 items in the changelog.</div>
<div class='msg'><time>2025‑03‑03 09:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * 9.5 is only provided to help the reader understand what problem the function is attempting to solve.</div>
<div class='msg'><time>2025‑03‑03 11:17</time>&ensp;<span class='u' style='color:#788ad5'>yu2c</span>: Does anyone know why the PDF file for release v0.6.3 is 111 MB, while the previous version v0.6.2 was only 4.22 MB? 🧐</div>
<div class='msg'><time>2025‑03‑03 11:43</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: The alternative renders are small though https://github.com/JamBrains/graypaper/actions/runs/13629940636</div>
<div class='msg'><time>2025‑03‑03 11:45</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: * The alternative renders are small though https://github.com/JamBrains/graypaper/actions/runs/13629940636 (and if you are not logged into GH, [here](https://jamcha.in/spec))</div>
<div class='msg'><time>2025‑03‑03 13:08</time>&ensp;<span class='u' style='color:#788ad5'>yu2c</span>: Is the missing update of $l$ to $y$ in the serialization of $\mathbb{L}$?https://github.com/gavofyork/graypaper/blob/85129dacf739e76ead2065bb5b84a999e8ac71e7/text/serialization.tex#L143</div>
<div class='msg'><time>2025‑03‑03 14:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@yu2c:matrix.org&gt; Does anyone know why the PDF file for release v0.6.3 is 111 MB, while the previous version v0.6.2 was only 4.22 MB? 🧐

Good point!:) I’ll look into getting a smaller rendering. </div>
<div class='msg'><time>2025‑03‑03 14:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@yu2c:matrix.org&gt; Is the missing update of $l$ to $y$ in the serialization of $\mathbb{L}$?https://github.com/gavofyork/graypaper/blob/85129dacf739e76ead2065bb5b84a999e8ac71e7/text/serialization.tex#L143

PR accepted!:)</div>
<div class='msg'><time>2025‑03‑03 16:58</time>&ensp;<span class='u' style='color:#788ad5'>yu2c</span>: And small suggestion: Add $\mathbb{N}_{R}$ defined in [(4.23)](https://graypaper.fluffylabs.dev/#/85129da/0a13010a2001?v=0.6.3) in the Appendix I / Sets / Regular Notions</div>
<div class='msg'><time>2025‑03‑03 17:35</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: I believe we are not checking the right indices for memory validity in host functions that have wrapping in their memory inspecting/mutation:
http://github.com/gavofyork/graypaper/pull/272</div>
<div class='msg'><time>2025‑03‑03 18:50</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: I saw that formula 14.11 (https://graypaper.fluffylabs.dev/#/85129da/1a9b021aad02?v=0.6.3) on 0.6.3 now passes work item components to ΨR, but ΨR function signature didn&#x27;t change (B.4). It still receives package (p) and item position (i). Where do args S(w,l), X(w) go now? (replaced old î) </div>
<div class='msg'><time>2025‑03‑03 19:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@yu2c:matrix.org&gt; And small suggestion: Add $\mathbb{N}_{R}$ defined in [(4.23)](https://graypaper.fluffylabs.dev/#/85129da/0a13010a2001?v=0.6.3) in the Appendix I / Sets / Regular Notions

PR?:)</div>
<div class='msg'><time>2025‑03‑03 19:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; I believe we are not checking the right indices for memory validity in host functions that have wrapping in their memory inspecting/mutation:
&gt; http://github.com/gavofyork/graypaper/pull/272

Is there any particular reason you think we should be more lenient?</div>
<div class='msg'><time>2025‑03‑03 19:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; I saw that formula 14.11 (https://graypaper.fluffylabs.dev/#/85129da/1a9b021aad02?v=0.6.3) on 0.6.3 now passes work item components to ΨR, but ΨR function signature didn&#x27;t change (B.4). It still receives package (p) and item position (i). Where do args S(w,l), X(w) go now? (replaced old î) 

Please explain?</div>
<div class='msg'><time>2025‑03‑03 20:50</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: ΨR call here passes 11 parameters: (wc,wg ,ws,h,wy ,px, pa,o,S(w,l),X(w),ℓ) (https://graypaper.fluffylabs.dev/#/85129da/1a9b021aad02?v=0.6.3)

But ΨR defined still has only 5 (i,p,o,i,ς): https://graypaper.fluffylabs.dev/#/85129da/2d65002d9300?v=0.6.3 </div>
<div class='msg'><time>2025‑03‑03 21:12</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: &gt; &lt;@gav:polkadot.io&gt; Is there any particular reason you think we should be more lenient?

In poke for example, we read from the ram with wrapping , which means we want to allow for the case where z &gt; ram size, in which case we wrap back to 0. But in that case, Ns…z will not be in Vu, so we will panic</div>
<div class='msg'><time>2025‑03‑03 21:12</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: If we don’t want to handle the case where z &gt; ram size, then we are wrapping unnecessarily</div>
<div class='msg'><time>2025‑03‑03 21:15</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: *s+z</div>
<div class='msg'><time>2025‑03‑04 02:13</time>&ensp;<span class='u' style='color:#823cac'>wabkebab</span>: Jam implementors, technologist and Web3 enthusiast, here you can find the video of the JAM Tour, filmed during the lecture at Taipei University

https://www.youtube.com/watch?v=aTS4yjFsJd0</div>
<div class='msg'><time>2025‑03‑04 02:23</time>&ensp;<span class='u' style='color:#823cac'>wabkebab</span>: * Jam implementors, technologists and Web3 enthusiasts, here you can find the video of the JAM Tour, filmed during the lecture at Taipei University
https://www.youtube.com/watch?v=aTS4yjFsJd0</div>
<div class='msg'><time>2025‑03‑04 02:37</time>&ensp;<span class='u' style='color:#823cac'>wabkebab</span>: * Jam implementors, technologists and Web3 enthusiasts, here you can find one of the videos of the JAM Tour, filmed during the lecture at Taipei University. More content coming! https://www.youtube.com/watch?v=aTS4yjFsJd0</div>
<div class='msg'><time>2025‑03‑04 03:44</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: In 0.5.4 there was extrinsic data blobs in $a$ of Refine invocation:
https://graypaper.fluffylabs.dev/#/579bd12/2d13012d1301?v=0.5.4
but in 0.6.x these extrinsic data blobs seem to have disappeared:
https://graypaper.fluffylabs.dev/#/78ca0a8/2df3002df300?v=0.6.0
There are no release notes for this change
https://github.com/gavofyork/graypaper/releases/tag/v0.6.0
While `fetch` enables access to the extrinsic blob hashes and their lengths of a work item, the extrinsic blobs are not in the work item:
https://graypaper.fluffylabs.dev/#/85129da/199f00199f00?v=0.6.3
So how does Refine fetch the extrinsic data blobs as of 0.6.x?</div>
<div class='msg'><time>2025‑03‑04 05:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@danicuki:matrix.org&gt; ΨR call here passes 11 parameters: (wc,wg ,ws,h,wy ,px, pa,o,S(w,l),X(w),ℓ) (https://graypaper.fluffylabs.dev/#/85129da/1a9b021aad02?v=0.6.3)
&gt; 
&gt; But ΨR defined still has only 5 (i,p,o,i,ς): https://graypaper.fluffylabs.dev/#/85129da/2d65002d9300?v=0.6.3

Yes indeed: https://github.com/gavofyork/graypaper/pull/273</div>
<div class='msg'><time>2025‑03‑04 05:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@sourabhniyogi:matrix.org&gt; In 0.5.4 there was extrinsic data blobs in $a$ of Refine invocation:
&gt; https://graypaper.fluffylabs.dev/#/579bd12/2d13012d1301?v=0.5.4
&gt; but in 0.6.x these extrinsic data blobs seem to have disappeared:
&gt; https://graypaper.fluffylabs.dev/#/78ca0a8/2df3002df300?v=0.6.0
&gt; There are no release notes for this change
&gt; https://github.com/gavofyork/graypaper/releases/tag/v0.6.0
&gt; While `fetch` enables access to the extrinsic blob hashes and their lengths of a work item, the extrinsic blobs are not in the work item:
&gt; https://graypaper.fluffylabs.dev/#/85129da/199f00199f00?v=0.6.3
&gt; So how does Refine fetch the extrinsic data blobs as of 0.6.x?

As I&#x27;ve said countless times now, the GP does not dictate the specifics of data logistics, only observable behaviour. `fetch` requires implementations to return the correct extrinsic data by virtue of the constraints placed on the return value from `fetch`. How it gets the extrinsic data is entirely implementation-specific and left as an exercise for the reader. Probably it will be supplied along with the rest of the WP by the builder, but the GP remains ambivalent about this.</div>
<div class='msg'><time>2025‑03‑04 05:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * As I&#x27;ve said countless times now, the GP does not dictate the specifics of data logistics, only observable behaviour. `fetch` requires implementations to return the correct extrinsic data by virtue of the constraints placed on the return value from `fetch`. How it gets the extrinsic data is entirely implementation-specific and left as an exercise for the reader. Probably it will be supplied along with the rest of the WP by the builder, but the GP does not define this since it is not *observable behaviour*.</div>
<div class='msg'><time>2025‑03‑04 05:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Your question betrays an presupposition that the formalisms in the GP are 1:1 mappable to some implementation code. That may sometimes be the case but certainly not always.</div>
<div class='msg'><time>2025‑03‑04 05:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Your question betrays a presupposition that the formalisms in the GP are 1:1 mappable to some implementation code. That may sometimes be the case but certainly not always.</div>
<div class='msg'><time>2025‑03‑04 05:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: We are able to use formalisms in mathematics such as `let H(return_value) = input_value`</div>
<div class='msg'><time>2025‑03‑04 05:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * e.g. We are able to use formalisms in mathematics such as `let H(return_value) = input_value`. This does not map 1:1 with (procedural) code.</div>
<div class='msg'><time>2025‑03‑04 05:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * e.g. We are able to use formalisms in mathematics such as `let H(return_value) = input_value`. This does not map 1:1 with (procedural) code, because it would imply the ability to make a reverse hash, for which no general solution is known.</div>
<div class='msg'><time>2025‑03‑04 05:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It works in the GP because it is describing *what* we wish to see, not *how* it must be delivered.</div>
<div class='msg'><time>2025‑03‑04 05:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: In the case of implementing the &quot;impossible&quot; reverse hash function, it is fine because implementations are allowed to &quot;cheat&quot; and use external knowledge (such as DA contents or data arriving over the network) in order to arrive at the answer.</div>
<div class='msg'><time>2025‑03‑04 05:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Implementing the GP is a puzzle and intentionally so. There may be different ways of solving the puzzle. This diversity can help deliver a resilient, even anti-fragile, network. Don&#x27;t expect a perfectly described path to implementation. You&#x27;ll need to use your brain.</div>
<div class='msg'><time>2025‑03‑04 05:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; In poke for example, we read from the ram with wrapping , which means we want to allow for the case where z &gt; ram size, in which case we wrap back to 0. But in that case, Ns…z will not be in Vu, so we will panic

Ahh, in fact the wrapping is superfluous.</div>
<div class='msg'><time>2025‑03‑04 05:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; In poke for example, we read from the ram with wrapping , which means we want to allow for the case where z &gt; ram size, in which case we wrap back to 0. But in that case, Ns…z will not be in Vu, so we will panic

 * Ahh, in fact the wrapping is superfluous there.</div>
<div class='msg'><time>2025‑03‑04 05:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>:  * Ahh, in fact the wrapping is superfluous there; I&#x27;ll accept a PR which removes it from the host functions.</div>
<div class='msg'><time>2025‑03‑04 05:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@yu2c:matrix.org&gt; And small suggestion: Add $\mathbb{N}_{R}$ defined in [(4.23)](https://graypaper.fluffylabs.dev/#/85129da/0a13010a2001?v=0.6.3) in the Appendix I / Sets / Regular Notions

PR welcome:)</div>
<div class='msg'><time>2025‑03‑04 06:06</time>&ensp;<span class='u' style='color:#788ad5'>yu2c</span>: https://github.com/gavofyork/graypaper/pull/274 This PR adds the definition of $\N_R$ in Appendix I / Sets / Regular Notion.</div>
<div class='msg'><time>2025‑03‑04 09:19</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: hi there, I&#x27;m currently get confused about the fallback keys (sealing) in grandpa:

while blocks sealed with fallback keys are for the placeholder of contingency, https://graypaper.fluffylabs.dev/#/85129da/1fc0001fc400?v=0.6.3 seems mean that headers with fallback keys are not eligible to be selected as best header, if I&#x27;m not mistaken, the blocks with fallback keys should be selected as the best headers if there are no ticket sealed blocks at the end of slots, plz correct me if I&#x27;m wrong 🙏</div>
<div class='msg'><time>2025‑03‑04 09:19</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * hi there, I&#x27;m currently get confused about the fallback keys (sealing) in grandpa:

while blocks sealed with fallback keys are for the placeholder of contingency, https://graypaper.fluffylabs.dev/#/85129da/1fc0001fc400?v=0.6.3 seems mean that headers with fallback keys are not eligible to be selected as best headers, if I&#x27;m not mistaken, the blocks with fallback keys should be selected as the best headers if there are no ticket sealed blocks at the end of slots, plz correct me if I&#x27;m wrong 🙏</div>
<div class='msg'><time>2025‑03‑04 09:25</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * hi there, I&#x27;m currently confused about the fallback keys (sealing) in grandpa:

while blocks sealed with fallback keys are for the placeholder of contingency, https://graypaper.fluffylabs.dev/#/85129da/1fc0001fc400?v=0.6.3 seems mean that headers with fallback keys are not eligible to be selected as best headers, if I&#x27;m not mistaken, the blocks with fallback keys should be selected as the best headers if there are no ticket sealed blocks at the end of slots, plz correct me if I&#x27;m wrong 🙏</div>
<div class='msg'><time>2025‑03‑04 09:26</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * hi there, I&#x27;m currently confused about the fallback keys (sealing) in grandpa:

while blocks sealed with fallback keys are for the placeholder of contingency, https://graypaper.fluffylabs.dev/#/85129da/1fc0001fc400?v=0.6.3 seems mean that headers with fallback keys are not eligible to be selected as best headers which will make the blocks with fallback keys meaningless, if I&#x27;m not mistaken, the blocks with fallback keys should be selected as the best headers if there are no ticket sealed blocks at the end of slots, plz correct me if I&#x27;m wrong 🙏</div>
<div class='msg'><time>2025‑03‑04 13:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Such blocks may be the only way of extending the chain and getting to the point of having blocks which increase the best chain score. </div>
<div class='msg'><time>2025‑03‑04 13:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Such blocks may be the only way of extending the chain and getting to the point of having regular ticketed blocks which increase the best chain score. </div>
<div class='msg'><time>2025‑03‑04 21:43</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: &gt; &lt;@gav:polkadot.io&gt; Ahh, in fact the wrapping is superfluous.

http://github.com/gavofyork/graypaper/pull/272</div>
<div class='msg'><time>2025‑03‑05 01:34</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: In New, should we panic if the 8th register is not in N-2^32? Because then (c,l) will not be a valid key for the l component of the new service account </div>
<div class='msg'><time>2025‑03‑05 02:40</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: so the case of finalizing headers with fallback keys is: we just finalized a ticketed blocks, and we are requesting the ancestors of the newly finalized ticketed blocks ( blocks with the fallback keys in the header could be here ) ?</div>
<div class='msg'><time>2025‑03‑05 02:40</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * so the case of finalizing headers with fallback keys is: we just finalized a ticketed block, and we are requesting the ancestors of the newly finalized ticketed blocks ( blocks with the fallback keys in the header could be here ) ?</div>
<div class='msg'><time>2025‑03‑05 02:40</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * so the case of finalizing headers with fallback keys is: we just finalized a ticketed block, and we are requesting the ancestors of the newly finalized ticketed blocks ( blocks with the fallback keys in the headers could be here ) ?</div>
<div class='msg'><time>2025‑03‑05 02:42</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * so the case of finalizing headers with fallback keys is: we just finalized a ticketed block, and we are requesting the ancestors of the newly finalized tickete blocks ( blocks with the fallback keys in the headers could be here ) ?</div>
<div class='msg'><time>2025‑03‑05 02:43</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * so the case of finalizing headers with fallback keys is: we just finalized a ticketed block, and we are requesting the ancestors of the newly finalized ticketed blocks ( blocks with the fallback keys in the headers could be here ) ?</div>
<div class='msg'><time>2025‑03‑05 02:44</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: &gt; &lt;@ascriv:matrix.org&gt; In New, should we panic if the 8th register is not in N-2^32? Because then (c,l) will not be a valid key for the l component of the new service account 

Also in new, a is missing the p component which should presumably be {}</div>
<div class='msg'><time>2025‑03‑05 02:53</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * so the case of finalizing headers with fallback keys is: we just confirmed a ticketed block is on the best chain, and we are requesting the ancestors of the newly finalized ticketed blocks ( blocks with the fallback keys in the headers could be here ) ?</div>
<div class='msg'><time>2025‑03‑05 02:53</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * so the case of finalizing headers with fallback keys is: we just confirmed a ticketed block is on the best chain, and we are requesting the ancestors of the best head ( blocks with the fallback keys in the headers could be here ) ?</div>
<div class='msg'><time>2025‑03‑05 02:58</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: http://github.com/gavofyork/graypaper/pull/275</div>
<div class='msg'><time>2025‑03‑05 16:11</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * ~~so the case of finalizing headers with fallback keys is: we just confirmed a ticketed block is on the best chain, and we are requesting the ancestors of the best head ( blocks with the fallback keys in the headers could be here ) ?~~

</div>
<div class='msg'><time>2025‑03‑05 16:12</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * ~~so the case of finalizing headers with fallback keys is: we just confirmed a ticketed block is on the best chain, and we are requesting the ancestors of the best head ( blocks with the fallback keys in the headers could be here ) ?~~

clear about it now, best chain voted by blocks with most ancestor blocks, headers with fallback keys could be part of them</div>
<div class='msg'><time>2025‑03‑06 05:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; In New, should we panic if the 8th register is not in N-2^32? Because then (c,l) will not be a valid key for the l component of the new service account 

Well, it’s not that it’s not “valid” (don’t forget we’re not using typed logic here, just basic set formalisms). Rather that there can be early certainty that if l is not in N_2^32, then there can certainly be no keys (c, l) in the set (H, N_2^32).</div>
<div class='msg'><time>2025‑03‑06 05:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; In New, should we panic if the 8th register is not in N-2^32? Because then (c,l) will not be a valid key for the l component of the new service account 

* Well, it’s not that it’s not “valid” (don’t forget we’re not using typed logic here, just basic set formalisms). Rather that there can be early certainty that if l is not in N_2^32, then there can certainly be no item (c, l) in the set (H, N_2^32).</div>
<div class='msg'><time>2025‑03‑06 05:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; In New, should we panic if the 8th register is not in N-2^32? Because then (c,l) will not be a valid key for the l component of the new service account 

* Well, it’s not that it’s not “valid” (don’t forget we’re not using typed logic here, just basic set formalisms). Rather that there can be early certainty that if l is not in N_2^32, then there can be no item (c, l) in the set (H, N_2^32).</div>
<div class='msg'><time>2025‑03‑06 05:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ascriv:matrix.org&gt; In New, should we panic if the 8th register is not in N-2^32? Because then (c,l) will not be a valid key for the l component of the new service account 

* Well, it’s not that it’s not “valid” (don’t forget we’re not using typed logic here, just basic set formalisms). Rather that there can be early certainty that if l is not in N_2^32, then there can be no item (c, l) in the set (H, N_2^32). This implies no key can exist. </div>
<div class='msg'><time>2025‑03‑06 15:24</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: gav: in your latest lecture in Taipei about JAM, you said that your implementation achieved ~**% speed of native code; would it possible to have the program you used for this benchmark? I&#x27;d love to test jampy PVM around different improvements I have in my sleeve</div>
<div class='msg reply'><time>2025‑03‑06 15:25</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: https://github.com/paritytech/polkavm/blob/master/BENCHMARKS.md</div>
<div class='msg reply'><time>2025‑03‑06 15:25</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: https://github.com/paritytech/polkavm/tree/master/guest-programs</div>
<div class='msg reply'><time>2025‑03‑06 15:27</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: thx Jan</div>
<div class='msg reply'><time>2025‑03‑06 16:00</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: Jan Bujak: I&#x27;m calling `bash guest-programs/build-benchmarks.sh` in order to create pvm and native binaries: it correctly creates PVM binaries, but the x86_64 contains only shared objects. Am I missing a step? </div>
<div class='msg reply'><time>2025‑03‑06 16:01</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: tools/benchtool is used to run those</div>
<div class='msg reply'><time>2025‑03‑06 17:28</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: I&#x27;m giving up since generated files are elf or .polkavm format, and I do not want to read other implementation&#x27;s code. I&#x27;ll write my own benchmark program</div>
<div class='msg'><time>2025‑03‑06 17:45</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: for the &#x27;info&#x27; host call-&gt; where is the serialization of the service accounts preimage availability dictionary (l) defined? 

https://graypaper.fluffylabs.dev/#/5f542d7/307f02307f02?v=0.6.2</div>
<div class='msg'><time>2025‑03‑06 22:13</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: Pretty sure this is the case, but want to verify here-&gt; this branch conditional in the read host call is TYPE equivalence rather than literal equivalence? So this branch wouldn&#x27;t be taken if w7 == s, only in the case where w7 == 2^64-1

https://graypaper.fluffylabs.dev/#/5f542d7/308500308500?v=0.6.2</div>
<div class='msg'><time>2025‑03‑07 00:28</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: </div>
<div class='msg'><time>2025‑03‑07 20:23</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: &gt; &lt;@gav:polkadot.io&gt; Well, it’s not that it’s not “valid” (don’t forget we’re not using typed logic here, just basic set formalisms). Rather that there can be early certainty that if l is not in N_2^32, then there can certainly be no keys (c, l) in the set (H, N_2^32).

For some cases when lhs and rhs types are different, it’s clear what to do, for example in set inclusion we can safely interpret as evaluating to false. But in other cases where lhs and rhs are different types, like the building of the set that is the new service account, it becomes too ambiguous. One interpretation is that the l component in the new service account should be empty. Another is that a should be \error . I’ve made a PR with the second interpretation 
http://github.com/gavofyork/pull/279</div>
<div class='msg'><time>2025‑03‑07 20:24</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: * For some cases when lhs and rhs types are different, it’s clear what to do, for example in set inclusion we can safely interpret as evaluating to false. But in other cases where lhs and rhs are different types, like the building of the set that is the new service account, it becomes too ambiguous. One interpretation is that the l component in the new service account should be empty. Another is that a should be \error . I’ve made a PR with the second interpretation 
http://github.com/gavofyork/graypaper/pull/279</div>
<div class='msg'><time>2025‑03‑08 08:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes, that&#x27;s fair. Merged.</div>
<div class='msg'><time>2025‑03‑08 08:15</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: you&#x27;ve highlighted regular l, when the preimage dictionary is bold-l.</div>
<div class='msg'><time>2025‑03‑08 08:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: regular l is an dependent field.</div>
<div class='msg'><time>2025‑03‑08 08:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: s* and s are both in `\N_S`. the comparison is just a simple numeric one.</div>
<div class='msg'><time>2025‑03‑08 08:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * No idea what you&#x27;re talking about. s\* and s are both in `\N_S`. the comparison is just a simple numeric one.</div>
<div class='msg'><time>2025‑03‑08 08:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * No idea what you&#x27;re talking about. s\* and s are both in `\N_S`. the comparison is just a simple numeric one. If you work the logic through, it would be taken is omega_7 = s or omega_7 = 2^64-1.</div>
<div class='msg'><time>2025‑03‑08 08:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * No idea what you&#x27;re talking about. s\* and s are both in `\N_S`. the comparison is just a simple numeric one. If you work the logic through, it would be taken if either omega\_7 = s or omega\_7 = 2^64-1.</div>
<div class='msg'><time>2025‑03‑08 08:20</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * No idea what you&#x27;re talking about. s\* and s are both in `\N_S`. the comparison is just a simple numeric one. If you work the logic through, it would be taken if `omega_7 in { s,  2^64-1 }`.</div>
<div class='msg'><time>2025‑03‑08 14:45</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: Thanks for the response! I&#x27;m not sure I&#x27;m following though? &#x27;t&#x27; is referencing an account, and I only see &#x27;l&#x27; used in the accounts context when referring to the lookup dict? It would make sense if the metadata returned by the info host call contains some metadata about preimages, maybe just the keys even -&gt; but I&#x27;m assuming that would be represented as K{t}_l in the spec if that were the case...</div>
<div class='msg'><time>2025‑03‑08 15:02</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: Thanks for clarifying! Wasn&#x27;t sure if an account being able to selectively target its *s* vs. *d* context was a valid use case. Also was getting hung up on this being a more verbose way to get to &#x27;a&#x27; than in the previous host call (lookup) -&gt; but I see the intermediate value used when querying the storage, so the verbosity makes sense there.</div>
<div class='msg'><time>2025‑03‑08 20:35</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: For the bless and assign host calls, what should happen if a non-privileged service tries to update it? Panic? The GP doesn’t really specify.</div>
<div class='msg'><time>2025‑03‑08 20:38</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: * For the bless and assign host calls, what should happen if a non-privileged service tries to execute it? Panic? The GP doesn’t really specify.</div>
<div class='msg'><time>2025‑03‑08 22:32</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: * Hello. For the bless and assign host calls, what should happen if a non-privileged service tries to execute it? Panic? The GP doesn’t really specify.</div>
<div class='msg'><time>2025‑03‑09 01:48</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: * Hello. For the bless and assign host calls, what should happen if a non-privileged service tries to execute it? Panic or HUH? The GP doesn’t really specify.</div>
<div class='msg'><time>2025‑03‑10 13:25</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: Happy Monday folks. In the &#x27;new&#x27; host function-&gt; the GP doesn&#x27;t specify what should happen if the preimage blob length is above the valid range required by the account spec (N_l = 2^32). There is a related case where this type of behavior is specified-&gt; In the bless host call the GP specifies a &#x27;WHO&#x27; exit when the values aren&#x27;t within the valid N_s range. Curious to hear what the guidance is here, happy to open a PR if needed.

https://graypaper.fluffylabs.dev/#/5f542d7/31db0031e600?v=0.6.2</div>
<div class='msg'><time>2025‑03‑11 17:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Exactly what the GP specifies.</div>
<div class='msg'><time>2025‑03‑11 17:59</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Ahh yes, l subscript should actually be o subscript.</div>
<div class='msg'><time>2025‑03‑11 17:59</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Ahh yes, `l` subscript should actually be `o` subscript.</div>
<div class='msg'><time>2025‑03‑11 17:59</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Ahh yes, `t_l` should actually be `t_o`.</div>
<div class='msg'><time>2025‑03‑11 18:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Ahh yes, `t_l` should actually be `t_o`. Feel free to post an issue or make a PR:)</div>
<div class='msg'><time>2025‑03‑11 18:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Exactly what the GP specifies. It returns OK, but ultimately will be ignored.</div>
<div class='msg'><time>2025‑03‑11 18:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Exactly what the GP specifies. It returns OK (but ultimately will be ignored).</div>
<div class='msg'><time>2025‑03‑11 18:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: This was previously reported and is addressed in `main` branch.</div>
<div class='msg'><time>2025‑03‑11 18:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Exactly what the GP specifies. It returns OK but has no effect on the system&#x27;s state.</div>
<div class='msg'><time>2025‑03‑11 18:11</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: &gt; &lt;@gav:polkadot.io&gt; Exactly what the GP specifies. It returns OK but has no effect on the system&#x27;s state.

Thanks!</div>
<div class='msg'><time>2025‑03‑11 18:12</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: https://github.com/gavofyork/graypaper/pull/284</div>
<div class='msg'><time>2025‑03‑11 18:13</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: &gt; &lt;@jay_ztc:matrix.org&gt; Happy Monday folks. In the &#x27;new&#x27; host function-&gt; the GP doesn&#x27;t specify what should happen if the preimage blob length is above the valid range required by the account spec (N_l = 2^32). There is a related case where this type of behavior is specified-&gt; In the bless host call the GP specifies a &#x27;WHO&#x27; exit when the values aren&#x27;t within the valid N_s range. Curious to hear what the guidance is here, happy to open a PR if needed.
&gt; 
&gt; https://graypaper.fluffylabs.dev/#/5f542d7/31db0031e600?v=0.6.2

I made a change which results in a panic if that happens</div>
<div class='msg'><time>2025‑03‑11 18:15</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: I see it now, thanks!</div>
<div class='msg'><time>2025‑03‑11 22:05</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: I see in the on transfer and accumulate invocations we check if a service account’s code hash is “without value” but according to the service account type the code has must have a value. Is the service account type wrong or are these checks wrong?</div>
<div class='msg'><time>2025‑03‑11 22:05</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: * I see in the on transfer and accumulate invocations we check if a service account’s code hash is “without value” but according to the service account type the code hash must have a value. Is the service account type wrong or are these checks wrong?</div>
<div class='msg'><time>2025‑03‑12 09:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: what makes you think that the code hash must have a value?</div>
<div class='msg'><time>2025‑03‑12 09:50</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>: The accumulate invocation returns unsigned gas (N_G): https://graypaper.fluffylabs.dev/#/85129da/2e3e002e5a00?v=0.6.3

Shouldn&#x27;t the return value be signed gas (Z_G), as Psi_M is returning signed gas? The same also for C, where now the input and output should then probably be both Z_G? Or should C instead return 0 for the out-of-gas case?</div>
<div class='msg'><time>2025‑03‑12 12:19</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: &gt; &lt;@gav:polkadot.io&gt; what makes you think that the code hash must have a value?

In 9.3 the code hash is of type H, I think if we want it to be able to be valueless it should be of type “H?” ?</div>
<div class='msg'><time>2025‑03‑12 15:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: ahh right, sure the hash is non-empty.</div>
<div class='msg'><time>2025‑03‑12 15:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * ahh right, sure the hash is non-empty. but there may not be a preimage.</div>
<div class='msg'><time>2025‑03‑12 15:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: regular c and bold c are not the same.</div>
<div class='msg'><time>2025‑03‑12 15:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes indeed. I suspect this may have been incorrectly corrected recently.</div>
<div class='msg'><time>2025‑03‑12 15:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Feel free to make a PR/issue.</div>
<div class='msg'><time>2025‑03‑12 15:50</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: &gt; &lt;@gav:polkadot.io&gt; regular c and bold c are not the same.

Yep, misread as regular c. Thanks </div>
<div class='msg'><time>2025‑03‑12 16:49</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>: Sure, for C to return 0 in case of negative gas or for change to Z_G? If change to Z_G, then this will also spill over into Psi_A and the accumulation chapter, where N_G is expected.</div>
<div class='msg'><time>2025‑03‑13 12:17</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes, in fact it was confusing the gas used (which is the PVM gas counter and can be negative in the case of an underrun) with gas remaining (which is the value used by the higher level accumulation functions). Should make more sense with https://github.com/gavofyork/graypaper/pull/288.</div>
<div class='msg'><time>2025‑03‑13 12:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Yes, in fact it was confusing the gas remaining (which is the PVM gas counter and can be negative in the case of an underrun) with gas used (which is the value used by the higher level accumulation functions). Should make more sense with https://github.com/gavofyork/graypaper/pull/288.</div>
<div class='msg'><time>2025‑03‑13 12:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Yes, in fact it was confusing the gas remaining (which is the PVM gas counter and can be negative in the case of an underrun) with gas used (which is the value used by the higher level accumulation functions and cannot be negative). Should make more sense with https://github.com/gavofyork/graypaper/pull/288.</div>
<div class='msg'><time>2025‑03‑15 19:11</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: In the outer accumulation function, is it intended that the free accumulation services dict be zeroed out after the first iteration? Couldn’t there be work reports in the remaining ones which was made by a free accumulation service?</div>
<div class='msg reply'><time>2025‑03‑17 05:22</time>&ensp;<span class='u' style='color:#4068cd'>0xjunha</span>: My understanding is that the always-accumulate services are privileged to be processed first, followed by other services. And there is enough gas to run all the always-accumulate services in the initial round, so those getting accumulated later than the initial round would never happen.</div>
<div class='msg'><time>2025‑03‑17 04:40</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: </div>
<div class='msg'><time>2025‑03‑17 04:41</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * hey teams, curious about in your implementations, after genesis, can you ensure there will be no empty slots in the local testnet? e.g.

there are valid blocks on each of the time slots and all of them get full finalized with all of the nodes within 6 seconds </div>
<div class='msg'><time>2025‑03‑17 04:43</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * hey teams, curious about in your implementations, after genesis, can you ensure there will be no empty slots in the local testnet? e.g. there are valid blocks on each of the time slots and all of them get full finalized with all of the nodes within 6 seconds</div>
<div class='msg'><time>2025‑03‑17 05:28</time>&ensp;<span class='u' style='color:#4068cd'>0xjunha</span>: * My understanding is that the always-accumulate services should be processed first, followed by other services. And there is enough gas to run all the always-accumulate services in the initial round, so those getting accumulated later than the initial round would never happen.</div>
<div class='msg'><time>2025‑03‑17 10:04</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: I think I&#x27;ve found something interesting when handling the `ecalli` pvm fn. According to the gp `ΨH|A.34` calls `Ψ()|A.1` and handles the  `ε′ = hxh`. 

The `ecalli` fn ( https://graypaper.fluffylabs.dev/#/85129da/25ff0025ff00?v=0.6.3 )  is set to modify just `ε` leaving the default `ı′ = ı + 1 + skip(ı)` defined in A.7 in place. 

Then the host call gets executed inside `ΨH|A.34`. If all goes ok and `f` returs (▸, ....) then we should recursively call `ΨH` but with `ı′′` which is defined as `ı′′ = ı′ + 1 + skip(ı′)`. Now since `i&#x27;` is what is being retrned by `Ψ` and is already skipping an instruction, then `ΨH` gets called by skipping one instruction (due to the 2x skips being applied).

Now i think this is either a misinterpretation of mine or an error in the graypaper as in my point of view it makes no sense to skip 1 instruction after a successful hostcall execution via ecalli. Multiple implementations seems to agree with this considering there are multiple implementors passing the duna testnet.</div>
<div class='msg'><time>2025‑03‑17 10:06</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: * I think I&#x27;ve found something interesting when handling the `ecalli` pvm fn. According to the gp `ΨH|A.34` calls `Ψ()|A.1` and handles the  `ε′ = hxh`.

The `ecalli` fn ( https://graypaper.fluffylabs.dev/#/85129da/25ff0025ff00?v=0.6.3 )  is set to modify just `ε` leaving the default `ı′ = ı + 1 + skip(ı)` defined in A.7 in place.

Then the host call gets executed inside `ΨH|A.34`. If all goes ok and `f` returs (▸, ....) then we should recursively call `ΨH` but with `ı′′` which is defined as `ı′′ = ı′ + 1 + skip(ı′)`. Now since `i&#x27;` is what is being retrned by `Ψ` and is already skipping an instruction, then `ΨH` gets called by skipping another instruction (due to the 2x skips being applied).

Now i think this is either a misinterpretation of mine or an error in the graypaper as in my point of view it makes no sense to skip 1 instruction after a successful hostcall execution via ecalli. Multiple implementations seems to agree with this considering there are multiple implementors passing the duna testnet.</div>
<div class='msg'><time>2025‑03‑17 10:52</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: * I think I&#x27;ve found something interesting when handling the `ecalli` pvm fn. According to the gp `ΨH|A.34` calls `Ψ()|A.1` and handles the  `ε′ = hxh`.

The `ecalli` fn ( https://graypaper.fluffylabs.dev/#/85129da/25ff0025ff00?v=0.6.3 )  is set to modify just `ε` leaving the default `ı′ = ı + 1 + skip(ı)` defined in A.7 in place.

Then the host call gets executed inside `ΨH|A.34`. If all goes ok and `f` returns (▸, ....) then we should recursively call `ΨH` but with `ı′′` which is defined as `ı′′ = ı′ + 1 + skip(ı′)`. Now since `i&#x27;` is what is being returned by `Ψ` and is already skipping an instruction, then `ΨH` gets called by skipping another instruction (due to the 2x skips being applied).

Now i think this is either a misinterpretation of mine or an error in the graypaper as in my point of view it makes no sense to skip 1 instruction after a successful hostcall execution via ecalli. Multiple implementations seems to agree with this considering there are multiple implementors passing the duna testnet.</div>
<div class='msg'><time>2025‑03‑17 14:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: You mean this, right? https://github.com/gavofyork/graypaper/issues/247</div>
<div class='msg'><time>2025‑03‑17 14:51</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: yes. i didnt see this issue daaamn. but essentially yeah its 247</div>
<div class='msg'><time>2025‑03‑17 14:51</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: * yes. i didnt see this issue daaamn. but essentially yeah its the same as i am reporting</div>
<div class='msg'><time>2025‑03‑17 14:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: https://github.com/gavofyork/graypaper/pull/292</div>
<div class='msg'><time>2025‑03‑17 15:01</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: perfect thanks</div>
<div class='msg'><time>2025‑03‑17 19:54</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: Hey, I have a question relating to guaranteeing/auditing timing. After a work package is guaranteed and included on-chain, assurers will normally start assuring its availability in the next slot. Is there any reason to wait for these assurances to be posted, or can the auditors (if they are assigned to that specific core) just immediately request shards from the original guarantors? My implementation currently doesn&#x27;t wait for the assurances and just wanted to see if thats okay, or if i should change the timing around.</div>
<div class='msg'><time>2025‑03‑18 00:01</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: * Hey, I have a question relating to guaranteeing/auditing timing. After a work package is guaranteed and included on-chain, assurers will normally start assuring its availability in the next slot. Is there any reason to wait for these assurances to be posted, or can the auditors (if they are assigned to that specific core) just immediately request shards from the original guarantors? My implementation currently doesn&#x27;t wait for the assurances and just wanted to see if thats okay, or if i should change the timing around. What are the best practices here?</div>
<div class='msg'><time>2025‑03‑18 02:30</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: https://graypaper.fluffylabs.dev/#/85129da/1b6d001b8800?v=0.6.3
Is equation (14.14) using J_x as defined in (E.5) or the PagedProof P described in (14.10)?

From the preceding equations, it appears to use J_x, but the paragraph stating that “such a vast amount of data is not generally needed as the justification can be derived through a single PagedProof” suggests that using P could also be reasonable. Could we get a clarification on this?</div>
<div class='msg'><time>2025‑03‑18 17:33</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: </div>
<div class='msg'><time>2025‑03‑18 17:53</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: * What doeas [`t_o`](https://graypaper.fluffylabs.dev/#/85129da/307f02307f02?v=0.6.3) mean in the info host\_call function?

In the graypaper reader version 3 March 2025 this term is `t_l`, but in the latest version of the GP 0.6.3 March 13 2025 this term is `t_o`.</div>
<div class='msg'><time>2025‑03‑18 17:54</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: * What does [`t_o`](https://graypaper.fluffylabs.dev/#/85129da/307f02307f02?v=0.6.3) mean in the info host\_call function?

In the graypaper reader version 3 March 2025 this term is `t_l`, but in the latest version of the GP 0.6.3 March 13 2025 this term is `t_o`.</div>
<div class='msg'><time>2025‑03‑18 18:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Not sure what you mean: see section 17.3; audit selection happens on all work-reports &quot;pending which have just become available&quot;.

</div>
<div class='msg'><time>2025‑03‑18 18:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: So you&#x27;ll never be self-selecting to audit a work-report until you, at least, believe it is available.</div>
<div class='msg reply'><time>2025‑03‑18 18:27</time>&ensp;<span class='u' style='color:#d470bf'>jaymansfield</span>: Thanks this answers the question. </div>
<div class='msg'><time>2025‑03‑18 18:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 14.14 defines regular-J, using caligraphic-J, itself defined in E.5</div>
<div class='msg'><time>2025‑03‑18 18:32</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * 14.14 defines regular-J, using caligraphic-J (subscripted with 0), itself defined in E.5.</div>
<div class='msg'><time>2025‑03‑18 18:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 14.14 does not use the paged-proof(regular-P, 14.10) at all.</div>
<div class='msg'><time>2025‑03‑18 18:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * The formulation of 14.14 does not use the paged-proof(regular-P, 14.10) at all.</div>
<div class='msg'><time>2025‑03‑18 18:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Now, please remember as I&#x27;ve now countless times, the Gray Paper defines *observable behaviour*. It doesn&#x27;t necessarily tell you how to create that behaviour.</div>
<div class='msg'><time>2025‑03‑18 18:34</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Now, please remember as I&#x27;ve now said countless times, the Gray Paper defines _observable behaviour_. It doesn&#x27;t necessarily tell you how to create that behaviour.</div>
<div class='msg'><time>2025‑03‑18 18:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: In this case, as the text states, you&#x27;ll need to combine this formulation with the page-proof formulation and see that you can create the correct behaviour without  requiring all of the data in the segment tree.</div>
<div class='msg'><time>2025‑03‑18 18:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: That&#x27;s indeed the whole point of the paged-proofs. They&#x27;re a very efficient means of storing proofs across nodes for proving the correctness of exported data when the time comes to import them.</div>
<div class='msg'><time>2025‑03‑18 18:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * That&#x27;s indeed the whole point of the paged-proofs. They&#x27;re a very efficient means of storing proofs across nodes for showing the correctness of exported data segments when the time comes to import them.</div>
<div class='msg'><time>2025‑03‑18 18:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * The formulation of 14.14 does not use the paged-proof(regular-P, 14.10) formulation at all.</div>
<div class='msg'><time>2025‑03‑18 18:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * In this case, as the text states, you&#x27;ll need to combine this formulation with the page-proof formulation and see that you can create the correct behaviour without requiring all of the data in the segment tree.</div>
<div class='msg'><time>2025‑03‑18 18:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: So you&#x27;ll need to study (14.10) and understand that for any export, a relevant proof-page can be used and information from within the two parts of it can be (quite easily) selected and combined in order to produce a full import-justification.</div>
<div class='msg reply'><time>2025‑03‑19 00:36</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: ok! Thanks for replying me!</div>
<div class='msg'><time>2025‑03‑18 18:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * So you&#x27;ll need to study (14.10) and understand that for any export, a relevant proof-page can be used and information from within the two parts of it can be (quite easily) selected and combined in order to produce a full import-justification of the form needed by (14.14 J).</div>
<div class='msg'><time>2025‑03‑18 18:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * So you&#x27;ll need to study (14.10) and understand that for any export, a relevant proof-page can be fetched and information from within the two parts of it can be (quite easily) selected and combined in order to produce a full import-justification of the form needed by (14.14 J).</div>
<div class='msg'><time>2025‑03‑18 18:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * So you&#x27;ll need to study (14.10) and understand that for any export, a relevant proof-page can be fetched from the Segments DA and information from within the two parts of it can be (quite easily) selected and combined in order to produce a full import-justification of the form needed by (14.14 J).</div>
<div class='msg'><time>2025‑03‑18 19:24</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: @room [v0.6.4 is released](https://github.com/gavofyork/graypaper/releases/tag/v0.6.4). Many minor fixes and clarifications in here; the only real changes are:
- [Activity statistics](https://github.com/gavofyork/graypaper/pull/285)
- [Assurances are checked with the prior validator set (rather than posterior)](https://github.com/gavofyork/graypaper/pull/281)
- [Include ed25519 keys in the epoch marker](https://github.com/gavofyork/graypaper/pull/282)</div>
<div class='msg'><time>2025‑03‑18 19:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Activity statistics should help us understand what our JAM instances are actually doing and would be a nice thing to monitor and visualise on a web/cli tool if anyone&#x27;s making any.</div>
<div class='msg'><time>2025‑03‑18 21:11</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Is it reasonable to use [CE139](https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-139140-segment-shard-request) to fetch the relevant-proof page from &quot;Segments DA&quot;, where the `Segment Index` of CE139 is _greater_ than the export count?</div>
<div class='msg'><time>2025‑03‑18 21:12</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * Is it reasonable to use [CE139](https://github.com/zdave-parity/jam-np/blob/main/simple.md#ce-139140-segment-shard-request) to fetch the relevant-proof page (or rather shards of the proof page, so as to reconstruct the proof page) from &quot;Segments DA&quot;, where the `Segment Index` of CE139 is _greater_ than the export count?</div>
<div class='msg'><time>2025‑03‑18 21:16</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Yes, that&#x27;s intended even</div>
<div class='msg'><time>2025‑03‑18 21:26</time>&ensp;<span class='u' style='color:#449ad3'>eclesiomelo</span>: hey guys! I have a question regards the test service in the Accumulation test vector, we have tried to parse it using the definition A.37. I would like to confirm that this PVM blob is formatted according to this definition and not simply A.2 (deblob), is this correct?</div>
<div class='msg reply'><time>2025‑03‑19 04:15</time>&ensp;<span class='u' style='color:#6ecf94'>qiwei</span>: yes, it&#x27;s a standard program blob</div>
<div class='msg reply'><time>2025‑03‑19 14:44</time>&ensp;<span class='u' style='color:#449ad3'>eclesiomelo</span>: okay, so given the definition A.37 the first 3 bytes encodes the |o|, however the first 3 bytes in the test service is 0x47000c which decodes to 786503 in decimal. 

</div>
<div class='msg reply'><time>2025‑03‑19 14:44</time>&ensp;<span class='u' style='color:#449ad3'>eclesiomelo</span>: image.png</div>
<div class='msg reply'><time>2025‑03‑19 15:00</time>&ensp;<span class='u' style='color:#449ad3'>eclesiomelo</span>: I am using the inverse of integer encoding, definition C.5, and where I pass [47, 00, 0c] and as output I got 786503, which I think I am missing something.</div>
<div class='msg'><time>2025‑03‑19 07:19</time>&ensp;<span class='u' style='color:#5e86de'>boymaas</span>: I am double-checking my implementation against the GP, and a question arose. I conclude that if we have a configuration with a W* such that the sum of gas consumption for W* is greater than G_a * C, then we would be overspending the provided gas limit (https://graypaper.fluffylabs.dev/#/85129da/176503176f03?v=0.6.3) with our always accumulate services (https://graypaper.fluffylabs.dev/#/85129da/175901175901?v=0.6.3). I searched for a condition that would prevent this but could not find one. Furthermore, this line from the Gray Paper suggests that such a scenario is possible:

	“We work with a limited amount of gas per block and therefore may not be able to process all items in W∗ in a single block.”
(https://graypaper.fluffylabs.dev/#/85129da/160e02161102?v=0.6.3)

If my conclusion is correct, is this overspending allowed by design?</div>
<div class='msg'><time>2025‑03‑19 10:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; then we would be overspending the provided gas limit

No.</div>
<div class='msg'><time>2025‑03‑19 10:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: W* is the *accumulatable* WRs; we don&#x27;t accumulate all of them if the gas limit doesn&#x27;t allow.</div>
<div class='msg'><time>2025‑03‑19 10:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: As for always-accumulate services, see (12.20) - there&#x27;s always enough gas to accumulate those.</div>
<div class='msg'><time>2025‑03‑19 10:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * As for always-accumulate services, see (12.20) - there&#x27;s always enough gas to accumulate those in addition to the usual amount for each core.</div>
<div class='msg'><time>2025‑03‑19 10:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There&#x27;s an additional note placed on G_T in definitions advising to account for the always-accumulate services, but because of (12.20) G_T formally only places a lower-limit on the amount of gas used; if there&#x27;s more always-accumulate gas than would fit into G_T, we run &quot;over&quot; G_T and honour the always-accumulate gas.</div>
<div class='msg'><time>2025‑03‑19 11:29</time>&ensp;<span class='u' style='color:#5e86de'>boymaas</span>: Thank you, gav . I am going to take another look later today. I was aware of 12.20 with the addition of the always accumulate services. I was imagining a scenario where we could get a set of accumulatable WRs whose total gas consumption would be more than Gₐ * C. Where fe an immediate WR, would resolve a bunch of queued WRs. In a tiny network setup with 2 cores for example. Since g is used to select a subset of the accumulable WRs I though it could eat into the reserve for the always accumulate services.</div>
<div class='msg'><time>2025‑03‑19 12:17</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: Should [this](https://graypaper.fluffylabs.dev/#/85129da/2dff012dff01?v=0.6.3) be `H?`</div>
<div class='msg'><time>2025‑03‑19 12:44</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: * Should [this](https://graypaper.fluffylabs.dev/#/85129da/2dff012dff01?v=0.6.3) be `H?` ?</div>
<div class='msg'><time>2025‑03‑19 14:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Always-accumulate services should be in the first &quot;batch&quot; of WRs accumulated (i.e. among the first items of W*) so they will, indeed, always accumulate.</div>
<div class='msg'><time>2025‑03‑19 14:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Should *what* be `H`?</div>
<div class='msg'><time>2025‑03‑19 14:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Not at all clear what you&#x27;re pointing at or the reasoning behind your suggestion/</div>
<div class='msg'><time>2025‑03‑19 14:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Not at all clear what you&#x27;re pointing at or the reasoning behind your suggestion.</div>
<div class='msg'><time>2025‑03‑19 14:45</time>&ensp;<span class='u' style='color:#449ad3'>eclesiomelo</span>: * okay, so given the definition A.37 the first 3 bytes encodes the |o|, however the first 3 bytes in the test service is 0x47000c which decodes to 786503 in decimal which is greater than the test service total bytes

</div>
<div class='msg'><time>2025‑03‑19 14:57</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: [Eq B.6](https://graypaper.fluffylabs.dev/#/85129da/2def012d0102?v=0.6.3) defines the result context of the accumulate invocation `X`. The last term of this equation is `y ∈ ¿H`. Should this term be `y ∈ H?` instead of `y ∈ ¿H` since the operator `¿` is used for serialisable terms?</div>
<div class='msg'><time>2025‑03‑19 14:59</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: * [Eq B.6](https://graypaper.fluffylabs.dev/#/85129da/2def012d0102?v=0.6.3) defines the result context `X` of the accumulate invocation. The last term of this equation is `y ∈ ¿H`. Should this term be `y ∈ H?` instead of `y ∈ ¿H` since the operator `¿` is used for serialisable terms?</div>
<div class='msg'><time>2025‑03‑19 15:03</time>&ensp;<span class='u' style='color:#c457c5'>vinsystems</span>: * [Eq B.6](https://graypaper.fluffylabs.dev/#/85129da/2def012d0102?v=0.6.3) defines the result context `X` of the accumulate invocation. The last term of this equation is `y ∈ ¿H`. Should this term be `y ∈ H?` instead of `y ∈ ¿H` since the operator `¿` is used for serializable terms?</div>
<div class='msg'><time>2025‑03‑19 15:14</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Ahh I see; yes.</div>
<div class='msg'><time>2025‑03‑19 15:17</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: https://github.com/gavofyork/graypaper/pull/299</div>
<div class='msg'><time>2025‑03‑19 17:12</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: C(13) in Eq D.2 needs to get the current / last validator stats (pi_V, pi_L) back in I think --</div>
<div class='msg'><time>2025‑03‑19 17:13</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * C(13) in Eq D.2 needs to get the current / last validator stats (pi\_V, pi\_L) back in (from 13.1/13.2)</div>
<div class='msg'><time>2025‑03‑19 17:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Please explain/</div>
<div class='msg'><time>2025‑03‑19 17:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Please explain</div>
<div class='msg'><time>2025‑03‑19 17:38</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: The subscripts in C(13) in D.2 only have { C, S } but should have { C, S, V, L } to cove both core/service activity (the new elements of C(13)) and validator statistics activity (the old elements of C(13)), that&#x27;s all.</div>
<div class='msg'><time>2025‑03‑19 17:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Not sure what you&#x27;re looking at</div>
<div class='msg'><time>2025‑03‑19 17:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: `main` branch currently reads:</div>
<div class='msg'><time>2025‑03‑19 17:39</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: image.png</div>
<div class='msg'><time>2025‑03‑19 17:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: image.png</div>
<div class='msg'><time>2025‑03‑19 17:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I suspect the problem you&#x27;re describing was fixed by https://github.com/gavofyork/graypaper/pull/298</div>
<div class='msg'><time>2025‑03‑19 17:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; The subscripts in C(13) in D.2 only have { C, S }

(They actually had C, L and S, but were indeed missing V as the typo had C twice.</div>
<div class='msg'><time>2025‑03‑19 17:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * &gt; The subscripts in C(13) in D.2 only have { C, S }

(They actually had C, L and S, but were indeed missing V as the typo had C twice.)</div>
<div class='msg'><time>2025‑03‑19 17:44</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * The subscripts in C(13) in D.2 only have { C, S, L } but should have { C, S, V, L } to cover both core/service activity (the new elements of C(13)) and validator statistics activity (the old elements of C(13)), that&#x27;s all.</div>
<div class='msg'><time>2025‑03‑19 17:47</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Would it be ok to seed a JAM implementer DAO on this repo
 https://github.com/w3f-webops/graypaper-website/pull/96</div>
<div class='msg'><time>2025‑03‑19 18:59</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: How did you end up with W_M = 3072 (The maximum number of imports and exports in a work-package.) which implies at most 48 proof pages and 12.6MB of CoreVM memory -- is this due to bandwidth or networking considerations?    With 4104 byte proof pages, you can fit many more export segments.  If we solved the 14.10/14.14 &quot;puzzle&quot;, we have only 64*32+192 byte = 2240 bytes out the 4104 bytes being used.  You can definitely fit many many more segments with the unused proof page space of 4104-2240=1864 bytes</div>
<div class='msg'><time>2025‑03‑19 19:00</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * How did you end up with W\_M = 3072 (The maximum number of imports and exports in a work-package.) which implies at most 48 proof pages and 12.6MB of CoreVM memory -- is this due to bandwidth or networking considerations?    With 4104 bytes usable per proof page, you can fit many many more import/export segments than 3072.   If we solved the 14.10/14.14 &quot;puzzle&quot;, we have only 64\*32+192 byte = 2240 bytes out the 4104 bytes being used.  You can definitely fit many many more segments with the unused proof page space of 4104-2240=1864 bytes</div>
<div class='msg'><time>2025‑03‑19 19:02</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: I didn&#x27;t come up with these numbers; Gav did. I think they&#x27;re based primarily on bandwidth usage, as discussed in the discussion section at the end of the GP</div>
<div class='msg'><time>2025‑03‑19 19:08</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Re proof segment usage, think one reason for the choice of 64 is that it&#x27;s a power-of-2 which makes things simple -- you fit a complete subtree in a page. Could probably fit more page proofs in but it would get more complicated as you would have a partial subtree. Not sure if there are other reasons.</div>
<div class='msg'><time>2025‑03‑19 19:10</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: * Re proof segment usage, think one reason for the choice of 64 is that it&#x27;s a power-of-2 which makes things simple -- you fit a complete subtree in a segment. Could probably fit more page proofs in but it would get more complicated as you would have a partial subtree. Not sure if there are other reasons.</div>
<div class='msg'><time>2025‑03‑19 19:10</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: * Re proof segment usage, think one reason for the choice of 64 is that it&#x27;s a power-of-2 which makes things simple -- you fit a complete subtree in a segment. Could probably fit more proofs in but it would get more complicated as you would have a partial subtree. Not sure if there are other reasons.</div>
<div class='msg'><time>2025‑03‑19 19:10</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: * Re proof segment usage, think one reason for the choice of 64 is that it&#x27;s a power-of-2 which makes things simple -- you fit a complete subtree in a segment. Could probably fit more proofs in but it would get more complicated as you would have a partial subtree (or multiple subtrees depending on how you look at it). Not sure if there are other reasons.</div>
<div class='msg'><time>2025‑03‑19 19:21</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Did you get &quot;full&quot; erasure coding decoding in the JAM Toaster yet (or some serious fraction of it) --  I&#x27;ve been bothered by doing all this networking just to get a measly 12 bytes  and was wondering if instead of W_G=4104 pages we&#x27;d like something slightly bigger than 64K or 128K instead (thus getting 16x-32x as much).   Then the 3072 could gets 16 or 32x times as much memory but of course 16x - 32x as much bandwidth usage.  The idea would be that you can get your CoreVM loaded with fewer segments and network calls, but maybe someone will want a CoreVM to have not 12.6MB or memory but 200MB or 400MB instead.  Not sure if W_G = 4104 is chosen to be compatible with some RISC-V related considerations?</div>
<div class='msg'><time>2025‑03‑19 19:25</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * Did you get &quot;full&quot; erasure coding decoding in the JAM Toaster yet (or some serious fraction of it) --  I&#x27;ve been bothered by doing all this networking just to get a measly 12 bytes  and was wondering if instead of W\_G=4104 pages we&#x27;d like something slightly bigger than 64K or 128K instead (thus getting 16x-32x as much).   Then the 3072 could gets 16 or 32x times as much memory but of course 16x - 32x as much bandwidth usage.  The idea would be that you can get your CoreVM loaded with fewer segments and network calls, but maybe someone will want a CoreVM to have not 12.6MB of memory but 200MB or 400MB instead.  Not sure if W\_G = 4104 is chosen to be compatible with some RISC-V related considerations?</div>
<div class='msg'><time>2025‑03‑19 19:25</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: W_G=4104 for 4k pages for eg CoreVM. Bigger page sizes are not great, as it means way more read/write amplification in the worst case. 4k is already really too big for a number of use cases, we just can&#x27;t really go smaller as 4k is the min page size on modern HW</div>
<div class='msg'><time>2025‑03‑19 19:28</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: Please note that the 12 bytes is _per segment shard requested_. You should absolutely be batching these requests so that in the ideal case you make ~340 network requests for all of the segment shards you need for a WP. This is still a lot of requests of course. In the full network protocol we may add a fast path for requesting the original data directly from guarantors.</div>
<div class='msg'><time>2025‑03‑19 19:32</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: 12MB is a limit on the number of pages read/written _per WP_. It is _not_ the limit on the CoreVM memory. This can&#x27;t really be made larger as it is constrained by bandwidth. Remember that all this data needs to be read/written from/to the DA system for every core every slot</div>
<div class='msg'><time>2025‑03‑19 19:53</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: Understood about the batching of `segmentIndex` in JAMNP taking us from 12 bytes to some multiple of that.   My mental model is that the majority of segments will come from one primary work package and occasionally a few segments come in from another few &quot;foreign&quot; wps but I understand that&#x27;s just one use case, where my mental model is formed by what I imagine a lazy CoreVM programmer would do (if you tell him its like normal programs).   

By &quot;read/write amplification&quot; I believe you mean the idea that we load up all these pages (yes, in a single WP) from Segments DA and only a tiny % of the pages are updated and only a tiny fraction of each page at that, right?  So it looks like a tradeoff between that and the number of networking calls, even with batched `segmentIndex`.   Thanks for explaining!</div>
<div class='msg reply'><time>2025‑03‑20 10:10</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: By read/write amplification I mean even if you want to read or write just 1 byte you still have to import/export an entire page/segment; you end up reading/writing 4000 times as much. Of course that is the worst case, usually it will not be quite as bad</div>
<div class='msg'><time>2025‑03‑19 20:50</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * How did you end up with W\_M = 2048 (The maximum number of imports and exports in a work-package.) which implies at most 32 proof pages and 8.4MB of CoreVM memory -- is this due to bandwidth or networking considerations?    With 4104 bytes usable per proof page, you can fit many many more import/export segments than 2048.   If we solved the 14.10/14.14 &quot;puzzle&quot;, we have only 64\*32+5*32 byte = 2208 bytes out the 4104 bytes being used.  You can definitely fit many many more segments with the unused proof page space of 4104-2240=1900 bytes</div>
<div class='msg'><time>2025‑03‑19 20:51</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * Did you get &quot;full&quot; erasure coding decoding in the JAM Toaster yet (or some serious fraction of it) --  I&#x27;ve been bothered by doing all this networking just to get a measly 12 bytes  and was wondering if instead of W\_G=4104 pages we&#x27;d like something slightly bigger than 64K or 128K instead (thus getting 16x-32x as much).   Then the 2048 could gets 16 or 32x times as much memory but of course 16x - 32x as much bandwidth usage.  The idea would be that you can get your CoreVM loaded with fewer segments and network calls, but maybe someone will want a CoreVM to have not 8.4MB of memory but 134MB or 268MB instead.  Not sure if W\_G = 4104 is chosen to be compatible with some RISC-V related considerations?</div>
<div class='msg'><time>2025‑03‑19 20:53</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * How did you end up with W\_M = 2048 (The maximum number of imports and exports in a work-package.) which implies at most 32 proof pages and 8.4MB of CoreVM memory -- is this due to bandwidth or networking considerations?    With 4104 bytes usable per proof page, you can fit many many more import/export segments than 2048.   If we solved the 14.10/14.14 &quot;puzzle&quot;, we have only 64\*32+5\*32 byte = 2208 bytes out the 4104 bytes being used.  You can definitely fit many many more segments with the unused proof page space of 4104-2208=1896 bytes</div>
<div class='msg'><time>2025‑03‑19 20:56</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * How did you end up with W\_M = 2048 (The maximum number of imports and exports in a work-package.) [or 3072 in recent versions] which implies at most 32 proof pages and 8.4MB of CoreVM memory -- is this due to bandwidth or networking considerations?    With 4104 bytes usable per proof page, you can fit many many more import/export segments than 2048.   If we solved the 14.10/14.14 &quot;puzzle&quot;, we have only 64\*32+5\*32 byte = 2208 bytes out the 4104 bytes being used.  You can definitely fit many many more segments with the unused proof page space of 4104-2208=1896 bytes</div>
<div class='msg'><time>2025‑03‑19 20:56</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * How did you end up with W\_M = 2048 (The maximum number of imports and exports in a work-package.) \[or 3072 in recent versions\] which implies at most 32 proof pages and 8.4MB of CoreVM memory -- is this due to bandwidth or networking considerations?    With 4104 bytes usable per proof page, you can fit many many more import/export segments than 2048.   If we solved the 14.10/14.14 &quot;puzzle&quot;, we have only 64\*32+5\*32 byte = 2208 bytes out the 4104 bytes being used [or 2240 in recent versions].  You can definitely fit many many more segments with the unused proof page space of 4104-2208=1896 bytes</div>
<div class='msg'><time>2025‑03‑20 03:43</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: What is the expected strategy to have the CoreVM service identify which pages in the child VM have been written to (say, marked with a &quot;dirty&quot; bit) so that those pages (and only those pages) are exported to Segment DA by the parent VM?    </div>
<div class='msg'><time>2025‑03‑20 08:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes, CoreVM supports this.</div>
<div class='msg'><time>2025‑03‑20 08:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Yes, CoreVM will support this via the inner PVM.</div>
<div class='msg'><time>2025‑03‑20 08:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Yes, CoreVM will support this via the inner PVM API.</div>
<div class='msg'><time>2025‑03‑20 08:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Yes, CoreVM will support this via the inner PVM host API.</div>
<div class='msg'><time>2025‑03‑20 08:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Yes, CoreVM will support this via the inner PVM host API. We don&#x27;t yet have that host call API in place but I believe it&#x27;s on Jan Bujak &#x27;s TODO list.</div>
<div class='msg'><time>2025‑03‑20 08:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: One additional thing to note for segment reconstruction is that actually fetching each 12 byte piece from a unique set of 342 nodes and reconstructing is the very worst case. There are four better cases: that some or all of the segments are provided to the guarantors by the builder (because it could be the same builder or builder-network whose package created them in the first place). In this case they could have the proof-pages or just be content indexed and passed as extrinsics. Or the guarantor could already have the pages in their own cache because it was they who guaranteed the exporting package. Or the guarantor could fetch them from the exporting guarantor as whole segments. Or that the guarantor batches them because they were exported by the same package as other segments which are also needed for import. And in the worst case, the system wouldn&#x27;t *break*; it would just mean that packages which exposed this worst-case behaviour would take potentially a little to make their way through the pipeline.</div>
<div class='msg'><time>2025‑03‑20 08:57</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * One additional thing to note for segment reconstruction is that actually fetching each 12 byte piece from a unique set of 342 nodes and reconstructing is the very worst case. There are four better cases: that some or all of the segments are provided to the guarantors by the builder (because it could be the same builder or builder-network whose package created them in the first place). In this case they could have the proof-pages or just be content indexed and passed as extrinsics. Or the guarantor could already have the pages in their own cache because it was they who guaranteed the exporting package. Or the guarantor could fetch them from the exporting guarantor as whole segments. Or that the guarantor batches them because they were exported by the same package as other segments which are also needed for import. And in the worst case, the system wouldn&#x27;t _break_; it would just mean that packages which exposed this worst-case behaviour would take potentially a little longer to make their way through the pipeline.</div>
<div class='msg'><time>2025‑03‑20 10:26</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: The encoding for newly created Work Result fields (C.23) do not specify integer sizes for xu, xi, xx, xz, xe. Are they all 1 byte values? </div>
<div class='msg'><time>2025‑03‑20 16:32</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: I have a couple of questions/remarks about accumulation. Specifically how jam should handle dependencies when accumulating a service. Let&#x27;s consider the following scenario:
  - WorkReport A contains 2 results: service 1 and service 2
  - WorkReport B has a dependency on A `((WB)_x)_p = ((WA)_s)_h` and contains one result of service 3.

So `W!` contains [1, 2], lets assume `WQ` is empty... But `W*` contains also 3 so ` W* = [1, 2, 3]`.

Now `∆∗` which is called &quot;parallelized accumulation&quot;, is being called with W* on 12.21 https://graypaper.fluffylabs.dev/#/68eaa1f/17b50317c103?v=0.6.4 .

question 1: But since there is no ordering enforced (that i can see) when executing `∆∗`, then 3 might be executed before it&#x27;s dependencies. 

question 2: lets say i am wrong in the previous question. Lets say Service 1 writes in it&#x27;s storage a key that Service 3 needs to read from (via hostcall read). service 3 won&#x27;t receive the updated storage when `∆1` gets called with s=3 

I guess both questions/remarks are wrong and that Service3 needs to be indeed gets executed after 1,2 (which can be parallelized) and that it should be accumulated using the updated service accounts from the 1,2 accumulation. but i can&#x27;t see where this is enforced in the GP.</div>
<div class='msg'><time>2025‑03‑20 16:34</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: * I have a couple of questions/remarks about accumulation. Specifically how jam should handle dependencies when accumulating a service. Let&#x27;s consider the following scenario:

- WorkReport A contains 2 results: service 1 and service 2
- WorkReport B has a dependency on A `((WB)_x)_p = ((WA)_s)_h` and contains one result of service 3.

So `W!` contains \[1, 2\], lets assume `WQ` is empty... But `W*` contains also 3 so ` W* = [1, 2, 3]`.

Now `∆∗` which is called &quot;parallelized accumulation&quot;, is being called with W\* on 12.21 https://graypaper.fluffylabs.dev/#/68eaa1f/17b50317c103?v=0.6.4 .

question 1: But since there is no ordering enforced (that i can see) when executing `∆∗`, then 3 might be executed before it&#x27;s dependencies.

question 2: lets say i am wrong in the previous question. Lets say Service 1 writes in it&#x27;s storage a key that Service 3 needs to read from (via hostcall read). service 3 does not seem to receive the updated storage when `∆1` gets called with s=3

I guess both questions/remarks are wrong and that Service3 needs to be indeed gets executed after 1,2 (which can be parallelized) and that it should be accumulated using the updated service accounts from the 1,2 accumulation. but i can&#x27;t see where this is enforced in the GP.</div>
<div class='msg'><time>2025‑03‑20 17:08</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Indeed, as Gav said, we will most likely add a way for the parent VM to fetch this information in an efficient manner. It&#x27;s on my TODO list; we just don&#x27;t want to spec it before implementing it to make sure the performance is good.</div>
<div class='msg'><time>2025‑03‑20 17:09</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: * I have a couple of questions/remarks about accumulation. Specifically how jam should handle dependencies when accumulating a service. Let&#x27;s consider the following scenario:

- WorkReport A contains 2 results: service 1 and service 2
- WorkReport B has a dependency on A `((WB)_x)_p = ((WA)_s)_h` and contains one result of service 3.

So `W!` contains \[1, 2\], lets assume `WQ` is empty... But `W*` contains also 3 so ` W* = [1, 2, 3]`.

Now `∆∗` which is called &quot;parallelized accumulation&quot;, is being called with W\* on 12.21 (after ∆+) https://graypaper.fluffylabs.dev/#/68eaa1f/17b50317c103?v=0.6.4 .

question 1: But since there is no ordering enforced (that i can see) when executing `∆∗`, then 3 might be executed before it&#x27;s dependencies.

question 2: lets say i am wrong in the previous question. Lets say Service 1 writes in it&#x27;s storage a key that Service 3 needs to read from (via hostcall read). service 3 does not seem to receive the updated storage when `∆1` gets called with s=3

I guess both questions/remarks are wrong and that Service3 needs to be indeed gets executed after 1,2 (which can be parallelized) and that it should be accumulated using the updated service accounts from the 1,2 accumulation. but i can&#x27;t see where this is enforced in the GP.</div>
<div class='msg'><time>2025‑03‑20 18:34</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: That&#x27;s totally great.  A `page-manifest`  host function call of both (A) what pages MUST be exported because it was written to (a &quot;dirty bit&quot; per page) and (B) what page MUST be imported because it was read from (a &quot;accessed&quot; bit per page) appears necessary for programmers to not have to think much about how their child &quot;guest program&quot; uses memory and the parent CoreVM service will need this manifest to poke and peek pages so the programmer doesn&#x27;t have to. 

But since guest programs will vary widely in terms of how many &quot;accessed&quot; and &quot;dirty&quot; bits they get before they hit some refine gas limit OR the W_M=3072 (12MB) limit on imported+exported segments which applies across ALL the VMs, parent and child.   It seems the builder should be able to run with the whole 2^32 VMs always fully loaded and then use this bookkeeper&#x27;s to dump work packages out right before it runs out of gas, to break up long running computations into work packages.   We would thus want &quot;builder&quot; mode refining (having tens of thousands maybe the 1MM page) and &quot;guarantor&quot; model refining (W_M) working on just the subset the builder wants.  Is that the way to think about designing this host function?</div>
<div class='msg'><time>2025‑03‑20 18:35</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * That&#x27;s totally great.  A `page-manifest`  host function call of both (A) what pages MUST be exported because it was written to (a &quot;dirty bit&quot; per page) and (B) what page MUST be imported because it was read from (a &quot;accessed&quot; bit per page) appears necessary for programmers to not have to think much about how their child &quot;guest program&quot; uses memory and the parent CoreVM service will need this manifest to poke and peek pages so the programmer doesn&#x27;t have to.

But since guest programs will vary widely in terms of how many &quot;accessed&quot; and &quot;dirty&quot; bits they get before they hit some refine gas limit OR the W\_M=3072 (12MB) limit on imported+exported segments which applies across ALL the VMs, parent and child, it seems the builder should be able to run with the whole 2^32 VMs always fully loaded ... and *then* use this bookkeeper to dump work packages out right before it runs out of gas or hit the W_M, to effectively break up long running computations into work packages that the guarantors can legit handle in accordance with JAM spec.   We would thus want &quot;builder&quot; mode refining (having tens of thousands maybe the 1MM page) and &quot;guarantor&quot; model refining (W\_M) working on just the subset the builder wants.  Is that the way to think about designing this host function?  How do performance considerations figure in?</div>
<div class='msg'><time>2025‑03‑20 18:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: They&#x27;re all variable.</div>
<div class='msg'><time>2025‑03‑20 18:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * They&#x27;re all variable. See C.6</div>
<div class='msg'><time>2025‑03‑20 18:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 1. WIs for services 1, 2 and 3 would be executed in the same batch. From the perspective of each they would be executed under the same prior state. If #3 inspected the state of #2 it would see its prior state; if #2 inspected #3, it would also see #3&#x27;s prior state.
2. No. #3 would not see the storage change.</div>
<div class='msg'><time>2025‑03‑20 18:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * 1. WIs for services 1, 2 and 3 would be executed in the same batch. From the perspective of each they would be executed under the same prior state. If #3 inspected the state of #2 it would see its prior state; if #2 inspected #3, it would also see #3&#x27;s prior state.
2. No. #3 would not (necessarily) see the storage change.</div>
<div class='msg'><time>2025‑03‑20 18:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The thing to understand is that JAM services are very much designed to be only asynchronously interactive, at least at the accumulation stage.</div>
<div class='msg'><time>2025‑03‑20 18:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The prerequisite functionality is there to ensure that a package doesn&#x27;t get accumulated before another package is known to be accumulatable.</div>
<div class='msg'><time>2025‑03‑20 18:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It is not there to force a total ordering on its constituent work items.</div>
<div class='msg'><time>2025‑03‑20 18:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: This would create a potentially troublesome pattern and may over-extend the queue system.</div>
<div class='msg'><time>2025‑03‑20 18:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: A total ordering is possible within a single service.</div>
<div class='msg'><time>2025‑03‑20 18:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * A total ordering is possible within a single service; by creating dependent packages, you can be certain that certain WIs will not be accumulated in batches before others. You may end up with a dependency in the same batch, but then that&#x27;s up to the service code to apply the appropriate ordering.</div>
<div class='msg'><time>2025‑03‑20 18:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: If you&#x27;re looking to synchronise between services, then you&#x27;ll need to use `transfer`s..</div>
<div class='msg'><time>2025‑03‑20 18:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * If you&#x27;re looking to synchronise between services, then you&#x27;ll need to use `transfer`s.</div>
<div class='msg'><time>2025‑03‑20 18:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Transfers can be combined with co-scheduling at the Refine stage (e.g. sharing the same WP) and it becomes possible to create causal entanglement between the WIs of multiple services which can be enforced at the accumulation stage.</div>
<div class='msg'><time>2025‑03‑20 18:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Transfers can be combined with co-scheduling at the Refine stage (e.g. sharing the same WP) and it becomes possible to create causal entanglement between the WIs of multiple services which can be enforced at the accumulation stage, so the entangled effects only get integrated into state when both sides are known to be completable.</div>
<div class='msg'><time>2025‑03‑20 18:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * It is not there to force a total ordering over its constituent work items; and certainly not over multiple services.</div>
<div class='msg'><time>2025‑03‑20 18:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * This would create a potentially troublesome pattern and may over-extend the queue system and reduce potential parallelisability for accumulate.</div>
<div class='msg'><time>2025‑03‑20 18:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Accumulation is designed with a view to becoming parallelisable. At some later revision of JAM we may e.g. increase the number of cores to 682 with a requirement that a single service cannot regularly have more accumulation gas than is possible with 341 of them. We can&#x27;t squeeze more gas into the synchronous pipeline, so this would be made viable through CPU parallelism executing multiple service&#x27;s simultaneously.</div>
<div class='msg'><time>2025‑03‑20 18:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: This model breaks more as work-items between services become orderable and synchronous dependencies - chains of execution - start to become the norm.</div>
<div class='msg'><time>2025‑03‑20 18:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: So it&#x27;s something I&#x27;m really trying to avoid with this design.</div>
<div class='msg'><time>2025‑03‑20 18:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: In short synchronous dependencies are evil and the death of scalability. We want to keep them off-chain.</div>
<div class='msg'><time>2025‑03‑20 18:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * In short, cross-service execution dependencies force synchroneity are evil and the death of scalability. We want to keep them off-chain.</div>
<div class='msg'><time>2025‑03‑20 18:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * In short, cross-service execution dependencies force synchroneity and are evil and the death of scalability. We want to keep them off-chain.</div>
<div class='msg'><time>2025‑03‑20 19:03</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: perfect gavin. Thanks for this indepth explanation. it was very much needed for me... I was trying to make both the &quot;dependency system&quot;/prerequisite and parallelism work together. 

</div>
<div class='msg'><time>2025‑03‑21 14:34</time>&ensp;<span class='u' style='color:#994dd2'>tvvkk7</span>: Hello, I&#x27;m implementing PVM invocations, but I&#x27;m curious about how we get the actual service code, or in other words the standard program codes. 
Take [on-transfer invocation](https://graypaper.fluffylabs.dev/#/68eaa1f/2fc8002fca00?v=0.6.4) for example, we input service codeHash into argument invocations. But, service codeHash is a 32-octet value. How do we get the program codes through service codeHash ? </div>
<div class='msg'><time>2025‑03‑21 14:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There’s a function, big Lambda. This should define how to derive the hash preimage. </div>
<div class='msg'><time>2025‑03‑21 14:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It’s all well defined. </div>
<div class='msg'><time>2025‑03‑21 14:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: You’ll need to utilise the preimage lookup map. </div>
<div class='msg'><time>2025‑03‑21 14:57</time>&ensp;<span class='u' style='color:#994dd2'>tvvkk7</span>: Much appreciated </div>
<div class='msg'><time>2025‑03‑21 22:19</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Hi guys, small questions:  
- Is ε(tₐ, tᵦ, tₜ, tᵧ, tₘ, tₒ, tᵢ) used in the definition of the host call function info Ωᵢ the same encoding as **𝐚 ∼ 𝓔₈(𝐚ᵦ, 𝐚ᵧ, 𝐚ₘ, 𝐚ₒ) ∼ 𝓔₄(𝐚ᵢ)**?
- Perhaps there&#x27;s something I don&#x27;t see, but in equation A.43 we define **u = ρ − max(ρ′, 0)**.  
  If ρ′ is negative, then **u = ρ**, which means the gas doesn&#x27;t change.  
  So the service would have run code, but the gas stays the same — is that correct?  
  If so, is that the intended behavior?</div>
<div class='msg reply'><time>2025‑03‑22 04:56</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: may I ask if this is part of the PVM tests or the stf of accumulation? I see everybody is talking about this however we haven&#x27;t meet this yet 😅</div>
<div class='msg reply'><time>2025‑03‑22 09:01</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Capture d’écran du 2025-03-22 10-28-25.png</div>
<div class='msg reply'><time>2025‑03‑22 09:01</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Capture d’écran du 2025-03-22 10-29-08.png</div>
<div class='msg reply'><time>2025‑03‑22 09:02</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Sorry actually you were asking about the first question or the second question ?</div>
<div class='msg reply'><time>2025‑03‑22 09:06</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: sry I&#x27;m just curious about the host call part, I&#x27;m now updating our PVM tests while I don&#x27;t see tests with host calls, so I assume it belongs to the accumulation stf?</div>
<div class='msg'><time>2025‑03‑22 04:56</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * may I ask if this is part of the PVM tests or the stf of accumulation? I see everybody is talking about this however we haven&#x27;t met this yet 😅</div>
<div class='msg'><time>2025‑03‑22 04:57</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * may I ask if this is part of the new PVM tests or the stf of accumulation? I see everybody is talking about this however we haven&#x27;t met this yet 😅</div>
<div class='msg'><time>2025‑03‑22 05:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@celadari:matrix.org&gt; Hi guys, small questions:  
&gt; - Is ε(tₐ, tᵦ, tₜ, tᵧ, tₘ, tₒ, tᵢ) used in the definition of the host call function info Ωᵢ the same encoding as **𝐚 ∼ 𝓔₈(𝐚ᵦ, 𝐚ᵧ, 𝐚ₘ, 𝐚ₒ) ∼ 𝓔₄(𝐚ᵢ)**?
&gt; - Perhaps there&#x27;s something I don&#x27;t see, but in equation A.43 we define **u = ρ − max(ρ′, 0)**.  
&gt;   If ρ′ is negative, then **u = ρ**, which means the gas doesn&#x27;t change.  
&gt;   So the service would have run code, but the gas stays the same — is that correct?  
&gt;   If so, is that the intended behavior?

On the second point, no. u is gas used. By ensuring the second term (gas counter) is never negative we just ensure that the gas used is never greater than the gas limit. </div>
<div class='msg reply'><time>2025‑03‑22 07:40</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Oh thank you, I hadn&#x27;t inderstood that u was used gas, makes sense</div>
<div class='msg'><time>2025‑03‑22 05:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: On the first point, no. The former encoding uses the variable size numeric encodings. </div>
<div class='msg reply'><time>2025‑03‑22 08:31</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: I see =&gt; thanks : )</div>
<div class='msg'><time>2025‑03‑22 11:21</time>&ensp;<span class='u' style='color:#bc5896'>greywolve</span>: Is the explicit encoding of the [tuple in 5.6](https://graypaper.fluffylabs.dev/#/68eaa1f/0ce0000cf200?v=0.6.4) redundant since that&#x27;s going to just remain an octet sequence after the outer encoding?  Or is there something special I&#x27;m missing?</div>
<div class='msg'><time>2025‑03‑22 11:24</time>&ensp;<span class='u' style='color:#bc5896'>greywolve</span>: * Is the explicit encoding of the [tuple in 5.6](https://graypaper.fluffylabs.dev/#/68eaa1f/0ce0000cf200?v=0.6.4) redundant since that&#x27;s going to just remain an octet sequence after the outer encoding?  Or is there something special I&#x27;m missing? (i.e is it pretty much the same as the regular serialization in the appendix only the work report replaced with the hashed work report instead)</div>
<div class='msg'><time>2025‑03‑22 11:36</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Question regarding this:

i&#x27;&#x27; was removed in the definition of Psi_H in version 6.4 of the GP so my question   =&gt;  ¿ do we advance the counter after ecalli instruction or not when we exit ecalli for the host call ?

Looking at this line looks like we don&#x27;t advance it https://graypaper.fluffylabs.dev/#/68eaa1f/246700247200?v=0.6.4

but then it conflicts with idea of using i&#x27; (not using i&#x27;&#x27;) during Psi_H call (https://graypaper.fluffylabs.dev/#/68eaa1f/2b9d012b9d01?v=0.6.4) where it would mean that i&#x27; is advanced after ecalli instruction for the host call ?

Thanks in advance for the clarification 🙏</div>
<div class='msg reply'><time>2025‑03‑22 11:38</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: PS: I tag Ivan Subotic  so he gets notified as well</div>
<div class='msg'><time>2025‑03‑22 11:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@greywolve:matrix.org&gt; Is the explicit encoding of the [tuple in 5.6](https://graypaper.fluffylabs.dev/#/68eaa1f/0ce0000cf200?v=0.6.4) redundant since that&#x27;s going to just remain an octet sequence after the outer encoding?  Or is there something special I&#x27;m missing? (i.e is it pretty much the same as the regular serialization in the appendix only the work report replaced with the hashed work report instead)

It is done this way to avoid having to send all guarantees with the header. Merkle proofs can be provided for those which are sent on other channels. </div>
<div class='msg'><time>2025‑03‑22 11:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@celadari:matrix.org&gt; Question regarding this:
&gt; 
&gt; i&#x27;&#x27; was removed in the definition of Psi_H in version 6.4 of the GP so my question   =&gt;  ¿ do we advance the counter after ecalli instruction or not when we exit ecalli for the host call ?
&gt; 
&gt; Looking at this line looks like we don&#x27;t advance it https://graypaper.fluffylabs.dev/#/68eaa1f/246700247200?v=0.6.4
&gt; 
&gt; but then it conflicts with idea of using i&#x27; (not using i&#x27;&#x27;) during Psi_H call (https://graypaper.fluffylabs.dev/#/68eaa1f/2b9d012b9d01?v=0.6.4) where it would mean that i&#x27; is advanced after ecalli instruction for the host call ?
&gt; 
&gt; Thanks in advance for the clarification 🙏

ecalli is no different to other instructions regarding i’: i’ still represents the instruction immediately following and as per the definition of PsiH, we advance to it once the host call is resolved. </div>
<div class='msg'><time>2025‑03‑22 13:10</time>&ensp;<span class='u' style='color:#bcd429'>subotic</span>: Ahh, now I understand it. The program counter always advances as per (A.7) and additionally in the case of `ecalli`,  `epsilon is h x v_x` instead of `play`. Thanks!</div>
<div class='msg'><time>2025‑03‑24 09:56</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: gav: ﻿what is the rationale of having core and service statistics into the protocol? While validators&#x27; statistics are useful as explained in the GP, there are no information of the usefulness of core and service statistics, and I&#x27;m unable to figure it out by myself</div>
<div class='msg'><time>2025‑03‑24 10:10</time>&ensp;<span class='u' style='color:#bf4233'>emilkietzman</span>: Secondary markets of Agile Coretime like RegionX or Lastic - You could check Core utilizations in different projects and sell unused Coretime</div>
<div class='msg'><time>2025‑03‑24 11:16</time>&ensp;<span class='u' style='color:#cdc232'>oliver.tale-yazdi</span>: It was mentioned in the OpenDev call https://www.youtube.com/live/5kpgs7eb95M?si=AQu819sfQUwxgCRP&amp;t=395</div>
<div class='msg'><time>2025‑03‑24 11:21</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: I missed that, I&#x27;ll watch it. Thank you</div>
<div class='msg'><time>2025‑03‑24 23:32</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Question regarding host call functions Omeja_J(n=reject)

- if we apply it to an account `a` of index `s` =&gt; it is supposed to eliminate from the database only the components `a_c`, `a_b`,` a_g`, `a_m`, `a_o`, `a_i` (represented by C(255, s) in the trie) or `a_l`, `a_p`, `a_s` as well ? </div>
<div class='msg'><time>2025‑03‑25 14:55</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: Is the ordering of preimages fully defined in the GP? 12.35 specifies that the preimages extrinsic should be ordered by the (account, preimage) tuples, but doesn&#x27;t go into further detail. Looking at the tuple &amp; sequence notation sections in section 3, there&#x27;s not a default tuple ordering defined there either. 

 https://graypaper.fluffylabs.dev/#/68eaa1f/181001181001?v=0.6.4</div>
<div class='msg'><time>2025‑03‑25 14:56</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * Is the ordering of the preimages extrinsic fully defined in the GP? 12.35 specifies that the preimages extrinsic should be ordered by the (account, preimage) tuples, but doesn&#x27;t go into further detail. Looking at the tuple &amp; sequence notation sections in section 3, there&#x27;s not a default tuple ordering defined there either. 

 https://graypaper.fluffylabs.dev/#/68eaa1f/181001181001?v=0.6.4</div>
<div class='msg'><time>2025‑03‑25 15:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Tuples are ordered as is obvious. </div>
<div class='msg'><time>2025‑03‑25 15:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Tuples are ordered in the usual, obvious way. </div>
<div class='msg'><time>2025‑03‑25 15:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Eg (1,1), (1,2), (2,1), (2,2)</div>
<div class='msg'><time>2025‑03‑25 15:09</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: got it, thx for clarifying</div>
<div class='msg'><time>2025‑03‑25 16:31</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: With v0.5&#x27;s PVM 64-bit change (and a irreversible commitment to not supporting 32-bit PVM), it is reasonable to adjust https://graypaper.fluffylabs.dev/#/68eaa1f/2c15002c1500?v=0.6.4 to have a memory address space beyond 4GB?   If not, what are the technical reasons for continuing with this 32-bit layout?  

I believe we should extend it to include &quot;accessed&quot; (i) and &quot;dirty&quot; (e) bits so as to map into import and export host calls, and get a convention on how corevm services use the 4104-4096=8 bytes to keep the page number and these metadata bits -- are there others?</div>
<div class='msg'><time>2025‑03‑25 16:52</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * With v0.5&#x27;s PVM 64-bit change (and a irreversible commitment to not supporting 32-bit PVM), it is reasonable to adjust https://graypaper.fluffylabs.dev/#/68eaa1f/2c15002c1500?v=0.6.4 to have a memory address space beyond 4GB?   If not, what are the technical reasons for continuing with this 32-bit layout?  

I believe we should extend it to include &quot;accessed&quot; (i) and &quot;dirty&quot; (e) bits so as to map into import and export host calls, and get a convention on how corevm services use the 4104-4096=8 bytes to keep the page number and these additional metadata bits -- are there additional metadata bits candidates per segment under consideration?</div>
<div class='msg'><time>2025‑03‑25 16:53</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * With v0.5&#x27;s PVM 64-bit change (and a irreversible commitment to not supporting 32-bit PVM), it is reasonable to adjust https://graypaper.fluffylabs.dev/#/68eaa1f/2c15002c1500?v=0.6.4 to have a memory address space beyond 4GB?   If not, what are the technical reasons for continuing with this 32-bit layout?  

I believe we should extend it to include &quot;accessed&quot; (i) and &quot;dirty&quot; (e) bits so as to map into import and export host calls, and get a convention on how corevm services use the 4104-4096=8 bytes to keep the page number and these additional metadata bits -- are there additional metadata bits candidates per segment we should consider when designing CoreVM + Coreplay services?  </div>
<div class='msg'><time>2025‑03‑25 16:54</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * With v0.5&#x27;s PVM 64-bit change (and a irreversible commitment to not supporting 32-bit PVM), it is reasonable to adjust https://graypaper.fluffylabs.dev/#/68eaa1f/2c15002c1500?v=0.6.4 to have a memory address space beyond 4GB?   If not, what are the technical reasons for continuing with this 32-bit layout?  

I believe we should extend it to include &quot;accessed&quot; (i) and &quot;dirty&quot; (e) bits so as to map into import and export host calls, and get a convention on how corevm services use the 4104-4096=8 bytes to keep the page number and these additional metadata bits.  I understand JAM protocol may not wish to impose constraints on what these additional 8 bytes, but a nevertheless pregnant question regardless is: are there additional metadata bits candidates per segment we should consider when designing CoreVM + Coreplay services?  </div>
<div class='msg'><time>2025‑03‑25 17:10</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * With v0.5&#x27;s PVM 64-bit change (and a irreversible commitment to not supporting 32-bit PVM), it is reasonable to adjust https://graypaper.fluffylabs.dev/#/68eaa1f/2c15002c1500?v=0.6.4 to have a memory address space beyond 4GB?   If not, what are the technical reasons for continuing with this 32-bit layout?  

I believe we should extend it to include &quot;accessed&quot; (i) and &quot;dirty&quot; (e) bits so as to map into import and export host calls, and get a convention on how corevm services use the 4104-4096=8 bytes to keep the page number and these additional metadata bits.  I understand JAM protocol may not wish to impose constraints on what these additional 8 bytes contain (though I believe it makes sense to have these i+e bits to support OSes to run on JAM), but a nevertheless pregnant question regardless is: are there additional metadata bits candidates per segment we should consider when designing CoreVM + Coreplay services?  </div>
<div class='msg'><time>2025‑03‑25 20:31</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * With v0.5&#x27;s PVM 64-bit change (and a irreversible commitment to not supporting 32-bit PVM), it is reasonable to adjust https://graypaper.fluffylabs.dev/#/68eaa1f/2c15002c1500?v=0.6.4 to have a memory address space beyond 4GB?   If not, what are the technical reasons for continuing with this 32-bit layout?  

I believe we should extend the &quot;A&quot; [here](https://graypaper.fluffylabs.dev/#/68eaa1f/0a7e010a7e01?v=0.6.4) to include &quot;accessed&quot; (i) and &quot;dirty&quot; (e) bits so as to map into what pages must be imported and what pages must be exported, thus treating coreVM OSes specially.  Or get at least a convention on how corevm services use the 4104-4096=8 bytes to keep the page number and these additional metadata bits.  I understand JAM protocol may not wish to impose constraints on what these additional 8 bytes contain (though I believe it makes sense to have these i+e bits to support OSes to run on JAM), but a nevertheless pregnant question regardless is: are there additional metadata bits candidates per segment we should consider when designing CoreVM + Coreplay services?  </div>
<div class='msg'><time>2025‑03‑25 20:31</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: No idea what you&#x27;re talking about. Please reframe it in specific terms of Omega_J.</div>
<div class='msg'><time>2025‑03‑25 20:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: We can&#x27;t actually handle 4 GB of allocations. Realistically most programs will mostly execute with only 1MB actually accessible (maybe sometimes with 16MB, but only very rarely with more).</div>
<div class='msg'><time>2025‑03‑25 20:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * We can&#x27;t actually handle 4 GB of allocations in terms of gas. Realistically most programs will mostly execute with only 1MB actually accessible (maybe sometimes with 16MB, but only very rarely with more).</div>
<div class='msg'><time>2025‑03‑25 20:33</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Gas will be scaled depending on how much memory you&#x27;re accessing. It&#x27;ll become impractical many orders of magnitude below 32-bit.</div>
<div class='msg'><time>2025‑03‑25 20:36</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: &gt; If not, what are the technical reasons for continuing with this 32-bit layout?

Speed, as it makes sandboxing cheaper, and as Gav said you won&#x27;t be able to use this much memory in practice anyway, so it&#x27;s pointless to have a 64-bit address space.</div>
<div class='msg'><time>2025‑03‑25 20:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: And, for security (auditing) validators will need to be able to execute several refinements concurrently, probably around 10; we&#x27;ll also need 2 guarantor refinements. If they all used, say, 4 GB of RAM, then validators would need to have 48GB of RAM free before we even start thinking about the state DB and various caches. </div>
<div class='msg'><time>2025‑03‑25 20:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: That would probably push minimum requirements to beyond 64 GB per node, which is too much.</div>
<div class='msg'><time>2025‑03‑25 20:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Any, in any case, there&#x27;s no sensible on-chain use-case which would need 64-bit addressability.</div>
<div class='msg'><time>2025‑03‑25 21:03</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: I read David Emett &#x27;s comment of &quot;12MB is a limit on the number of pages read/written per WP. It is not the limit on the CoreVM memory.&quot; in the following way:
* A CoreVM service user actually really does have a 4GB virtual computer.  However, in any given work package, spanning say a few seconds of computation only	a small number of pages are accessed (imported) or written to (exported).
* Only W_M (3072 as of 0.6.4) pages = 12MB of them is realistic in JAM but it is only  _tiny fraction_ of the larger addressable subset of CoreVM 4GB memory.
* So one work package might access ABC (12MB) the next might access DEF (a different 12MB), the next EFG etc, none of which exceed W_M *individually* but in totality across multiple work packages exceed 12MB.  In this way, you could totally want much more than 4GB.
* When a builder submits a work package to a guarantor, JAM being basically an audit protocol of what happens in up to a W_M (12MB sized) sliver of memory of the larger 4GB computer did.  JAM is optimized for trustless OS services.
In previous decades there was a story of &quot;640K ought to be enough for anybody&quot; and maybe &quot;I think there is a world market for about five computers&quot; -- these days 4-8B people all having 4-8GB phones in their pocket and so perhaps the trustless supercomputing equivalent is &quot;4GB ought to be enough for everyone&quot; and &quot;there is a world market for about 5 trustless supercomputers&quot; =). </div>
<div class='msg'><time>2025‑03‑25 21:04</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * I read David Emett &#x27;s comment of &quot;12MB is a limit on the number of pages read/written per WP. It is not the limit on the CoreVM memory.&quot; in the following way:

- A CoreVM service user actually really does have a 4GB virtual computer.  However, in any given work package, spanning say a few seconds of computation only	a small number of pages are accessed (imported) or written to (exported).
- Only W\_M (3072 as of 0.6.4) pages = 12MB of them is realistic in JAM but it is only  _tiny fraction_ of the larger addressable subset of CoreVM 4GB memory.
- So one work package might access ABC (12MB) the next might access DEF (a different 12MB), the next EFG etc, none of which exceed W\_M _individually_ but in totality across multiple work packages exceed 12MB.  In this way, you could totally want much more than 4GB.
- When a builder submits a work package to a guarantor, JAM being basically an audit protocol of what happens in up to a W\_M (12MB sized) sliver of memory of the larger 4GB computer did.  JAM is optimized for trustless OS services.

In previous decades there was a story of &quot;640K ought to be enough for anybody&quot; and maybe &quot;I think there is a world market for about five computers&quot; -- these days 4-8B people all have 4-8GB phones in their pocket and so perhaps the trustless supercomputing equivalent is &quot;12MB/4GB ought to be enough for everyone&quot; and &quot;there is a world market for about 5 trustless supercomputers&quot; =).</div>
<div class='msg'><time>2025‑03‑25 21:06</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * I read David Emett &#x27;s comment of &quot;12MB is a limit on the number of pages read/written per WP. It is not the limit on the CoreVM memory.&quot; in the following way:

- A CoreVM service user actually really does have a 4GB virtual computer.  However, in any given work package, spanning say a few seconds of computation only	a small number of pages are accessed (imported) or written to (exported).
- Only W\_M (3072 as of 0.6.4) pages = 12MB of them is realistic in JAM but it is only  _tiny fraction_ of the larger addressable subset of the CoreVM service users&#x27;s 4GB virtual computer.
- So one work package might access ABC (12MB) the next might access DEF (a different 12MB), the next EFG etc, none of which exceed W\_M _individually_ but in totality across multiple work packages exceed 12MB.  In this way, you could totally want much more than 4GB.
- When a builder submits a work package to a guarantor, JAM being basically an audit protocol of what happens in up to a W\_M (12MB sized) sliver of memory of the larger 4GB computer did.  JAM is optimized for trustless OS services.

In previous decades there was a story of &quot;640K ought to be enough for anybody&quot; and maybe &quot;I think there is a world market for about five computers&quot; -- these days 4-8B people all have 4-8GB phones in their pocket and so perhaps the trustless supercomputing equivalent is &quot;12MB/4GB ought to be enough for everyone&quot; and &quot;there is a world market for about 5 trustless supercomputers&quot; =).  Could we imagine that all 4-8B people collectively get their Shared World Computer in a 64-bit way so they may all coreplay together, even though any individual work package only references a tiny sliver?</div>
<div class='msg'><time>2025‑03‑25 21:10</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * I read David Emett &#x27;s comment of &quot;12MB is a limit on the number of pages read/written per WP. It is not the limit on the CoreVM memory.&quot; in the following way:

- A CoreVM service user actually really does have a 4GB virtual computer.  However, in any given work package, spanning say a few seconds of computation only	a small number of pages are accessed (imported) or written to (exported).
- Only W\_M (3072 as of 0.6.4) pages = 12MB of this 4GB virtual computer is realistic to set up with JAM&#x27;s PVM but it is only  _tiny fraction_ of the larger addressable subset of the CoreVM service users&#x27;s 4GB virtual computer.
- So one work package might access ABC (12MB) the next might access DEF (a different 12MB), the next EFG etc, none of which exceed W\_M _individually_ but in totality across multiple work packages exceed 12MB.  In this way, you could totally want much more than 4GB.
- When a builder submits a work package to a guarantor, JAM being basically an audit protocol of what happens in up to a W\_M (12MB sized) sliver of memory of the larger 4GB computer did.  JAM is optimized for trustless OS services.

In previous decades there was a story of &quot;640K ought to be enough for anybody&quot; and maybe &quot;I think there is a world market for about five computers&quot; -- these days 4-8B people all have 4-8GB phones in their pocket and so perhaps the trustless supercomputing equivalent is &quot;12MB/4GB ought to be enough for everyone&quot; and &quot;there is a world market for about 5 trustless supercomputers&quot; =).  Could we imagine that all 4-8B people collectively get their Shared World Computer in a 64-bit way so they may all coreplay together, even though any individual work package only references a tiny sliver?</div>
<div class='msg'><time>2025‑03‑25 21:14</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I appreciate the ambition, but the limits are there for a reason.</div>
<div class='msg'><time>2025‑03‑25 21:14</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: We&#x27;ve explained the reasoning. Live with it or come up with a better protocol yourself.</div>
<div class='msg'><time>2025‑03‑25 21:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There&#x27;s the business of dreaming and the business of building. This channel is for the latter.</div>
<div class='msg'><time>2025‑03‑25 21:30</time>&ensp;<span class='u' style='color:#c67452'>sourabhniyogi</span>: * I read David Emett &#x27;s comment of &quot;12MB is a limit on the number of pages read/written per WP. It is not the limit on the CoreVM memory.&quot; in the following way:

- A CoreVM service user actually really does have a 4GB virtual computer.  However, in any given work package, spanning say a few seconds of computation only	a small number of pages are accessed (imported) or written to (exported).
- Only W\_M (3072 as of 0.6.4) pages = 12MB of this 4GB virtual computer is realistic to set up with JAM&#x27;s PVM but it is only  _tiny fraction_ of the larger addressable subset of the CoreVM service users&#x27;s 4GB virtual computer.
- So one work package might access ABC (12MB) the next might access DEF (a different 12MB), the next EFG etc, none of which exceed W\_M _individually_ but in totality across multiple work packages exceed 12MB.  In this way, you could totally want much more than 4GB.
- When a builder submits a work package to a guarantor, JAM being basically an audit protocol of what happens in up to a W\_M (12MB sized) sliver of memory of what the larger 4GB computer did.  JAM is optimized for trustless OS services.

In previous decades there was a story of &quot;640K ought to be enough for anybody&quot; and maybe &quot;I think there is a world market for about five computers&quot; -- these days 4-8B people all have 4-8GB phones in their pocket and so perhaps the trustless supercomputing equivalent is &quot;12MB/4GB ought to be enough for everyone&quot; and &quot;there is a world market for about 5 trustless supercomputers&quot; =).  Could we imagine that all 4-8B people collectively get their Shared World Computer in a 64-bit way so they may all coreplay together, even though any individual work package only references a tiny sliver?</div>
<div class='msg'><time>2025‑03‑25 21:33</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Thanks for pointing out my message wasn’t clear and asking for clarification — I appreciate it 🙂

Speaking in terms of **`Omega_J`**:
– we&#x27;re removing an account `d` (https://graypaper.fluffylabs.dev/#/68eaa1f/32a50332a803?v=0.6.4)

Speaking in terms of the **trie root (Appendix D)**:
By removing this account `d`, the state root trie will eventually need to be updated.

My question is:
– Do we remove only the first component of the account in the trie? (https://graypaper.fluffylabs.dev/#/68eaa1f/382b03383b03?v=0.6.4)
– Or do we remove other components of account (storage, pre_image lookup, ...) as well?
(https://graypaper.fluffylabs.dev/#/68eaa1f/385403386103?v=0.6.4, https://graypaper.fluffylabs.dev/#/68eaa1f/384103384e03?v=0.6.4, https://graypaper.fluffylabs.dev/#/68eaa1f/387603387f03?v=0.6.4)</div>
<div class='msg'><time>2025‑03‑25 21:34</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: * Thanks for pointing out my message wasn’t clear and asking for clarification — I appreciate it 🙂

Speaking in terms of **`Omega_J`**:
– we&#x27;re removing an account `d` (https://graypaper.fluffylabs.dev/#/68eaa1f/32a50332a803?v=0.6.4)

Speaking in terms of the **trie root (Appendix D)**:
By removing this account `d`, the state root trie will need to be updated at some point.

My question is:
– Do we remove only the first component of the account in the trie? (https://graypaper.fluffylabs.dev/#/68eaa1f/382b03383b03?v=0.6.4)
– Or do we remove other components of account (storage, pre\_image lookup, ...) as well?
(https://graypaper.fluffylabs.dev/#/68eaa1f/385403386103?v=0.6.4, https://graypaper.fluffylabs.dev/#/68eaa1f/384103384e03?v=0.6.4, https://graypaper.fluffylabs.dev/#/68eaa1f/387603387f03?v=0.6.4)</div>
<div class='msg'><time>2025‑03‑25 21:35</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: * Thanks for pointing out my message wasn’t clear and asking for clarification — I appreciate it 🙂

Speaking in terms of **`Omega_J`**:
– we&#x27;re removing an account `d` (https://graypaper.fluffylabs.dev/#/68eaa1f/32a50332a803?v=0.6.4)

Speaking in terms of the **trie root (Appendix D)**:
By removing this account `d`, the state root trie will need to be updated at some point.

My question is:
– Do we remove only the first component of the account in the trie? (https://graypaper.fluffylabs.dev/#/68eaa1f/382b03383b03?v=0.6.4)
– Or do we remove other components of the account (storage, pre_image lookup, ...) as well?
(https://graypaper.fluffylabs.dev/#/68eaa1f/385403386103?v=0.6.4, https://graypaper.fluffylabs.dev/#/68eaa1f/384103384e03?v=0.6.4, https://graypaper.fluffylabs.dev/#/68eaa1f/387603387f03?v=0.6.4)</div>
<div class='msg'><time>2025‑03‑25 21:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: You can answer your own question if you simply phrase it in terms of Omega_J.</div>
<div class='msg'><time>2025‑03‑25 21:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Omega_J has the effect of removing a particular item (d) from the accounts dictionary (delta).</div>
<div class='msg reply'><time>2025‑03‑26 15:25</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Thanks again for your time and answer.

Just to give a bit more context on why I was confused:

I hadn’t realized that the condition on 
`𝑑𝑖=2` was actually implying that the **storage**, **preimages**, etc. for that account had to be *already empty* — meaning the account must have gone through a `forget(Omega_F)` and `write(Omega_W)` before being eligible for deletion.

Initially, I thought we were supposed to manually remove these fields by directly deleting down from the partial trie key like
`𝐶(𝑠,𝐸4(2^32−1))`
which would have worked fine for **preImageLookupP** and **storage**, but not for **preImageLookupL** (because of `E(l)`) — and that one had me pulling my hair out 😅</div>
<div class='msg'><time>2025‑03‑25 21:57</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: And if you see the various data concerning accounts which makes up the state trie (from which the trie root may be derived), they&#x27;re all defined through the contents of the accounts dictionary delta.</div>
<div class='msg'><time>2025‑03‑25 21:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Therefore if the dictionary no longer contains a particular account, then state trie items such as the the stored data, preimages, &amp;c which were concerning said account will no longer be in place.</div>
<div class='msg'><time>2025‑03‑26 07:36</time>&ensp;<span class='u' style='color:#994dd2'>tvvkk7</span>: Hello gav , I&#x27;m implementing accumulation invocation. The [initializer function](https://graypaper.fluffylabs.dev/#/68eaa1f/2e36012e4001?v=0.6.4) I requires eta&#x27;_0. Does eta&#x27;_0 be input through [U](https://graypaper.fluffylabs.dev/#/68eaa1f/163702163702?v=0.6.4) ? Although, it is only needed in Psi_A.</div>
<div class='msg'><time>2025‑03‑26 09:21</time>&ensp;<span class='u' style='color:#d25e85'>shawntabrizi</span>: As I recall, compact numbers in JAM are different than they are in SCALE and Polkadot today. Can someone write a small description of the new compact number format? ❤️</div>
<div class='msg reply'><time>2025‑03‑26 09:31</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I give my code to chatgpt and this is the description from it
```
This encoding converts an unsigned integer into a sequence of bytes using just as many bytes as needed. Here’s how it works in simple terms:
	1.	Zero Handling:
If the integer is 0, it simply outputs one byte with the value 0.
	2.	Determining Byte Count:
For nonzero numbers, the encoder figures out how many extra bytes are needed by finding the smallest number l (from 0 to 7) such that the value fits within 7 \times (l+1) bits. If none of these work, it defaults to using 8 bytes in total.
	3.	Control Byte Creation:
The first byte (control byte) combines a prefix that indicates how many extra bytes follow and part of the number itself. The prefix is calculated as:
\text{prefix} = 256 - (1 \ll (8 - l))
The control byte is then formed by adding this prefix to the most significant bits of the number.
	4.	Appending Remaining Bytes:
After the control byte, the remaining bytes (if any) represent the lower parts of the number, each taking an 8-bit chunk.

In summary, the format starts with a control byte that tells you how many additional bytes there are and includes part of the data, followed by the extra bytes that complete the full representation of the integer.
```</div>
<div class='msg'><time>2025‑03‑26 09:22</time>&ensp;<span class='u' style='color:#d25e85'>shawntabrizi</span>: image.png</div>
<div class='msg'><time>2025‑03‑26 09:22</time>&ensp;<span class='u' style='color:#d25e85'>shawntabrizi</span>: is that this?

</div>
<div class='msg'><time>2025‑03‑26 09:22</time>&ensp;<span class='u' style='color:#d25e85'>shawntabrizi</span>: need an ELI5 :)</div>
<div class='msg'><time>2025‑03‑26 09:24</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: One prefix byte plus payload. The prefix byte determines the length through the number of `1`s before the first `0`. The unused bits in the first byte are used for the payload. The first byte always contains the most significant bits. The rest of the bytes are always written in a little endian order. Can encode at most 64-bit numbers.

At most  7bit - 0xxxxxxx
At most 14bit - 10xxxxxx xxxxxxxx
At most 21bit - 110xxxxx xxxxxxxx xxxxxxxx
At most 28bit - 1110xxxx xxxxxxxx xxxxxxxx xxxxxxxx
At most 35bit - 11110xxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
At most 42bit - 111110xx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
At most 49bit - 1111110x xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
At most 56bit - 11111110 xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
At most 64bit - 11111111 xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
</div>
<div class='msg'><time>2025‑03‑26 09:24</time>&ensp;<span class='u' style='color:#5dd07c'>knight1205</span>: is there any specification for work package builders, yet? </div>
<div class='msg'><time>2025‑03‑26 09:30</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: hi there, as for the riscv test https://github.com/spacejamapp/jam-test-vectors/blob/main/pvm/programs/riscv_rv64ua_amoadd_d.json, it doesn&#x27;t have jump table defined, (the program starts with [0, 0]), how do we perform jumps in the bytecode?</div>
<div class='msg'><time>2025‑03‑26 09:31</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * hi there, as for the riscv test https://github.com/spacejamapp/jam-test-vectors/blob/main/pvm/programs/riscv\_rv64ua\_amoadd\_d.json, it doesn&#x27;t have jump table defined, (the program starts with \[0, 0\]), however seems jumps are required for executing the complete logic, but how do we perform jumps in the bytecode since we don&#x27;t have the jump table?</div>
<div class='msg'><time>2025‑03‑26 09:32</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * hi there, as for the riscv test https://github.com/koute/jamtestvectors/blob/master_pvm_initial/pvm/programs/riscv_rv64ua_amoadd_d.json, it doesn&#x27;t have jump table defined, (the program starts with \[0, 0\]), however seems jumps are required for executing the complete logic, but how do we perform jumps in the bytecode since we don&#x27;t have the jump table?</div>
<div class='msg'><time>2025‑03‑26 09:33</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Not sure I understand your question. That program contains only static jumps and it doesn&#x27;t require a jump table.</div>
<div class='msg reply'><time>2025‑03‑26 09:48</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: wait, I can reproduce my case in pvm debugger 

https://pvm.fluffylabs.dev/?program=0x0000808833000000018300ff9700103200330502330700000080330800f83a0a0000017ba782ab3e02000003c88b027ba23a02000003330400000080ab4b4c33050382ac3304ff97441f954400f8ab4c3a33050482ab3e02000003c88b027ba23a020000033304ff97441f954400f8ab4b1933050582ac33040000f88344ff97440cab4c0652050400287bff212941840a2904494924851492480a4932#/

at JUMP_IND, we triggers halt, if so, how do we run the rest of the logic to reach the expected test result? </div>
<div class='msg reply'><time>2025‑03‑26 09:49</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: You don&#x27;t start execution at 0.</div>
<div class='msg reply'><time>2025‑03‑26 09:50</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: oh I got it, missed the `initial_pc`, thanks!</div>
<div class='msg'><time>2025‑03‑26 09:35</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: oh I got you, so there could be problems in my `djump` implementation, I&#x27;m referencing the jump table in all jump instructions</div>
<div class='msg'><time>2025‑03‑26 09:36</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: The only dynamic jump in that program is the jump that goes to the hardcoded special address which halts the program; no other jumps there use the jump table.</div>
<div class='msg'><time>2025‑03‑26 09:37</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Non-dynamic jumps definitely shouldn&#x27;t do anything with the jump table.</div>
<div class='msg'><time>2025‑03‑26 09:37</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: I may need to fix more problems in my code, since I can pass all `test_instr_*` with my current implementation 😂</div>
<div class='msg'><time>2025‑03‑26 09:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Specification, no, and there won&#x27;t be.</div>
<div class='msg'><time>2025‑03‑26 09:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There may be conventions, published APIs and/or SDKs to help create package builders.</div>
<div class='msg'><time>2025‑03‑26 09:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: But, the JAM protocol doesn&#x27;t prescribe any means of building packages any more than it prescribes how you should create your service logic.</div>
<div class='msg'><time>2025‑03‑26 09:44</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * But the JAM protocol doesn&#x27;t prescribe any means of building packages any more than it prescribes how you should create your service logic.</div>
<div class='msg'><time>2025‑03‑26 09:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It terms of data logistics, ideally builders will connect to the JAM network via inbuilt nodes (light or full, depending on the use-case and circumstances) and use internal node APIs to inject new packages. Nodes would then identify the right guarantors and send the package to them.</div>
<div class='msg'><time>2025‑03‑26 09:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: However, in the early days, we&#x27;ll probably see RPCs being used by builder executables to deliver packages to nodes on testnets. It&#x27;s definitely not something I&#x27;d want to see in production, but running &amp; synching a full-node to insert a single work-package is plainly suboptimal and we don&#x27;t have any light-clients yet.</div>
<div class='msg'><time>2025‑03‑26 09:49</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * wait, I can reproduce my case in pvm debugger 

https://pvm.fluffylabs.dev/?program=0x0000808833000000018300ff9700103200330502330700000080330800f83a0a0000017ba782ab3e02000003c88b027ba23a02000003330400000080ab4b4c33050382ac3304ff97441f954400f8ab4c3a33050482ab3e02000003c88b027ba23a020000033304ff97441f954400f8ab4b1933050582ac33040000f88344ff97440cab4c0652050400287bff212941840a2904494924851492480a4932#/

at JUMP\_IND, we trigger halt, if so, how do we run the rest of the logic to reach the expected test result? </div>
<div class='msg'><time>2025‑03‑26 09:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: That&#x27;s not a question the GP (or I) can answer. How you get eta&#x27; into the appropriate place in your code for it to be able to calculate the initial machine state is entirely an implementation details.</div>
<div class='msg reply'><time>2025‑03‑26 11:51</time>&ensp;<span class='u' style='color:#994dd2'>tvvkk7</span>: Many thanks ! I got it!</div>
<div class='msg'><time>2025‑03‑26 09:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * That&#x27;s not a question the GP (or I) can answer. How you get eta&#x27; into the appropriate place in your code for it to be able to calculate the initial machine state is entirely an implementation detail.</div>
<div class='msg'><time>2025‑03‑26 09:50</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: are validators expected to open connections with any builder nodes? obviously limits needs to be enforced on validators side but that can still be a DoS vector?</div>
<div class='msg'><time>2025‑03‑26 09:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: No.</div>
<div class='msg'><time>2025‑03‑26 09:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The builder node set is unconstrained.</div>
<div class='msg'><time>2025‑03‑26 09:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: And even if it were somehow constrained, validators have no idea who they are.</div>
<div class='msg'><time>2025‑03‑26 09:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Whereas validators IDs are well-known to anyone with an up to date JAM state.</div>
<div class='msg'><time>2025‑03‑26 09:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Strategically, validators need to find work-packages they can guarantee in order to make rewards. But they must balance this with the possibility of being attacked.</div>
<div class='msg'><time>2025‑03‑26 09:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Strategically, validators need to find work-packages they can guarantee in order to make rewards. But they must balance this with the possibility of being DoSed/attacked.</div>
<div class='msg'><time>2025‑03‑26 09:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: So there will be some need for implementors to create guarantor strategies which balance these two opposing forces. There&#x27;s not really a right answer here and it&#x27;s the sort of thing which should be discussed at JAM0.</div>
<div class='msg'><time>2025‑03‑26 09:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Realistically I&#x27;d expect validators to have several dozen nodes connected, other than fellow validators.</div>
<div class='msg'><time>2025‑03‑26 09:55</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: I see. something to be figured out. worst case we just have tx pool and some package gossip protocol + peer reputation. ie something like what we have today </div>
<div class='msg'><time>2025‑03‑26 09:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: And to actively churn through nodes, keeping ones who tend to give them good packages.</div>
<div class='msg'><time>2025‑03‑26 09:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Connection could come with a promise to give packages adhering to a set of authorizers. Failure to provide a package on a core with one of those authorizers in the pool could result in booting.</div>
<div class='msg'><time>2025‑03‑26 09:57</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Obviously if bad packages are received, then this would also result in booting.</div>
<div class='msg'><time>2025‑03‑26 10:12</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: so for a builder to be able to consistently deliver work packages, it needs to work with all sorts of services. It certainly need a pool and some way to collect the packages. this is a big chunk of work</div>
<div class='msg'><time>2025‑03‑26 10:15</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Highly unlikely.</div>
<div class='msg'><time>2025‑03‑26 10:15</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Builders will almost certainly be private enterprises and specialised to a particular service or service-type.</div>
<div class='msg'><time>2025‑03‑26 10:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: E.g. for parachains, it could be that every parachain will have its own builder network (aka collator network).</div>
<div class='msg'><time>2025‑03‑26 10:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * E.g. for parachains, it could be that every parachain will have its own builder network (aka collator network). Though with the Omninode, we&#x27;ll probably see generic parachain builder networks.</div>
<div class='msg'><time>2025‑03‑26 10:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: But still, they&#x27;ll only build for the one Parachains service.</div>
<div class='msg'><time>2025‑03‑26 10:17</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It will be up to the builders to convince guarantors on cores which their packages are capable of running that they can furnish them with packages.</div>
<div class='msg'><time>2025‑03‑26 10:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Thankfully this need not be done blindly; IsAuthorized is designed to run independently and cheaply.</div>
<div class='msg'><time>2025‑03‑26 10:19</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: And once IsAuthorized executes successfully, the guarantor knows that the builder can reasonably supply a package worth refining/guaranteeing.</div>
<div class='msg'><time>2025‑03‑26 10:35</time>&ensp;<span class='u' style='color:#5dd07c'>knight1205</span>: so the strategy to build connection and accept work packages will be fixed for each implementation, for consistency, or will there be different strategies? If fixed, will that be provided in JAM-NP?</div>
<div class='msg'><time>2025‑03‑26 10:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: JAM-SNP already contains network messages for provision/sharing of work-packages (and preimages)</div>
<div class='msg'><time>2025‑03‑26 10:37</time>&ensp;<span class='u' style='color:#5dd07c'>knight1205</span>: but that is just protocol for connection setup. will there be any strategy/requirements for acceptance or just we have to validate author hash or work package on our own and then perform computations?</div>
<div class='msg'><time>2025‑03‑26 10:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: As I just wrote:</div>
<div class='msg'><time>2025‑03‑26 10:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; So there will be some need for implementors to create guarantor strategies which balance these two opposing forces. There&#x27;s not really a right answer here and it&#x27;s the sort of thing which should be discussed at JAM0</div>
<div class='msg'><time>2025‑03‑26 10:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (For the purposes of M2 conformance testing we&#x27;ll have idealised connections and implementations will not need to concern themselves with the possibility of DoS.)</div>
<div class='msg'><time>2025‑03‑26 10:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: As per the security audit (M5) implementations will need to demonstrate a resilience against DoS. But of course, over-conservative nodes which sacrifice too many rewards may find that fewer validators are willing to run them.</div>
<div class='msg'><time>2025‑03‑26 10:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * As per the security audit (M5), implementations will need to demonstrate a resilience against DoS. But of course, over-conservative nodes which sacrifice too many rewards may find that fewer validators are willing to run them.</div>
<div class='msg'><time>2025‑03‑26 10:42</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * As per the security audit (M5), implementations will need to demonstrate a resilience against DoS, including attacks by peers. But of course, over-conservative nodes which sacrifice too many rewards may find that fewer validators are willing to run them.</div>
<div class='msg'><time>2025‑03‑26 10:43</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Again, no right answers, and I do expect (and hope for!) some differences between node strategies, but our implementor conferences are meant for brainstorming and sharing insights into such things.</div>
<div class='msg'><time>2025‑03‑26 10:43</time>&ensp;<span class='u' style='color:#5dd07c'>knight1205</span>: alright, got it. thank you very much</div>
<div class='msg'><time>2025‑03‑26 11:01</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: SNP currently allows builders to identify themselves at connection time by adding /builder to the protocol advertised during ALPN, see https://github.com/zdave-parity/jam-np/blob/main/simple.md#alpn. To some extent how validators treat these connections is a strategy thing and it isn&#x27;t necessary for all implementations to behave the same. A reasonable strategy might be to grant a peer connecting with the /builder suffix a special builder connection slot (subject to availability), but require the peer to submit a valid work-package within a few seconds after connecting in order to keep the slot and not lose reputation.</div>
<div class='msg'><time>2025‑03‑26 12:41</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: </div>
<div class='msg'><time>2025‑03‑26 15:25</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: * Thanks again for your time and answer.

Just to give a bit more context on why I was confused:

I hadn’t realized that the condition on
`𝑑𝑖=2` was actually implying that the **storage**, **preimages**, etc. for that account had to be _already empty_ — meaning the account must have gone through a `forget(Omega_F)` and `write(Omega_W)` before being eligible for deletion.

Initially, I thought we were supposed to manually remove these fields by directly deleting down from the partial trie key like
`𝐶(𝑠,𝐸4(2^32−1))`
which would have worked fine for **preImageLookupP** and **storage**, but not for **preImageLookupL** (because of `E(l)`) — and that one had me pulling my hair out 😅

All good now and thanks again :)</div>
<div class='msg'><time>2025‑03‑27 16:51</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: should the pvm invocation definitions make explicit the use of the historical lookup function when representing an accounts code? Currently it looks like S_c is used as if it were intended to be the code preimage itself, rather than the code hash.

https://graypaper.fluffylabs.dev/#/68eaa1f/2fa9002fac00?v=0.6.4</div>
<div class='msg'><time>2025‑03‑27 23:13</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: within the accumulate pvm invocation, is flushing S back to the partial state after read-only host functions intentional? (read, lookup, info). Seems like it should be moot.

https://graypaper.fluffylabs.dev/#/68eaa1f/2ebb022ebb02?v=0.6.4</div>
<div class='msg'><time>2025‑03‑28 08:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: s_{bold c} is the preimage (s_{regular c} is the hash)</div>
<div class='msg'><time>2025‑03‑28 08:39</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * s\_{bold c} is the preimage (s\_{regular c} is the hash) - It is defined in (9.4)</div>
<div class='msg'><time>2025‑03‑28 08:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * s\_{bold c} is the preimage (s\_{regular c} is the hash) - It is defined in (9.4), and doesn&#x27;t rely on the preimage lookup function.</div>
<div class='msg'><time>2025‑03‑28 08:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes it&#x27;s a moot point; I&#x27;m happy to take a PR which simplifies it, though I&#x27;m not sure if that&#x27;s necessarily easy.</div>
<div class='msg'><time>2025‑03‑28 13:34</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: I see it now, thanks!</div>
<div class='msg'><time>2025‑03‑28 14:15</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: https://github.com/gavofyork/graypaper/pull/313</div>
<div class='msg'><time>2025‑03‑30 08:21</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Hi everyone,

I have a question regarding **the program metadata introduced in GP 6.3.**

If an extrinsic `E_P` includes a `pre_image` that do not conform to the expected encoding
`Epsilon(double_arrow Epsilon(a_m), a_c)`
(as specified here: https://graypaper.fluffylabs.dev/#/68eaa1f/106c01107101?v=0.6.4):

Should we:

- Consider the **entire block invalid ?**
OR
- **Accept the block**, and allow the service lookup dictionaries to include these entries, with the understanding that invocations of Psi_A, Psi_R, Psi_I, Psi_T for the service of this pre_image would simply fail ?</div>
<div class='msg'><time>2025‑03‑30 08:23</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: * Hi everyone,
I have a question regarding the program metadata introduced in GP 6.3.
If an extrinsic E_P includes a pre_image that do not conform to the expected encoding
Epsilon(double_arrow Epsilon(a_m), a_c)
(as specified here: https://graypaper.fluffylabs.dev/#/68eaa1f/106c01107101?v=0.6.4):
Should we:
Consider the entire block invalid ?
OR
Accept the block, and allow the service lookup dictionaries to include these entries, with the understanding that invocations of Psi_A, Psi_R, Psi_I, Psi_T for the service of this pre_image would simply fail (by failing I mean that invocations panic thus don&#x27;t change state) ?
</div>
<div class='msg'><time>2025‑03‑30 08:25</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: * Hi everyone,

I have a question regarding the *program metadata introduced in GP* 6.3.

If an extrinsic `E_P` includes a `pre_image` that do not conform to the expected encoding
`Epsilon(double_arrow Epsilon(a_m), a_c)`
(as specified here: https://graypaper.fluffylabs.dev/#/68eaa1f/106c01107101?v=0.6.4):


Should we:
- *Consider the entire block invalid ?*
OR
- *Accept the block*, and allow the service lookup dictionaries to include these entries, with the understanding that invocations of `Psi_A, Psi_R, Psi_I, Psi_T` for the service of this pre_image would simply fail (by failing I mean that invocations panic thus don&#x27;t change state) ?
</div>
<div class='msg'><time>2025‑03‑30 11:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: does not conform to the expected encoding of what?!!</div>
<div class='msg'><time>2025‑03‑30 11:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The preimage is determined solely by data encoded as per the GP specification. </div>
<div class='msg'><time>2025‑03‑30 11:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * does not conform to the expected encoding of what?</div>
<div class='msg'><time>2025‑03‑30 11:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Either it is requested or it is not. If it is not, then the block is invalid. There’s no room for guesswork here. </div>
<div class='msg'><time>2025‑03‑30 14:12</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Let me use an example to explain my question more clearly:

Suppose we receive an incoming block with some extrinsics, among which are `E_P` extrinsics (preimages). Let’s assume one of these preimages is for service `s` and is encoded as a `vertical-double-array p`. From the first byte, we determine the length of `p`, extract the corresponding bytes, and treat that as the preimage.

This preimage `p` is expected to represent an `Epsilon(double_arrow Epsilon(a_m), a_c)` structure (https://graypaper.fluffylabs.dev/#/68eaa1f/106c01107101?v=0.6.4).

Now, say `p = [129, 2, 4, 5, 6]`. Interpreting this:

The metadata slice is supposed to be of length 129, starting right after the first byte.

But the total array doesn&#x27;t even contain 129 elements—so this is clearly an incorrectly encoded preimage.

My question is:
- Should we **reject the entire block** due to this malformed preimage? 
OR
- Should we **accept the block**, include the &quot;bad formed&quot; preimage in the lookup for service `s`, and simply let the `Psi_A` panic at execution time (and thus not updating anything) for this service `s` ?</div>
<div class='msg reply'><time>2025‑03‑30 14:13</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: The reason I ask is because the current codec test vectors for preimages (https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/codec/data/preimages_extrinsic.json) don’t appear to cover a valid encoding that includes metadata.</div>
<div class='msg'><time>2025‑03‑30 14:50</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Preimage extrinsic (E_P) is a sequence of pairs (service index with blob).</div>
<div class='msg'><time>2025‑03‑30 14:51</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Implementations can determine it from the (encoded) block.</div>
<div class='msg'><time>2025‑03‑30 14:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Each other in the preimage extrinsic must be a valid request as per the prior state.</div>
<div class='msg'><time>2025‑03‑30 14:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: See (12.30) - (12.33) for formal definitions of this.</div>
<div class='msg'><time>2025‑03‑30 14:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: If you are still confused, I suggest you rephrase your query in though terms.</div>
<div class='msg'><time>2025‑03‑30 14:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: I&#x27;m not sure what you&#x27;re really asking, but if the question is &quot;if I receive a block which doesn&#x27;t correctly encode from from which I could make a best effort at some underlying meaning, should I import my best guess at it anyway?&quot; then the answer OF COURSE NOT!</div>
<div class='msg'><time>2025‑03‑30 14:54</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * I&#x27;m not sure what you&#x27;re really asking, but if the question is &quot;if I receive a block which doesn&#x27;t correctly decode but from which I could make a best guess at some underlying meaning, should I import my best guess at it anyway?&quot; then the answer OF COURSE NOT!</div>
<div class='msg'><time>2025‑03‑30 14:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * I&#x27;m not sure what you&#x27;re really asking, but if the question is &quot;if I receive a block which doesn&#x27;t correctly decode but from which I could make a best guess at imagining some underlying meaning, should I import it as though it was really an encoding of this best guess?&quot; then the answer OF COURSE NOT!</div>
<div class='msg'><time>2025‑03‑30 14:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * I&#x27;m not sure what you&#x27;re really asking, but if the question is &quot;if I receive a block which doesn&#x27;t correctly decode but from which I could make a best guess at imagining some underlying meaning, should I import it as though it was really an encoding of this best guess?&quot; then the answer is OF COURSE NOT!</div>
<div class='msg'><time>2025‑03‑30 14:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Again, this is a consensus protocol. There is no room for error or guesswork.</div>
<div class='msg'><time>2025‑03‑30 15:43</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: To be &quot;tougher&quot; - and concise:

These `preimage` test vectors (https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/codec/data/preimages_extrinsic.json) don’t cover a valid encoding that includes metadata. They are 7 months old.

➡️ So if I understand correctly =&gt; **we shouldn’t try to test these `preimage` test-vectors with the current GP version and just wait for new test vectors for preimages to be published ?**</div>
<div class='msg'><time>2025‑03‑30 17:31</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: If I understand correctly, what you&#x27;re asking is: if a preimage is requested which will be used as the code blob for a service, must the preimage be a valid &quot;code blob&quot; for it to be includable in a block and integrated into the service storage? Pretty sure the answer to this is no: as long as a preimage has been requested then it can be included in a block. If a service requests a preimage that cannot be decoded or used as a code blob for whatever reason, then attempts to use it as such will fail at the point of use. I&#x27;m not sure it can really work any other way as there is no type/format/whatever associated with preimages in the state; they are opaque binary blobs.</div>
<div class='msg reply'><time>2025‑03‑30 17:41</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: Thanks 🫶! That answers it pretty much

PS: by &quot;valid&quot; I meant only encoded-wise (https://graypaper.fluffylabs.dev/#/68eaa1f/106c01107101?v=0.6.4)

Thanks for the help</div>
<div class='msg'><time>2025‑03‑30 18:25</time>&ensp;<span class='u' style='color:#b332c3'>rustybot</span>: &gt; &lt;@celadari:matrix.org&gt; To be &quot;tougher&quot; - and concise:
&gt; 
&gt; These `preimage` test vectors (https://github.com/davxy/jam-test-vectors/blob/polkajam-vectors/codec/data/preimages_extrinsic.json) don’t cover a valid encoding that includes metadata. They are 7 months old.
&gt; 
&gt; ➡️ So if I understand correctly =&gt; **we shouldn’t try to test these `preimage` test-vectors with the current GP version and just wait for new test vectors for preimages to be published ?**

https://github.com/davxy/jam-test-vectors/tree/polkajam-vectors/codec#semantic-correctness</div>
<div class='msg'><time>2025‑03‑30 18:26</time>&ensp;<span class='u' style='color:#b332c3'>rustybot</span>: Codec vectors only exercise the codec. Data is just random data</div>
<div class='msg reply'><time>2025‑03‑30 18:28</time>&ensp;<span class='u' style='color:#db4dca'>celadari</span>: I agree but since we are talking about encoding I wasn&#x27;t sure to which extend we were supposed to verify or not.

But thanks anyway ✌️</div>
<div class='msg reply'><time>2025‑03‑30 18:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The Gray Paper is 100% clear on this.</div>
<div class='msg reply'><time>2025‑03‑30 18:30</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: If there was a need to verify, then it would state as much in the Gray Paper. It doesn&#x27;t.</div>
<div class='msg'><time>2025‑03‑30 18:27</time>&ensp;<span class='u' style='color:#b332c3'>rustybot</span>: * Codec vectors only exercise the codec. Payload is mostly just random data</div>
<div class='msg'><time>2025‑03‑31 15:39</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: Has anyone yet taken a serious look at if size-synchrony antagonism has been formalized mathematically? Would be nice to have further validation e.g. that what we’re doing is somewhat optimal </div>
<div class='msg'><time>2025‑03‑31 15:40</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: There are some quite similar concepts in systems theory.</div>
<div class='msg'><time>2025‑03‑31 15:55</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: AI answer:
&gt; One relevant concept is &quot;complexity theory,&quot; which posits that as systems grow in size and complexity, the potential for disorder and misalignment among components increases. This can lead to difficulties in achieving coherence. Larger systems may have more diverse elements, which can result in varying goals, behaviors, and interactions that can disrupt overall coherence.
&gt; Another related idea is &quot;Ashby&#x27;s Law of Requisite Variety,&quot; which states that for a system to effectively manage its environment, it must be as diverse as the environment it operates in. In larger systems, the variety of components and interactions can lead to challenges in maintaining coherence unless there are effective mechanisms for integration and coordination.
</div>
<div class='msg'><time>2025‑03‑31 15:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: However the strict trilemma of Scale, Speed and Coherence doesn&#x27;t seem to be a thing.</div>
<div class='msg'><time>2025‑03‑31 15:56</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * However the strict trilemma of Scale, Speed and Coherence doesn&#x27;t seem to be established.</div>
<div class='msg'><time>2025‑03‑31 15:57</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It seems to me, at least, quite demonstrable given real systems have causality bound by speed and component-distances.</div>
<div class='msg'><time>2025‑03‑31 15:58</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: CAP comes to mind, sort of a cousin principle if you will</div>
<div class='msg'><time>2025‑03‑31 16:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Coherence -&gt; degree of causality across all pairwise pieces of system state
Speed -&gt; bound as the time that it would take light to effect a causal resolution across the two most distant causally entangled parts of state
Size -&gt; Given some maximal density of system state, the total size of the system</div>
<div class='msg'><time>2025‑03‑31 16:00</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It seems pretty trivial to show that If you increase any of these you must reduce one or both of the others.</div>
<div class='msg'><time>2025‑03‑31 16:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Coherence -&gt; degree of causality across all pairwise pieces of system state
Speed -&gt; bound as the time that it would take light to effect a causal resolution across the two most distant causally entangled parts of state
Size -&gt; Given some maximal density of system state, the maximum distance between causally entangled state-components of the system</div>
<div class='msg'><time>2025‑03‑31 16:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: So if you make a system bigger (add more state components and therefore make things farther apart) you either need to accept causal resolution will be slower or you have to limit what parts are causally entangled and thus reduce coherence.</div>
<div class='msg'><time>2025‑03‑31 16:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * So if you make a system bigger (add more state components and therefore make things farther apart) you either need to accept causal resolution will be slower because at leats some portions of state are farther apart or you have to limit what parts are causally entangled and thus reduce coherence.</div>
<div class='msg'><time>2025‑03‑31 16:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: CAP is somehow related, but it&#x27;s binary (select any two).</div>
<div class='msg'><time>2025‑03‑31 16:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * CAP is somehow related, but it&#x27;s binary (select any two). It also doesn&#x27;t deal with size of speed but only properties.</div>
<div class='msg'><time>2025‑03‑31 16:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * CAP is somehow related, but it&#x27;s binary (select any two). It also doesn&#x27;t deal with size of speed but only &quot;correctness&quot; properties.</div>
<div class='msg'><time>2025‑03‑31 16:04</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: But yes, is a related trilemma/antagonism applicable to (distributed) systems.</div>
<div class='msg'><time>2025‑03‑31 16:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * So if you make a system bigger (add more state components and therefore make things farther apart) you either need to accept causal resolution will be slower because at least some portions of state are farther apart (and light only travels at a certain speed) or you have to limit what parts are causally entangled, limiting distances travelled for resolution and thus reduce coherence.</div>
<div class='msg'><time>2025‑03‑31 16:54</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: &gt; &lt;@gav:polkadot.io&gt; So if you make a system bigger (add more state components and therefore make things farther apart) you either need to accept causal resolution will be slower or you have to limit what parts are causally entangled and thus reduce coherence.

distance = rate * time in some sense?</div>
<div class='msg'><time>2025‑03‑31 16:55</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: Maybe that’s generalized too much</div>
<div class='msg'><time>2025‑03‑31 17:00</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: Distance ~ size
Rate ~ speed
Time ~ coherence</div>
<div class='msg'><time>2025‑03‑31 17:06</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: * Distance ~ size
Rate ~ speed
Time ~ coherence

So roughly size = speed*coherence</div>
<div class='msg'><time>2025‑03‑31 17:21</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: If a single global coherent state is the design goal (which it is) you can can play/design around different types of decoherence. Eg spatial decoherence (shards), temporal decoherence (ordered accumulation). You can allow for certain types of decoherence and still have a fully coherent global state sufficiently oftentimes to allow for the emergent abstraction of the Cloud layer.</div>
<div class='msg'><time>2025‑03‑31 17:24</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: * If a single global coherent state is the design goal (which it is) you can can play/design around different types of decoherence. Eg spatial decoherence (shards), temporal decoherence (ordered accumulation / asynchrony). You can allow for certain types of decoherence and still have a fully coherent global state sufficiently oftentimes to allow for the emergent abstraction of the Cloud layer.</div>
<div class='msg'><time>2025‑04‑01 06:01</time>&ensp;<span class='u' style='color:#4772c5'>faiz_871</span>: </div>
<div class='msg'><time>2025‑04‑01 06:14</time>&ensp;<span class='u' style='color:#4772c5'>faiz_871</span>: * Could somebody please explain the meaning of variable δ here in Refine invocation function PsiR https://graypaper.fluffylabs.dev/#/5f542d7/2d65002d0e01?v=0.6.2</div>
<div class='msg'><time>2025‑04‑01 11:05</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: size = time_taken / coherence</div>
<div class='msg'><time>2025‑04‑01 11:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: or speed * size * coherence = 1</div>
<div class='msg'><time>2025‑04‑01 11:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: you can make a system go fast, go big, or stay fully coherent but not all of them.</div>
<div class='msg'><time>2025‑04‑01 11:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: decentralisation implies size, but not the other way around.</div>
<div class='msg'><time>2025‑04‑01 11:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: so, if you keep a system small (in order to keep it fast and coherent, you&#x27;ll not be able to decentralise nor will you be able to scale out.</div>
<div class='msg'><time>2025‑04‑01 11:10</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * so, if you keep a system small (in order to keep it fast and coherent we might presume), you&#x27;ll not be able to decentralise nor will you be able to scale out.</div>
<div class='msg'><time>2025‑04‑01 11:11</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: i&#x27;d argue that by introducing such decoherence you do not have a fully coherent state.</div>
<div class='msg'><time>2025‑04‑01 11:13</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: however there may be ways to make the system *apparently* coherent, or dynamically rebalance the speed and/or coherence in order to optimise all three at any given time. </div>
<div class='msg'><time>2025‑04‑01 11:30</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: * Distance ~ size
Rate ~ speed
Time ~ 1/coherence

So roughly size = speed/coherence</div>
<div class='msg'><time>2025‑04‑01 11:35</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: &gt; &lt;@gav:polkadot.io&gt; or speed * size * coherence = 1

Or size*coherence ~ speed, with more speed of info travel you can get bigger or more coherent, no?</div>
<div class='msg'><time>2025‑04‑01 11:36</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: * Distance ~ size
Rate ~ speed
Time ~ 1/coherence

So roughly size ~ speed/coherence</div>
<div class='msg'><time>2025‑04‑01 11:36</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: sure.</div>
<div class='msg'><time>2025‑04‑01 11:37</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: * Distance ~ size
Rate ~ speed
Time ~ coherence

So roughly size = speed*coherence</div>
<div class='msg'><time>2025‑04‑01 11:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: but there&#x27;s two different speeds here</div>
<div class='msg'><time>2025‑04‑01 11:37</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: there&#x27;s the physical limit of speed (speed of light), and the overall speed of the system (one over time to causal resolution)</div>
<div class='msg'><time>2025‑04‑01 11:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: it probably isnt sensible to call both things &quot;speed&quot;.</div>
<div class='msg'><time>2025‑04‑01 11:38</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * it probably isn&#x27;t sensible to call both things &quot;speed&quot;.</div>
<div class='msg'><time>2025‑04‑01 11:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: the speed of light determines the upper limit of causal resolution - no system could ever process causal interactions faster than this. but it doesn&#x27;t account for keeping a complex system in coherence. as coherent systems become bigger and more complex, the speed of causality diverges from this universal physical limit.</div>
<div class='msg'><time>2025‑04‑01 11:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * the speed of light determines the upper limit of causal resolution - no system could ever process causal interactions faster than this. but it doesn&#x27;t account for keeping a complex and arbitrary system in coherence. as coherent systems become bigger and more complex, the speed of causality diverges from this universal physical limit.</div>
<div class='msg'><time>2025‑04‑01 11:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * the speed of light determines the upper limit of causal resolution - no system could ever process causal interactions faster than this. but it doesn&#x27;t account for keeping a complex and arbitrary system in coherence. as coherent systems become bigger and more complex, the speed of their overall causality diverges from this universal physical limit.</div>
<div class='msg'><time>2025‑04‑01 11:45</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: at a basic level, as a coherent system grows, even if all of its internal causality happened at the speed of light, it would still take longer to step through its state transitions becuase it would take light longer to get from the corners of the system to interact and resolve.</div>
<div class='msg'><time>2025‑04‑01 11:46</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: so the system - in terms of state transitions per second - would be slower.</div>
<div class='msg'><time>2025‑04‑01 11:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: this is compounded by complexity, meaning that internal causal entanglements probably resolve slower as the system grows more complex and arbitrary.</div>
<div class='msg'><time>2025‑04‑01 11:47</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: light is not just going in a straight line.</div>
<div class='msg'><time>2025‑04‑01 11:48</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: of course our systems have a long way to go before the speed of light becomes too important. but still, the principle can serve us well now.</div>
<div class='msg'><time>2025‑04‑01 11:58</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: basically `T=ZX/C` where:
- `T` is time to causal resolution (s),
- `Z` is size of the system (m),
- `X` is complexity factor of the system (no units)
- `C` is speed of light</div>
<div class='msg'><time>2025‑04‑01 12:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * basically `T=ZX/C` where:

- `T` is time to causal resolution (s),
- `Z` is size of the system (m - the diameter of its bounding sphere basically),
- `X` is complexity factor of the system (no units, but a factor at least 1 which describes the average distance light must travel in order to guarantee a causal resolution of state-transition)
- `C` is speed of light</div>
<div class='msg'><time>2025‑04‑01 12:01</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * basically `T=ZX/C` where:

- `T` is time to causal resolution (s),
- `Z` is size of the system (m - the diameter of its bounding sphere basically),
- `X` is complexity factor of the system (no units, but a factor at least 1 which describes the distance light must travel in order to guarantee a causal resolution of state-transition)
- `C` is speed of light</div>
<div class='msg'><time>2025‑04‑01 12:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * basically `T=ZX/C` where:

- `T` is time to causal resolution (s),
- `Z` is size of the system (m - the diameter of its bounding sphere basically),
- `X` is complexity factor of the system (no units, but a factor at least 1 which describes the number of times light must travel back across the diameter of the bounding sphere in order to guarantee a causal resolution of state-transition)
- `C` is speed of light</div>
<div class='msg'><time>2025‑04‑01 12:02</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * basically `T=ZX/C` where:

- `T` is time to causal resolution (s),
- `Z` is size of the system (m - the diameter of its bounding sphere basically),
- `X` is complexity factor of the system (no units, but a factor of at least 1 which describes the number of times light must travel back across the diameter of the bounding sphere in order to guarantee a causal resolution of state-transition)
- `C` is speed of light</div>
<div class='msg'><time>2025‑04‑01 12:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * basically `T=ZX/C` where:

- `T` is time to causal resolution (s - this is the inverse of the system&#x27;s operating speed),
- `Z` is size of the system (m - the diameter of its bounding sphere basically),
- `X` is complexity factor of the system (no units, but a factor of at least 1 which describes the number of times light must travel back across the diameter of the bounding sphere in order to guarantee a causal resolution of state-transition)
- `C` is speed of light</div>
<div class='msg'><time>2025‑04‑01 12:03</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * basically `T=ZX/C` where:

- `T` is time to causal resolution (s - this is the inverse of the system&#x27;s operating speed),
- `Z` is size of the system (m - the diameter of the system&#x27;s bounding sphere),
- `X` is complexity factor of the system (no units, but a factor of at least 1 which describes the number of times light must travel back across the diameter of the bounding sphere in order to guarantee a causal resolution of state-transition)
- `C` is speed of light</div>
<div class='msg'><time>2025‑04‑01 12:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: a totally trivial system would be a single laser switch in a vacuum with one light emitter transmitting a light signal to some light receiver. in this case Z would be the distance between the emitter and receiver, X would be close to one and T would therefore amount to the time it took light to travel between them.</div>
<div class='msg'><time>2025‑04‑01 12:06</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: this wouldn&#x27;t do much any processing though.</div>
<div class='msg'><time>2025‑04‑01 12:07</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: as we introduce the capability of data processing, `X` increases, and as we introduce state (whether intra-transition or inter-transition) `Z` increases.</div>
<div class='msg'><time>2025‑04‑01 12:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * as we introduce the capability of data processing `X` increases since the round trip of light is much higher as it passes through more gates and it routed around; and as we introduce state (whether intra-transition or inter-transition) `Z` increases as we need to cover a greater space.</div>
<div class='msg'><time>2025‑04‑01 12:08</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * as we introduce the capability of data processing `X` increases since the round trip of light is much higher as it passes through more gates and it routed around; and as we introduce state (whether intra-transition or inter-transition) `Z` increases as we need to cover a greater space to hold more information (also a fundamental physical principle).</div>
<div class='msg'><time>2025‑04‑01 12:09</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * as we introduce the capability of data processing `X` increases since the round trip of light is much higher as it passes through more gates and it routed around; and as we introduce state (whether intra-transition or inter-transition) `Z` increases as we need to cover a greater space to hold more information (also a fundamental physical principle as well as intuitively correct).</div>
<div class='msg'><time>2025‑04‑01 12:27</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: That seems like a good model. as a cool aside maximum info scales with the surface area of the bounding region, given by the bekenstein bound which black holes are believed to saturate </div>
<div class='msg'><time>2025‑04‑01 12:29</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: * That seems like a good model. as a cool aside maximum info scales with the surface area (not volume) of the bounding region, given by the bekenstein bound which black holes are believed to saturate </div>
<div class='msg'><time>2025‑04‑01 12:37</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: * That seems like a good model. as a cool aside maximum info scales with the surface area (not volume) of the bounding sphere, given by the bekenstein bound which black holes are believed to saturate </div>
<div class='msg'><time>2025‑04‑01 12:59</time>&ensp;<span class='u' style='color:#a23bc7'>emielsebastiaan</span>: My team and I have put some thought into this. I’ll try to digest it into something presentable for our little Lisbon meetup. </div>
<div class='msg'><time>2025‑04‑01 14:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * this wouldn&#x27;t do any processing though.</div>
<div class='msg'><time>2025‑04‑01 14:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Ahh yeah the holographic principle iirc</div>
<div class='msg'><time>2025‑04‑01 18:07</time>&ensp;<span class='u' style='color:#5e86de'>boymaas</span>: Have we considered, as a thought experiment, https://en.wikipedia.org/wiki/Quantum_entanglement as a means to get instant coherence in distributed systems? Going beyond the speed of light ... 😃</div>
<div class='msg'><time>2025‑04‑01 18:09</time>&ensp;<span class='u' style='color:#bfaf39'>dakkk</span>: &gt; &lt;@boymaas:matrix.org&gt; Have we considered, as a thought experiment, https://en.wikipedia.org/wiki/Quantum_entanglement as a means to get instant coherence in distributed systems? Going beyond the speed of light ... 😃

You can&#x27;t communicate any information faster than the speed of light; quantum entanglement doesn&#x27;t do that </div>
<div class='msg'><time>2025‑04‑01 18:13</time>&ensp;<span class='u' style='color:#5e86de'>boymaas</span>: Too bad, reading it now indeed, would have been an interesting case.</div>
<div class='msg'><time>2025‑04‑01 18:42</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: is sbrk here to stay? I noticed its being used in the accumulate testvectors.</div>
<div class='msg'><time>2025‑04‑02 08:24</time>&ensp;<span class='u' style='color:#bc5896'>greywolve</span>: Is the [28 days that erasure coded chunks need to be held for](https://graypaper.fluffylabs.dev/#/68eaa1f/1d2d001d3100?v=0.6.4) a minimum or a maximum? </div>
<div class='msg'><time>2025‑04‑02 08:26</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: minimum. you are not wrong if retained for one more day, but not the case otherwise</div>
<div class='msg'><time>2025‑04‑02 08:27</time>&ensp;<span class='u' style='color:#bc5896'>greywolve</span>: and I assume storing more data just costs you more?</div>
<div class='msg'><time>2025‑04‑02 08:27</time>&ensp;<span class='u' style='color:#4cbfa8'>xlchen</span>: yeah use more disk storage</div>
<div class='msg'><time>2025‑04‑04 13:02</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: hi there, please correct me if I&#x27;m wrong, a should be encoded right after c in (A.37)

https://github.com/gavofyork/graypaper/pull/323/files#diff-16981432fb50e7e5c3d19d2f40b81e3a14b1c9986de5a179b392b47cd8018383R773</div>
<div class='msg'><time>2025‑04‑04 13:03</time>&ensp;<span class='u' style='color:#be2950'>clearloop</span>: * hi there, please correct me if I&#x27;m wrong, a should be encoded right after c in (A.37) (Standard Program Initialization)

https://github.com/gavofyork/graypaper/pull/323/files#diff-16981432fb50e7e5c3d19d2f40b81e3a14b1c9986de5a179b392b47cd8018383R773</div>
<div class='msg'><time>2025‑04‑04 16:16</time>&ensp;<span class='u' style='color:#6141a6'>yuchun</span>: Hey there,

I have a question regarding the available work-reports 

The **W** available work-reports (defined in equation [(11.16)](https://graypaper.fluffylabs.dev/#/68eaa1f/144601144601?v=0.6.4)) are extracted from `rhoDagger` using the core index. As I understand it, each core should correspond to only one work-report, is that correct?

However, I’m a bit confused about equation [(13.10)](https://graypaper.fluffylabs.dev/#/68eaa1f/195601195601?v=0.6.4). It sums the work-reports for a specific core from the set of available work-reports. Does this imply that the same core might appear multiple times in the available work-reports?

Please feel free to let me know if I’ve misunderstood anything.

Thanks
</div>
<div class='msg'><time>2025‑04‑04 18:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes and no. </div>
<div class='msg'><time>2025‑04‑04 18:49</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: (In the case of 13.10, sum was simply to ensure that we get zero if the core is empty) </div>
<div class='msg'><time>2025‑04‑04 22:07</time>&ensp;<span class='u' style='color:#4068cd'>0xjunha</span>: In memory accessibility notation, is there any specific reason to use both \subseteq and \subset ? Or is that a typo?
\subset makes more sense to me - some host functions (and sbrk inst) are using \subseteq while others use \subset.

https://graypaper.fluffylabs.dev/#/68eaa1f/34a90234a902?v=0.6.4
https://graypaper.fluffylabs.dev/#/68eaa1f/336b00336b00?v=0.6.4</div>
<div class='msg'><time>2025‑04‑05 04:41</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@0xjunha:matrix.org&gt; In memory accessibility notation, is there any specific reason to use both \subseteq and \subset ? Or is that a typo?
&gt; \subset makes more sense to me - some host functions (and sbrk inst) are using \subseteq while others use \subset.
&gt; 
&gt; https://graypaper.fluffylabs.dev/#/68eaa1f/34a90234a902?v=0.6.4
&gt; https://graypaper.fluffylabs.dev/#/68eaa1f/336b00336b00?v=0.6.4

Typo. It should all be subseteq</div>
<div class='msg'><time>2025‑04‑07 04:55</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: https://graypaper.fluffylabs.dev/#/68eaa1f/09cf0109d301?v=0.6.4
https://graypaper.fluffylabs.dev/#/68eaa1f/09e70109e901?v=0.6.4
is the jam common era timestamp annotation wrong? 
1,735,689,600 (0000 UTC on January 1, 2025)
or
1,735,732,800 (1200 UTC on January 1, 2025)</div>
<div class='msg reply'><time>2025‑04‑07 11:38</time>&ensp;<span class='u' style='color:#4068cd'>0xjunha</span>: Probably will be included in the next release?

https://github.com/gavofyork/graypaper/commit/b16207dc291d343991de2fdfb9aa3feb25927b50</div>
<div class='msg reply'><time>2025‑04‑07 12:23</time>&ensp;<span class='u' style='color:#5adda3'>shwchg</span>: Thanks!</div>
<div class='msg'><time>2025‑04‑08 20:08</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: tecnically speaking is there something preventing the same service to be executed multiple times in the same block?</div>
<div class='msg'><time>2025‑04‑08 20:08</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: * I have a question: tecnically speaking is there something preventing the same service to be executed multiple times in the same block?</div>
<div class='msg'><time>2025‑04‑08 20:16</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Not at all. </div>
<div class='msg'><time>2025‑04‑08 20:17</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: And it can happen due to queuing and earlier work tranches but using all their allotted gas. </div>
<div class='msg'><time>2025‑04‑08 20:20</time>&ensp;<span class='u' style='color:#5c84c9'>prematurata</span>: tkz</div>
<div class='msg'><time>2025‑04‑14 17:06</time>&ensp;<span class='u' style='color:#7875cf'>charliewinston14</span>: Maybe I missed it but is there anything in the GP that mentions how to validate a justification received by CE 137?? I can generate one using the trace function but am not sure how a receiving node verifys the shard is correct using it.</div>
<div class='msg reply'><time>2025‑04‑14 17:12</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: In general the GP doesn&#x27;t say how to implement anything, it just defines the required behaviour. The justification is a Merkle proof and can be verified in the usual way. There are lots of blogposts explaining the concept that you can find by googling &quot;merkle proof&quot;</div>
<div class='msg reply'><time>2025‑04‑15 14:28</time>&ensp;<span class='u' style='color:#7875cf'>charliewinston14</span>: Ok that helped I have the general idea now. One question to everyone, given each value in a justification how do you know if they represent a left or right node to be be able to calculate the right hash?</div>
<div class='msg reply'><time>2025‑04‑15 15:15</time>&ensp;<span class='u' style='color:#c65779'>dave</span>: You can determine the &quot;path&quot; (series of lefts/rights) from the shard index</div>
<div class='msg'><time>2025‑04‑15 15:13</time>&ensp;<span class='u' style='color:#bc5896'>greywolve</span>: I think some variant of this question has been asked but I didn&#x27;t see a clear answer.

Assuming I want to submit a ticket extrinsic that will be included in the first block of a new epoch. At that point I have the last state of the previous epoch. 

1) Do I use eta_1 from the old state for the ring signature context? Given this will become eta_2 in the next epoch when the ticket will be verified.

2) What about the y_z, I only have access to the only y_z. I don&#x27;t see a way to compute what the new one yet. Do I just sign with the old y_z and hope it doesn&#x27;t change?</div>
<div class='msg'><time>2025‑04‑15 15:14</time>&ensp;<span class='u' style='color:#bc5896'>greywolve</span>: * I think some variant of this question has been asked but I didn&#x27;t see a clear answer.

Assuming I want to submit a ticket extrinsic that will be included in the first block of a new epoch. At that point I have the last state of the previous epoch.

1. Do I use eta\_1 from the old state for the ring signature context? Given this will become eta\_2 in the next epoch when the ticket will be verified.
2. What about the y\_z, I only have access to the old y\_z. I don&#x27;t see a way to compute what the new one yet. Do I just sign with the old y\_z and hope it doesn&#x27;t change?</div>
<div class='msg'><time>2025‑04‑15 15:17</time>&ensp;<span class='u' style='color:#bc5896'>greywolve</span>: * I think some variant of this question has been asked but I didn&#x27;t see a clear answer.

Assuming I want to submit a ticket extrinsic that will be included in the first block of a new epoch. At that point I have the last state of the previous epoch.

1. Do I use eta\_1 from the old state for the ring signature context? Given this will become eta\_2 in the next epoch when the ticket will be verified.
2. What about the y\_z, I only have access to the old y\_z. I don&#x27;t see a way to compute what the new one yet. Do I just sign with the old y\_z and hope it doesn&#x27;t change?

3. When importing this first block in the epoch, would we use the prior y_z or new y_z to verify tickets?</div>
<div class='msg'><time>2025‑04‑15 15:29</time>&ensp;<span class='u' style='color:#bc5896'>greywolve</span>: * I think some variant of this question has been asked but I didn&#x27;t see a clear answer.

Assuming I want to submit a ticket extrinsic that will be included in the first block of a new epoch. At that point I have the last state of the previous epoch.

1. Do I use eta\_1 from the old state for the ring signature context? Given this will become eta\_2 in the next epoch when the ticket will be verified.
2. What about the y\_z, I only have access to the old y\_z. I don&#x27;t see a way to compute the new one yet. Do I just sign with the old y\_z and hope it doesn&#x27;t change?
3. When importing this first block in the epoch, would we use the prior y\_z or new y\_z to verify tickets?</div>
<div class='msg'><time>2025‑04‑15 15:29</time>&ensp;<span class='u' style='color:#bc5896'>greywolve</span>: * I think some variant of this question has been asked but I didn&#x27;t see a clear answer.

Assuming I want to submit a ticket extrinsic that will be included in the first block of a new epoch. At that point I have the last state of the previous epoch.

1. Do I use eta\_1 from the old state for the ring signature context? Given this will become eta\_2 in the next epoch when the ticket will be verified.
2. What about the y\_z, I only have access to the old y\_z. I don&#x27;t see a way to compute the new one yet. Do I just sign with the old y\_z and hope it doesn&#x27;t change?
3. When importing this first block in the epoch, would I use the prior y\_z or new y\_z to verify tickets?</div>
<div class='msg'><time>2025‑04‑15 15:51</time>&ensp;<span class='u' style='color:#bc5896'>greywolve</span>: * I think some variant of this question has been asked but I didn&#x27;t see a clear answer.

Assuming I want to submit a ticket extrinsic that will be included in the first block of a new epoch. At that point I have the last state of the previous epoch.

1. Do I use eta\_1 from the old state for the ring signature context? Given this will become eta\_2 in the next epoch when the ticket will be verified.
2. What about the y\_z, I only have access to the old y\_z. I don&#x27;t see a way to compute the new one yet. Do I just sign with the old y\_z and hope it doesn&#x27;t change?
3. When importing this first block in the epoch, would I use the prior y\_z or new y\_z to verify tickets? [6.29 seems to indicate the prior](https://graypaper.fluffylabs.dev/#/68eaa1f/0f59000f5900?v=0.6.4)</div>
<div class='msg'><time>2025‑04‑15 15:51</time>&ensp;<span class='u' style='color:#bc5896'>greywolve</span>: * I think some variant of this question has been asked but I didn&#x27;t see a clear answer.

Assuming I want to submit a ticket extrinsic that will be included in the first block of a new epoch. At that point I have the last state of the previous epoch.

1. Do I use eta\_1 from the old state for the ring signature context? Given this will become eta\_2 in the next epoch when the ticket will be verified.
2. What about the y\_z, I only have access to the old y\_z. I don&#x27;t see a way to compute the new one yet. Do I just sign with the old y\_z and hope it doesn&#x27;t change?
3. When importing this first block in the epoch, would I use the prior y\_z or new y\_z to verify tickets? [6.29 seems to indicate the prior.](https://graypaper.fluffylabs.dev/#/68eaa1f/0f59000f5900?v=0.6.4)</div>
<div class='msg'><time>2025‑04‑15 15:52</time>&ensp;<span class='u' style='color:#bc5896'>greywolve</span>: * I think some variant of this question has been asked but I didn&#x27;t see a clear answer.

Assuming I want to submit a ticket extrinsic that will be included in the first block of a new epoch. At that point I have the last state of the previous epoch.

1. Do I use eta\_1 from the old state for the ring signature context? Given this will become eta\_2 in the next epoch when the ticket will be verified.
2. What about the y\_z, I only have access to the old y\_z. I don&#x27;t see a way to compute the new one yet. Do I just sign with the old y\_z (and y_k) and hope it doesn&#x27;t change?
3. When importing this first block in the epoch, would I use the prior y\_z or new y\_z to verify tickets? [6.29 seems to indicate the prior.](https://graypaper.fluffylabs.dev/#/68eaa1f/0f59000f5900?v=0.6.4)</div>
<div class='msg'><time>2025‑04‑16 07:52</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: 1. Yes.
3. This is a typo - it should read γ&#x27;z, not γz. I&#x27;ll change this
2. You&#x27;ll need to compute it - you have all the information necessary from the prior state.
</div>
<div class='msg'><time>2025‑04‑16 07:53</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * 1. Yes.
2. I think this is a typo (@davide - wdyt?) - it should read γ&#x27;z, not γz. I&#x27;ll change this.
3. You&#x27;ll need to compute it - you have all the information necessary from the prior state.</div>
<div class='msg'><time>2025‑04‑16 07:55</time>&ensp;<span class='u' style='color:#bc5896'>greywolve</span>: Thanks!</div>
<div class='msg'><time>2025‑04‑16 08:58</time>&ensp;<span class='u' style='color:#c9419d'>davxy</span>: &gt; &lt;@greywolve:matrix.org&gt; Thanks!

Yeah that is a typo</div>
<div class='msg'><time>2025‑04‑17 16:04</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: I have a doubt about core statistics formula:

Formula 13.9 points to w (lowercased) - reports in guarantees extrinsic: https://graypaper.fluffylabs.dev/#/68eaa1f/190d01190f01?v=0.6.4

Formula 13.10 points to W (uppercase) - available reports:
https://graypaper.fluffylabs.dev/#/68eaa1f/193e01193f01?v=0.6.4

Is this correct? If so, why is that? Also, in this context, it is very easy to incorrectly use W in the place of w, or vice-versa, since visually the difference is very subtle.</div>
<div class='msg'><time>2025‑04‑18 15:05</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: Just to confirm my understanding- the PVM entry pc is NOT required to be the start of a basic block, correct? Jan Bujak </div>
<div class='msg'><time>2025‑04‑18 15:11</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Currently, yes. Note that this is only relevant for inner PVMs - the outer PVM always starts at 0.</div>
<div class='msg'><time>2025‑04‑18 15:11</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: * Currently, yes (because we need the ability to resume execution after a page fault). Note that this is only relevant for inner PVMs - the outer PVM always starts at 0.</div>
<div class='msg'><time>2025‑04‑18 15:16</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: interesting point about resuming after a nested pvm page fault- thanks for clarifying. Aren&#x27;t the outer invocation entry pcs non-zero though? For example accumulate initial pc is 5 right? https://graypaper.fluffylabs.dev/#/68eaa1f/2ec1002ec100?v=0.6.4</div>
<div class='msg'><time>2025‑04‑18 15:17</time>&ensp;<span class='u' style='color:#4281bb'>jimboj21</span>: I would think the non-zero cases would have to be jumps right?</div>
<div class='msg'><time>2025‑04‑18 15:18</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Right, sorry, since it&#x27;s late here I had a brainfart there.</div>
<div class='msg'><time>2025‑04‑18 15:18</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: * Currently, yes (because we need the ability to resume execution after a page fault).</div>
<div class='msg'><time>2025‑04‑18 15:20</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: I suppose technically the outer PVM&#x27;s entry points could end up in the middle of a basic block if you&#x27;d build a particularly cursed blob.</div>
<div class='msg'><time>2025‑04‑18 15:21</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: No worries, thanks for clarifying. It sounds like it&#x27;s acceptable for an outer entrypoint to be into the middle of a basic block. My apologies for @ing after hours.</div>
<div class='msg'><time>2025‑04‑18 15:23</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: I have considered disallowing such entry points in the past (basically allow only start-of-basic-block entry points and those needed for hostcall + page fault resumption), but we haven&#x27;t made such change to the GP yet.</div>
<div class='msg'><time>2025‑04‑18 15:23</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: cursed blob/ an intentional attempt to break consensus 😉</div>
<div class='msg'><time>2025‑04‑18 15:24</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: That&#x27;s how I approached in my reasoning as well, do you think this change is likely?</div>
<div class='msg'><time>2025‑04‑18 15:25</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * That&#x27;s how I approached in my reasoning as well, do you think this change is likely? No worries if its too early to tell- just curious. Might end up tabling this in my impl.</div>
<div class='msg'><time>2025‑04‑18 15:30</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Can&#x27;t give you a 100% answer at this point, but it is possible. In general the plan for the final gas cost model is to charge gas only at the beginning of the basic blocks (because charging per instruction is very inefficient), so now if you allow entry points anywhere this potentially complicates the gas metering implementation. Unfortunately disallowing them doesn&#x27;t necessarily alleviate the problem because you still need to allow entry after page faults, and since memory accesses are so common we don&#x27;t want to make memory access instructions into basic block terminators.</div>
<div class='msg'><time>2025‑04‑18 15:35</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: Thanks for clarifying, this is really helpful. I don&#x27;t have enough context yet to form an opinion on the tradeoffs between allowing inner-instances being able to resume right after pageFault vs requiring them to restart/rollback to some basic block.</div>
<div class='msg'><time>2025‑04‑18 15:36</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * Thanks for clarifying, this is really helpful. I don&#x27;t have enough context yet to form an opinion on the tradeoffs between allowing inner-instances being able to resume right after pageFault vs requiring them to restart/rollback to the start of a basic block.</div>
<div class='msg'><time>2025‑04‑18 15:37</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Although we *need* some limitation when it comes to entry points, because without any restrictions you could e.g. jump into the middle of an instruction, and depending on the particular bytes used that might actually be a valid instruction. Supporting this in practice would be a nightmare in any other implementation that isn&#x27;t a naive slow interpreter, so at very least jumping in the middle of instructions is something that we definitely do *not* want to support.</div>
<div class='msg'><time>2025‑04‑18 15:38</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: context as far as the programs/usage of them on top of JAM I mean</div>
<div class='msg'><time>2025‑04‑18 15:39</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Unfortunately it&#x27;s impossible to require a restart at the start of a basic block as that&#x27;d screw up the program state.</div>
<div class='msg'><time>2025‑04‑18 15:39</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * *context as far as the programs/usage of programs on top of JAM</div>
<div class='msg'><time>2025‑04‑18 15:39</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: The already executed part of the basic block might have modified memory or registers in a way that is irreversible.</div>
<div class='msg'><time>2025‑04‑18 15:40</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: So a rollback is not possible without taking a snapshot at the start of every basic block which might page fault, and we do not want that as it&#x27;d be abysmally slow.</div>
<div class='msg'><time>2025‑04‑18 15:40</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: the outer pvm instance would have access to gas host function and could potentially use its own memory as a backup before any unsafe calls right? Although, this gets way complicated fast</div>
<div class='msg'><time>2025‑04‑18 15:41</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: lol we were thinking the same, yep</div>
<div class='msg'><time>2025‑04‑18 15:41</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * lol we were thinking the same, yep- agreed</div>
<div class='msg'><time>2025‑04‑18 15:42</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: But at the least, the outer pvm could do gas check to determine if it wants to &#x27;risk&#x27; another inner invocation right? Although being turing complete makes this pretty hard- unless there&#x27;s some well-defined gas-estimate API contract between nested invocations</div>
<div class='msg'><time>2025‑04‑18 15:43</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: That&#x27;s infeasible; if you could do that you&#x27;d become a very rich person as then it&#x27;d mean you solved the halting problem. :P</div>
<div class='msg'><time>2025‑04‑18 15:44</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: good point lol, suppose that api idea would be practically useless due to such a small scope of applicability... </div>
<div class='msg'><time>2025‑04‑18 15:46</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: This discussion has provided a lot of clarity, and given me a few things to think about... Many thanks for your time Jan Bujak  🙏</div>
<div class='msg'><time>2025‑04‑18 17:05</time>&ensp;<span class='u' style='color:#4281bb'>jimboj21</span>: image.png</div>
<div class='msg'><time>2025‑04‑18 17:06</time>&ensp;<span class='u' style='color:#4281bb'>jimboj21</span>: image.png</div>
<div class='msg'><time>2025‑04‑18 17:07</time>&ensp;<span class='u' style='color:#4281bb'>jimboj21</span>: Given the return signature: When 12.17 is called shouldnt the assignment order be o*, t*, b*, u* ?</div>
<div class='msg'><time>2025‑04‑19 16:18</time>&ensp;<span class='u' style='color:#817ecb'>ycc3741</span>: I just want to confirm something about STF.
Should the dispute when updating ψ′ happen before safrole?
Because based on what I see in this [link](https://graypaper.fluffylabs.dev/#/68eaa1f/0ea2000ea200?v=0.6.4),
updating gamma_k&#x27; requires ψ′_o.</div>
<div class='msg'><time>2025‑04‑19 17:23</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@jimboj21:matrix.org&gt; Given the return signature: When 12.17 is called shouldnt the assignment order be o*, t*, b*, u* ?

Yes. I think this is already fixed in main. </div>
<div class='msg'><time>2025‑04‑19 17:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: &gt; &lt;@ycc3741:matrix.org&gt; I just want to confirm something about STF.
&gt; Should the dispute when updating ψ′ happen before safrole?
&gt; Because based on what I see in this [link](https://graypaper.fluffylabs.dev/#/68eaa1f/0ea2000ea200?v=0.6.4),
&gt; updating gamma_k&#x27; requires ψ′_o.

Yes pretty much. Order is technically an implementation detail - some language don’t have that concept - so I’m not going to tell you any order per se, but your reading is correct - key rotation is dependent on disputes. </div>
<div class='msg'><time>2025‑04‑20 14:18</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * Yes pretty much. Order is technically an implementation detail - some languages don’t have the concept of ordering - so I’m not going to tell you any order per se, but your reading is correct - key rotation is dependent on disputes.</div>
<div class='msg'><time>2025‑04‑20 14:21</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes your reading is correct. It is in order to get as much information as possible in statistics, not just reported stuff (which represents the most recent computation work done on cores by guarantors) but also what data - required by each core - has recently been made available through assurers</div>
<div class='msg'><time>2025‑04‑21 21:25</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: I think the GP is not clear on how to serialize elements of N? And therefore, e.g. state serialization (D.2) is not clear on how to serialize the validator statistics component C, which has components in N</div>
<div class='msg reply'><time>2025‑04‑21 21:47</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: N you mean integers? </div>
<div class='msg reply'><time>2025‑04‑21 21:49</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: Formula C.6 is how you serialize numbers in N</div>
<div class='msg'><time>2025‑04‑21 21:47</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: 
 bold N , naturals</div>
<div class='msg'><time>2025‑04‑21 21:53</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: Makes sense, wanted to make sure we’re intentionally using the general natural serialization here instead of accidentally not specifying the subscript. Since usually we only use the general one for the length discriminator </div>
<div class='msg'><time>2025‑04‑21 21:55</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: It’s just not very consistent. Also in C(13) we are clear to use E_4 for pi_V and pi_L which have components in bold N </div>
<div class='msg'><time>2025‑04‑21 21:55</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: &gt; &lt;@ascriv:matrix.org&gt; Makes sense, wanted to make sure we’re intentionally using the general natural serialization here instead of accidentally not specifying the subscript. Since usually we only use the general one for the length discriminator 

Yes. It is used for the first time in latest version of GP</div>
<div class='msg'><time>2025‑04‑21 21:56</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: &gt; &lt;@ascriv:matrix.org&gt; It’s just not very consistent. Also in C(13) we are clear to use E_4 for pi_V and pi_L which have components in bold N 

It is used to save storage space, as statistics number can grow in definetly (or not). </div>
<div class='msg'><time>2025‑04‑21 21:57</time>&ensp;<span class='u' style='color:#4977cf'>danicuki</span>: &gt; &lt;@ascriv:matrix.org&gt; It’s just not very consistent. Also in C(13) we are clear to use E_4 for pi_V and pi_L which have components in bold N 

 * It is used to save storage space, as statistics number can grow indefinetly (or not).</div>
<div class='msg'><time>2025‑04‑21 21:58</time>&ensp;<span class='u' style='color:#4036ac'>ascriv</span>: But couldn’t pi_V and _L also? Yet we implicitly limit them based on the usage of E_4 serializing them</div>
<div class='msg'><time>2025‑04‑22 11:22</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: The lack of subscript is intentional.</div>
<div class='msg'><time>2025‑04‑22 11:25</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Yes, the encoding of integers is not presently entirely uniform. Some are encoded for size savings (statistics, where there&#x27;s relatively a lot of data in a place where bandwidth is very tight), others for the ability to swiftly/efficiently decode (e.g. in PVM I/O). It will be reviewed during the 0.6 series under this issue https://github.com/gavofyork/graypaper/issues/293.</div>
<div class='msg'><time>2025‑04‑22 11:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: pi_V and pi_L might yet be changed, or possibly pi_C/pi_S.</div>
<div class='msg'><time>2025‑04‑22 11:26</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: * The encoding used for pi\_V and pi\_L might yet be changed, or possibly pi\_C/pi\_S.</div>
<div class='msg'><time>2025‑04‑22 11:27</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: Again, the above issue will resolve this.</div>
<div class='msg'><time>2025‑04‑22 11:28</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: GP [v0.6.5](https://github.com/gavofyork/graypaper/releases/tag/v0.6.5) is out.</div>
<div class='msg'><time>2025‑04‑22 11:29</time>&ensp;<span class='u' style='color:#cd8957'>gav</span>: It&#x27;s mostly corrections, with two small protocol alterations:
- There&#x27;s now a gas limit in the accumulation operand tuple.
- There&#x27;s a new host-call to allow services to provide preimages to other services directly without going through the regular off-chain preimage process.</div>
<div class='msg'><time>2025‑04‑22 12:34</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: Got a few minor questions to confirm my understanding of the PVM spec-&gt; 

1. If c[0] isn&#x27;t a valid opcode, this would result in a runtime error, *if and only if* the program attempts to execute c[0], correct?

2. If an instruction (this time corresponding to an index from the bitmask, k) contains an invalid opcode, this would result in a runtime error, *if and only if* the program attempts to execute it (runtime), correct?

3. if the skip length function doesn&#x27;t find any bitmask-marked opcodes within the subsequent 24 octets, this bumps the pc to current+24 correct? So if there happened to be a valid opcode &amp; args at that new pc, it would continue executing at the new pc in the same manner as if it were marked by the instruction bitmask, correct?


 Jan Bujak </div>
<div class='msg'><time>2025‑04‑22 12:34</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * Got a few minor questions to confirm my understanding of the PVM spec-&gt;

1. If c\[0\] isn&#x27;t a valid opcode, this would result in a runtime error, _if and only if_ the program attempts to execute c\[0\], correct?
2. If an instruction (this time corresponding to an index from the bitmask, k) contains an invalid opcode, this would result in a runtime error, _if and only if_ the program attempts to execute it, correct?
3. if the skip length function doesn&#x27;t find any bitmask-marked opcodes within the subsequent 24 octets, this bumps the pc to current+24 correct? So if there happened to be a valid opcode &amp; args at that new pc, it would continue executing at the new pc in the same manner as if it were marked by the instruction bitmask, correct?

Jan Bujak</div>
<div class='msg'><time>2025‑04‑22 12:34</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * Got a few minor questions to confirm my understanding of the PVM spec-&gt;

1. If c\[0\] isn&#x27;t a valid opcode, this would result in a runtime error, _if and only if_ the program attempts to execute c\[0\], correct?
2. If an instruction (this time corresponding to an index from the bitmask, k) contains an invalid opcode, this would result in a runtime error, _if and only if_ the program attempts to execute it, correct?
3. if the skip length function doesn&#x27;t find any bitmask-marked opcodes within the subsequent 24 octets, this bumps the pc to current+24. So if there happened to be a valid opcode &amp; args at that new pc, it would continue executing at the new pc in the same manner as if it were marked by the instruction bitmask, correct?

Jan Bujak</div>
<div class='msg'><time>2025‑04‑22 12:35</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * Got a few minor questions about PVM edge cases-&gt;

1. If c\[0\] isn&#x27;t a valid opcode, this would result in a runtime error, _if and only if_ the program attempts to execute c\[0\], correct?
2. If an instruction (this time corresponding to an index from the bitmask, k) contains an invalid opcode, this would result in a runtime error, _if and only if_ the program attempts to execute it, correct?
3. if the skip length function doesn&#x27;t find any bitmask-marked opcodes within the subsequent 24 octets, this bumps the pc to current+24. So if there happened to be a valid opcode &amp; args at that new pc, it would continue executing at the new pc in the same manner as if it were marked by the instruction bitmask, correct?

Jan Bujak</div>
<div class='msg'><time>2025‑04‑22 12:35</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * Got a few small questions about PVM edge cases-&gt;

1. If c\[0\] isn&#x27;t a valid opcode, this would result in a runtime error, _if and only if_ the program attempts to execute c\[0\], correct?
2. If an instruction (this time corresponding to an index from the bitmask, k) contains an invalid opcode, this would result in a runtime error, _if and only if_ the program attempts to execute it, correct?
3. if the skip length function doesn&#x27;t find any bitmask-marked opcodes within the subsequent 24 octets, this bumps the pc to current+24. So if there happened to be a valid opcode &amp; args at that new pc, it would continue executing at the new pc in the same manner as if it were marked by the instruction bitmask, correct?

Jan Bujak</div>
<div class='msg'><time>2025‑04‑22 12:36</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * Got a few small questions about PVM edge cases, to confirm my understanding-&gt;

1. If c\[0\] isn&#x27;t a valid opcode, this would result in a runtime error, _if and only if_ the program attempts to execute c\[0\], correct?
2. If an instruction (this time corresponding to an index from the bitmask, k) contains an invalid opcode, this would result in a runtime error, _if and only if_ the program attempts to execute it, correct?
3. if the skip length function doesn&#x27;t find any bitmask-marked opcodes within the subsequent 24 octets, this bumps the pc to current+24. So if there happened to be a valid opcode &amp; args at that new pc, it would continue executing at the new pc in the same manner as if it were marked by the instruction bitmask, correct?

Jan Bujak</div>
<div class='msg'><time>2025‑04‑22 12:55</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * Got a few small questions about PVM edge cases, to confirm my understanding-&gt;

1. If c\[0\] isn&#x27;t a valid opcode, this would result in a panic, _if and only if_ the program attempts to execute c\[0\], correct?
2. If an instruction (this time corresponding to an index from the bitmask, k) contains an invalid opcode, this would result in a panic, _if and only if_ the program attempts to execute it, correct?
3. if the skip length function doesn&#x27;t find any bitmask-marked opcodes within the subsequent 24 octets, this bumps the pc to current+24. So if there happened to be a valid opcode &amp; args at that new pc, it would continue executing at the new pc in the same manner as if it were marked by the instruction bitmask, correct?

Jan Bujak</div>
<div class='msg'><time>2025‑04‑22 13:00</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Yes, currently &quot;invalid&quot; instructions don&#x27;t make the program invalid, and only have an effect if executed. Yes, if there&#x27;s no `1` found in the bitmask then the skip is assumed to be 24. Note that IIRC currently even if the next instruction has `0` in its opcode bitmask bit (i.e. the next bit after the last bit that the bitmask scan checks) the instruction will also be executed, but this is not intended behavior and is on my TODO list to add to the GP that every instruction must have a `1` in the bitmask to be considered valid (otherwise we&#x27;ll run into some nasty corner cases).</div>
<div class='msg'><time>2025‑04‑22 13:00</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: * Yes, currently &quot;invalid&quot; instructions don&#x27;t make the program invalid, and only have an effect if executed (they&#x27;re effectively treated as a trap). Yes, if there&#x27;s no `1` found in the bitmask then the skip is assumed to be 24. Note that IIRC currently even if the next instruction has `0` in its opcode bitmask bit (i.e. the next bit after the last bit that the bitmask scan checks) the instruction will also be executed, but this is not intended behavior and is on my TODO list to add to the GP that every instruction must have a `1` in the bitmask to be considered valid (otherwise we&#x27;ll run into some nasty corner cases).</div>
<div class='msg'><time>2025‑04‑22 13:04</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: Many thanks for the quick response 🙏, your insight on the TODO is much appreciated. enjoy your evening.</div>
<div class='msg'><time>2025‑04‑22 13:08</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: Also, while we&#x27;re at the topic parsing, (this is going to be relevant to people aiming for M3 and M4) in case you&#x27;re wondering why the limit is 24 - it was deliberately picked to allow for fast parsing. To parse a PVM instruction at a given position you need to read only two values from memory: a 128-bit integer from the instructions slice, and a 32-bit integer from the bitmask slice, and then you can easily parse it in an efficient manner with bitshifts etc. (for the bitmask one can use the &quot;leading zeros&quot; intrinsic/method which is a single assembly instruction on modern CPUs to cheaply get the skip to get to the next instruction, hence the maximum is 24)</div>
<div class='msg'><time>2025‑04‑22 13:10</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: corner case of the corner case might be a  &#x27;greater than 24 octet&#x27; break in instructions after a valid program termination instruction-&gt; (ie is the subsequent &#x27;valid&#x27; instruction also a &#x27;valid&#x27; jump target, or is the jump target the &#x27;invalid&#x27; 24th octet)</div>
<div class='msg'><time>2025‑04‑22 13:12</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: IIRC the jumps actually check that the previous instruction has the `1` set in its bitmask (because you can only jump either to offset=0 or after block terminators)</div>
<div class='msg'><time>2025‑04‑22 13:12</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * corner case of the corner case might be a  &#x27;greater than 24 octet&#x27; break in instructions after a valid basic block termination instruction-&gt; (ie is the subsequent &#x27;valid&#x27; instruction also a &#x27;valid&#x27; jump target, or is the jump target the &#x27;invalid&#x27; 24th octet)

edit: &#x27;program termination&#x27; -&gt; &#x27;basic block&#x27;</div>
<div class='msg'><time>2025‑04‑22 13:13</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * corner case of the corner case might be a  &#x27;greater than 24 octet&#x27; break in instructions after a valid basic block termination instruction-&gt; (ie is the subsequent &#x27;valid&#x27; instruction also a &#x27;valid&#x27; jump target, or is the jump target the &#x27;invalid&#x27; 24th octet)

edit: &#x27;program termination&#x27; -&gt; &#x27;basic block&#x27; (brain fart)</div>
<div class='msg'><time>2025‑04‑22 13:14</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: So with the current way things are you might get a paradoxical block terminator that would execute when you arrive at it from the previous instruction, but wouldn&#x27;t be a valid target for a jump.</div>
<div class='msg'><time>2025‑04‑22 13:14</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: (again, I want to require all instructions to have 1 set in its bitmask to prevent such potential corner cases)</div>
<div class='msg'><time>2025‑04‑22 13:15</time>&ensp;<span class='u' style='color:#da5c80'>jan</span>: * So with the current way things are you might get a paradoxical block terminator that would execute when you arrive at it from the previous instruction, but the next instruction wouldn&#x27;t be a valid target for a jump.</div>
<div class='msg'><time>2025‑04‑22 13:20</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: </div>
<div class='msg'><time>2025‑04‑22 13:22</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * jumps target indexes in w (basic block index set), which is calculated by applying the skip-length function to each opcode index in the k bitmask*-&gt; so this would result in a jump target of the 24th octet (our &#x27;invalid&#x27; instruction)

edit: *k also includes c[0] always</div>
<div class='msg'><time>2025‑04‑22 13:22</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * jumps target indexes in w (basic block index set), which is calculated by applying the skip-length function to each opcode index in the k bitmask\*-&gt; so this would result in a jump target of the 24th octet (our &#x27;invalid&#x27; instruction)

edit: \*k always includes c\[0\]</div>
<div class='msg'><time>2025‑04‑22 13:23</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * jumps target indexes in w (basic block index set), which is calculated by applying the skip-length function to each opcode index in the k bitmask\*-&gt; so this would result in a jump target of the 24th octet (our &#x27;invalid&#x27; instruction)



edit: \*additionally, k always includes c\[0\]</div>
<div class='msg'><time>2025‑04‑22 13:23</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * jumps target indexes in w (basic block index set), which is calculated by applying the skip-length function to each opcode index in the k bitmask\*-&gt; so this would result in a jump target of the 24th octet (our &#x27;invalid&#x27; instruction).


edit: \*additionally, k always includes c\[0\]</div>
<div class='msg'><time>2025‑04‑22 13:24</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: * jumps target indexes in w (basic block index set), which is calculated by applying the skip-length function to each opcode index in the k bitmask\*-&gt; so this would result in a jump target of the 24th octet (our &#x27;invalid&#x27; instruction).

edit: *additionally, k always includes offset=0 (c[0])</div>
<div class='msg'><time>2025‑04‑22 13:30</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: actually, looks like both branch &amp; jump use the &#x27;beginning of basic blocks&#x27; collection, *w* (which itself uses the skip-length).</div>
<div class='msg'><time>2025‑04‑22 13:37</time>&ensp;<span class='u' style='color:#825bc4'>jay_ztc</span>: Didn&#x27;t intend for this chat to continue into your off-hours, my apologies. Don&#x27;t worry about looking at this tonight especially given its a non-urgent corner case.</div>
<div class='msg'><time>2025‑04‑22 14:32</time>&ensp;<span class='u' style='color:#5dd07c'>knight1205</span>: Here: https://graypaper.fluffylabs.dev/#/68eaa1f/1bcb011b1702?v=0.6.4

In Eqn 14.14 and 14.15 we are using b which is defined as all the segments exported by all work packages, 
and then we are calculating it&#x27;s merkle root and comparing with segment root of some previously exported segments of any work package. 

Is this what it implies? As segments exported from a work package leads to different segment roots, then in that case how can it be same as segment root of all the segments (from all wps)?</div>
<div class='msg'><time>2025‑04‑22 14:32</time>&ensp;<span class='u' style='color:#5dd07c'>knight1205</span>: * Here: https://graypaper.fluffylabs.dev/#/68eaa1f/1bcb011b1702?v=0.6.4

In Eqn 14.14 and 14.15 we are using s (now b) which is defined as all the segments exported by all work packages, 
and then we are calculating it&#x27;s merkle root and comparing with segment root of some previously exported segments of any work package. 

Is this what it implies? As segments exported from a work package leads to different segment roots, then in that case how can it be same as segment root of all the segments (from all wps)?</div>
